/*
 * Type Definitions for node-gtk (https://github.com/romgrk/node-gtk)
 *
 * These type definitions are automatically generated, do not edit them by hand.
 * If you found a bug fix it in ts-for-gir itself or create a bug report on https://github.com/sammydre/ts-for-gjs
 */
/**
 * TelepathyGLib-0.12
 */

import type Gio from './Gio-2.0';
import type GObject from './GObject-2.0';
import type GLib from './GLib-2.0';

export namespace TelepathyGLib {

enum AccessControlType {
    WHITELIST,
    PUBLISH_LIST,
    GROUP,
    OPEN,
    SUBSCRIBE_OR_PUBLISH_LIST,
    CLOSED,
    NOT_UNDERSTOOD,
}
enum CMInfoSource {
    NONE,
    FILE,
    LIVE,
}
enum CallContentDisposition {
    NONE,
    INITIAL,
}
enum CallContentPacketizationType {
    RTP,
    RAW,
    MSN_WEBCAM,
}
enum CallState {
    UNKNOWN,
    PENDING_INITIATOR,
    INITIALISING,
    INITIALISED,
    ACCEPTED,
    ACTIVE,
    ENDED,
}
enum CallStateChangeReason {
    UNKNOWN,
    PROGRESS_MADE,
    USER_REQUESTED,
    FORWARDED,
    REJECTED,
    NO_ANSWER,
    INVALID_CONTACT,
    PERMISSION_DENIED,
    BUSY,
    INTERNAL_ERROR,
    SERVICE_ERROR,
    NETWORK_ERROR,
    MEDIA_ERROR,
    CONNECTIVITY_ERROR,
}
enum CallStreamCandidateType {
    NONE,
    HOST,
    SERVER_REFLEXIVE,
    PEER_REFLEXIVE,
    RELAY,
    MULTICAST,
}
enum CaptchaCancelReason {
    USER_CANCELLED,
    NOT_SUPPORTED,
    SERVICE_CONFUSED,
}
enum CaptchaStatus {
    LOCAL_PENDING,
    REMOTE_PENDING,
    SUCCEEDED,
    TRY_AGAIN,
    FAILED,
}
enum ChannelChatState {
    GONE,
    INACTIVE,
    ACTIVE,
    PAUSED,
    COMPOSING,
}
enum ChannelContactSearchState {
    NOT_STARTED,
    IN_PROGRESS,
    MORE_AVAILABLE,
    COMPLETED,
    FAILED,
}
enum ChannelGroupChangeReason {
    NONE,
    OFFLINE,
    KICKED,
    BUSY,
    INVITED,
    BANNED,
    ERROR,
    INVALID_CONTACT,
    NO_ANSWER,
    RENAMED,
    PERMISSION_DENIED,
    SEPARATED,
}
enum ChannelTextMessageType {
    NORMAL,
    ACTION,
    NOTICE,
    AUTO_REPLY,
    DELIVERY_REPORT,
}
enum ChannelTextSendError {
    UNKNOWN,
    OFFLINE,
    INVALID_CONTACT,
    PERMISSION_DENIED,
    TOO_LONG,
    NOT_IMPLEMENTED,
}
enum ConnectionPresenceType {
    UNSET,
    OFFLINE,
    AVAILABLE,
    AWAY,
    EXTENDED_AWAY,
    HIDDEN,
    BUSY,
    UNKNOWN,
    ERROR,
}
enum ConnectionStatus {
    CONNECTED,
    CONNECTING,
    DISCONNECTED,
}
enum ConnectionStatusReason {
    NONE_SPECIFIED,
    REQUESTED,
    NETWORK_ERROR,
    AUTHENTICATION_FAILED,
    ENCRYPTION_ERROR,
    NAME_IN_USE,
    CERT_NOT_PROVIDED,
    CERT_UNTRUSTED,
    CERT_EXPIRED,
    CERT_NOT_ACTIVATED,
    CERT_HOSTNAME_MISMATCH,
    CERT_FINGERPRINT_MISMATCH,
    CERT_SELF_SIGNED,
    CERT_OTHER_ERROR,
    CERT_REVOKED,
    CERT_INSECURE,
    CERT_LIMIT_EXCEEDED,
}
enum ContactFeature {
    ALIAS,
    AVATAR_TOKEN,
    PRESENCE,
    LOCATION,
    CAPABILITIES,
    AVATAR_DATA,
    CONTACT_INFO,
    CLIENT_TYPES,
    SUBSCRIPTION_STATES,
    CONTACT_GROUPS,
    CONTACT_BLOCKING,
}
enum ContactListState {
    NONE,
    WAITING,
    FAILURE,
    SUCCESS,
}
enum ContactMetadataStorageType {
    NONE,
    SUBSCRIBED_OR_PENDING,
    SUBSCRIBED,
    ANYONE,
}
enum DBusError {
    UNKNOWN_REMOTE_ERROR,
    PROXY_UNREFERENCED,
    NO_INTERFACE,
    NAME_OWNER_LOST,
    INVALID_BUS_NAME,
    INVALID_INTERFACE_NAME,
    INVALID_OBJECT_PATH,
    INVALID_MEMBER_NAME,
    OBJECT_REMOVED,
    CANCELLED,
    INCONSISTENT,
}
enum DTMFEvent {
    DIGIT_0,
    DIGIT_1,
    DIGIT_2,
    DIGIT_3,
    DIGIT_4,
    DIGIT_5,
    DIGIT_6,
    DIGIT_7,
    DIGIT_8,
    DIGIT_9,
    ASTERISK,
    HASH,
    LETTER_A,
    LETTER_B,
    LETTER_C,
    LETTER_D,
}
enum DebugLevel {
    ERROR,
    CRITICAL,
    WARNING,
    MESSAGE,
    INFO,
    DEBUG,
}
enum DeliveryStatus {
    UNKNOWN,
    DELIVERED,
    TEMPORARILY_FAILED,
    PERMANENTLY_FAILED,
    ACCEPTED,
    READ,
    DELETED,
}
enum Error {
    NETWORK_ERROR,
    NOT_IMPLEMENTED,
    INVALID_ARGUMENT,
    NOT_AVAILABLE,
    PERMISSION_DENIED,
    DISCONNECTED,
    INVALID_HANDLE,
    CHANNEL_BANNED,
    CHANNEL_FULL,
    CHANNEL_INVITE_ONLY,
    NOT_YOURS,
    CANCELLED,
    AUTHENTICATION_FAILED,
    ENCRYPTION_NOT_AVAILABLE,
    ENCRYPTION_ERROR,
    CERT_NOT_PROVIDED,
    CERT_UNTRUSTED,
    CERT_EXPIRED,
    CERT_NOT_ACTIVATED,
    CERT_FINGERPRINT_MISMATCH,
    CERT_HOSTNAME_MISMATCH,
    CERT_SELF_SIGNED,
    CERT_INVALID,
    NOT_CAPABLE,
    OFFLINE,
    CHANNEL_KICKED,
    BUSY,
    NO_ANSWER,
    DOES_NOT_EXIST,
    TERMINATED,
    CONNECTION_REFUSED,
    CONNECTION_FAILED,
    CONNECTION_LOST,
    ALREADY_CONNECTED,
    CONNECTION_REPLACED,
    REGISTRATION_EXISTS,
    SERVICE_BUSY,
    RESOURCE_UNAVAILABLE,
    WOULD_BREAK_ANONYMITY,
    CERT_REVOKED,
    CERT_INSECURE,
    CERT_LIMIT_EXCEEDED,
    NOT_YET,
    REJECTED,
    PICKED_UP_ELSEWHERE,
    CONFUSED,
    SERVICE_CONFUSED,
    EMERGENCY_CALLS_NOT_SUPPORTED,
    SOFTWARE_UPGRADE_REQUIRED,
    INSUFFICIENT_BALANCE,
    MEDIA_CODECS_INCOMPATIBLE,
    MEDIA_UNSUPPORTED_TYPE,
    MEDIA_STREAMING_ERROR,
    CAPTCHA_NOT_SUPPORTED,
}
enum FileHashType {
    NONE,
    MD5,
    SHA1,
    SHA256,
}
enum FileTransferState {
    NONE,
    PENDING,
    ACCEPTED,
    OPEN,
    COMPLETED,
    CANCELLED,
}
enum FileTransferStateChangeReason {
    NONE,
    REQUESTED,
    LOCAL_STOPPED,
    REMOTE_STOPPED,
    LOCAL_ERROR,
    REMOTE_ERROR,
}
enum HTTPMethod {
    GET,
    POST,
}
enum HandleType {
    NONE,
    CONTACT,
    ROOM,
    LIST,
    GROUP,
}
enum LocalHoldState {
    UNHELD,
    HELD,
    PENDING_HOLD,
    PENDING_UNHOLD,
}
enum LocalHoldStateReason {
    NONE,
    REQUESTED,
    RESOURCE_NOT_AVAILABLE,
}
enum MediaStreamBaseProto {
    UDP,
    TCP,
}
enum MediaStreamDirection {
    NONE,
    SEND,
    RECEIVE,
    BIDIRECTIONAL,
}
enum MediaStreamError {
    UNKNOWN,
    EOS,
    CODEC_NEGOTIATION_FAILED,
    CONNECTION_FAILED,
    NETWORK_ERROR,
    NO_CODECS,
    INVALID_CM_BEHAVIOR,
    MEDIA_ERROR,
}
enum MediaStreamState {
    DISCONNECTED,
    CONNECTING,
    CONNECTED,
}
enum MediaStreamTransportType {
    LOCAL,
    DERIVED,
    RELAY,
}
enum MediaStreamType {
    AUDIO,
    VIDEO,
}
enum RCPTXRRTTMode {
    ALL,
    SENDER,
}
enum RichPresenceAccessControlType {
    WHITELIST,
    PUBLISH_LIST,
    GROUP,
    OPEN,
}
enum SASLAbortReason {
    INVALID_CHALLENGE,
    USER_ABORT,
}
enum SASLStatus {
    NOT_STARTED,
    IN_PROGRESS,
    SERVER_SUCCEEDED,
    CLIENT_ACCEPTED,
    SUCCEEDED,
    SERVER_FAILED,
    CLIENT_FAILED,
}
enum SendingState {
    NONE,
    PENDING_SEND,
    SENDING,
    PENDING_STOP_SENDING,
}
enum ServicePointType {
    NONE,
    EMERGENCY,
    COUNSELING,
}
enum SocketAccessControl {
    LOCALHOST,
    PORT,
    NETMASK,
    CREDENTIALS,
}
enum SocketAddressType {
    UNIX,
    ABSTRACT_UNIX,
    IPV4,
    IPV6,
}
enum StreamComponent {
    UNKNOWN,
    DATA,
    CONTROL,
}
enum StreamEndpointState {
    CONNECTING,
    PROVISIONALLY_CONNECTED,
    FULLY_CONNECTED,
    EXHAUSTED_CANDIDATES,
    FAILED,
}
enum StreamFlowState {
    STOPPED,
    PENDING_START,
    PENDING_STOP,
    STARTED,
}
enum StreamTransportType {
    UNKNOWN,
    RAW_UDP,
    ICE,
    GTALK_P2P,
    WLM_2009,
    SHM,
    MULTICAST,
}
enum SubscriptionState {
    UNKNOWN,
    NO,
    REMOVED_REMOTELY,
    ASK,
    YES,
}
enum TLSCertificateRejectReason {
    UNKNOWN,
    UNTRUSTED,
    EXPIRED,
    NOT_ACTIVATED,
    FINGERPRINT_MISMATCH,
    HOSTNAME_MISMATCH,
    SELF_SIGNED,
    REVOKED,
    INSECURE,
    LIMIT_EXCEEDED,
}
enum TLSCertificateState {
    PENDING,
    ACCEPTED,
    REJECTED,
}
enum TubeChannelState {
    LOCAL_PENDING,
    REMOTE_PENDING,
    OPEN,
    NOT_OFFERED,
}
enum TubeState {
    LOCAL_PENDING,
    REMOTE_PENDING,
    OPEN,
}
enum TubeType {
    DBUS,
    STREAM,
}
enum AnonymityModeFlags {
    CLIENT_INFO,
    SHOW_CLIENT_INFO,
    NETWORK_INFO,
}
enum CallFlags {
    LOCALLY_HELD,
    LOCALLY_RINGING,
    LOCALLY_QUEUED,
    FORWARDED,
    CLEARING,
}
enum CallMemberFlags {
    RINGING,
    HELD,
    CONFERENCE_HOST,
}
enum CaptchaFlags {
    CAPTCHA_FLAGS_REQUIRED,
}
enum ChannelCallStateFlags {
    RINGING,
    QUEUED,
    HELD,
    FORWARDED,
    IN_PROGRESS,
    CONFERENCE_HOST,
}
enum ChannelGroupFlags {
    CAN_ADD,
    CAN_REMOVE,
    CAN_RESCIND,
    MESSAGE_ADD,
    MESSAGE_REMOVE,
    MESSAGE_ACCEPT,
    MESSAGE_REJECT,
    MESSAGE_RESCIND,
    CHANNEL_SPECIFIC_HANDLES,
    ONLY_ONE_GROUP,
    HANDLE_OWNERS_NOT_AVAILABLE,
    PROPERTIES,
    MEMBERS_CHANGED_DETAILED,
    MESSAGE_DEPART,
}
enum ChannelMediaCapabilities {
    AUDIO,
    VIDEO,
    NAT_TRAVERSAL_STUN,
    NAT_TRAVERSAL_GTALK_P2P,
    NAT_TRAVERSAL_ICE_UDP,
    IMMUTABLE_STREAMS,
}
enum ChannelPasswordFlags {
    PROVIDE,
    HINT,
}
enum ChannelTextMessageFlags {
    TRUNCATED,
    NON_TEXT_CONTENT,
    SCROLLBACK,
    RESCUED,
}
enum ConnMgrParamFlags {
    REQUIRED,
    REGISTER,
    HAS_DEFAULT,
    SECRET,
    DBUS_PROPERTY,
}
enum ConnectionAliasFlags {
    CONNECTION_ALIAS_FLAG_USER_SET,
}
enum ConnectionCapabilityFlags {
    CREATE,
    INVITE,
}
enum ContactBlockingCapabilities {
    CONTACT_BLOCKING_CAPABILITY_CAN_REPORT_ABUSIVE,
}
enum ContactInfoFieldFlags {
    PARAMETERS_EXACT,
    OVERWRITTEN_BY_NICKNAME,
}
enum ContactInfoFlags {
    CAN_SET,
    PUSH,
}
enum DBusNameType {
    UNIQUE,
    WELL_KNOWN,
    BUS_DAEMON,
    NOT_BUS_DAEMON,
    ANY,
}
enum DBusPropertiesMixinFlags {
    READ,
    WRITE,
    EMITS_CHANGED,
    EMITS_INVALIDATED,
}
enum DeliveryReportingSupportFlags {
    FAILURES,
    SUCCESSES,
    READ,
    DELETED,
}
enum LocationFeatures {
    LOCATION_FEATURE_CAN_SET,
}
enum MailNotificationFlags {
    SUPPORTS_UNREAD_MAIL_COUNT,
    SUPPORTS_UNREAD_MAILS,
    EMITS_MAILS_RECEIVED,
    SUPPORTS_REQUEST_INBOX_URL,
    SUPPORTS_REQUEST_MAIL_URL,
    THREAD_BASED,
}
enum MediaStreamPendingSend {
    LOCAL_SEND,
    REMOTE_SEND,
}
enum MessagePartSupportFlags {
    ONE_ATTACHMENT,
    MULTIPLE_ATTACHMENTS,
}
enum MessageSendingFlags {
    DELIVERY,
    READ,
    DELETED,
}
enum PropertyFlags {
    READ,
    WRITE,
}
enum RTCPXRStatisticsFlags {
    LOSS,
    DUPLICATE,
    JITTER,
    TTL,
    HL,
}
enum StorageRestrictionFlags {
    PARAMETERS,
    ENABLED,
    PRESENCE,
    SERVICE,
}
const ACCOUNT_MANAGER_BUS_NAME: string
const ACCOUNT_MANAGER_OBJECT_PATH: string
const ACCOUNT_OBJECT_PATH_BASE: string
const CHANNEL_DISPATCHER_BUS_NAME: string
const CHANNEL_DISPATCHER_OBJECT_PATH: string
const CLIENT_BUS_NAME_BASE: string
const CLIENT_OBJECT_PATH_BASE: string
const CM_BUS_NAME_BASE: string
const CM_OBJECT_PATH_BASE: string
const CONN_BUS_NAME_BASE: string
const CONN_OBJECT_PATH_BASE: string

const DEBUG_OBJECT_PATH: string
const ERROR_PREFIX: string
const IFACE_ACCOUNT: string
const IFACE_ACCOUNT_INTERFACE_ADDRESSING: string
const IFACE_ACCOUNT_INTERFACE_AVATAR: string
const IFACE_ACCOUNT_INTERFACE_STORAGE: string
const IFACE_ACCOUNT_MANAGER: string
const IFACE_AUTHENTICATION_TLS_CERTIFICATE: string
const IFACE_CALL_CONTENT: string
const IFACE_CALL_CONTENT_INTERFACE_AUDIO_CONTROL: string
const IFACE_CALL_CONTENT_INTERFACE_DTMF: string
const IFACE_CALL_CONTENT_INTERFACE_MEDIA: string
const IFACE_CALL_CONTENT_INTERFACE_VIDEO_CONTROL: string
const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION: string
const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS: string
const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK: string
const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS: string
const IFACE_CALL_STREAM: string
const IFACE_CALL_STREAM_ENDPOINT: string
const IFACE_CALL_STREAM_INTERFACE_MEDIA: string
const IFACE_CHANNEL: string
const IFACE_CHANNEL_DISPATCHER: string
const IFACE_CHANNEL_DISPATCHER_INTERFACE_MESSAGES1: string
const IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST: string
const IFACE_CHANNEL_DISPATCH_OPERATION: string
const IFACE_CHANNEL_INTERFACE_ANONYMITY: string
const IFACE_CHANNEL_INTERFACE_CALL_STATE: string
const IFACE_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION: string
const IFACE_CHANNEL_INTERFACE_CHAT_STATE: string
const IFACE_CHANNEL_INTERFACE_CONFERENCE: string
const IFACE_CHANNEL_INTERFACE_DESTROYABLE: string
const IFACE_CHANNEL_INTERFACE_DTMF: string
const IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA: string
const IFACE_CHANNEL_INTERFACE_GROUP: string
const IFACE_CHANNEL_INTERFACE_HOLD: string
const IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING: string
const IFACE_CHANNEL_INTERFACE_MESSAGES: string
const IFACE_CHANNEL_INTERFACE_PASSWORD: string
const IFACE_CHANNEL_INTERFACE_ROOM: string
const IFACE_CHANNEL_INTERFACE_ROOM_CONFIG: string
const IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION: string
const IFACE_CHANNEL_INTERFACE_SECURABLE: string
const IFACE_CHANNEL_INTERFACE_SERVICE_POINT: string
const IFACE_CHANNEL_INTERFACE_SMS: string
const IFACE_CHANNEL_INTERFACE_SUBJECT: string
const IFACE_CHANNEL_INTERFACE_TUBE: string
const IFACE_CHANNEL_REQUEST: string
const IFACE_CHANNEL_TYPE_CALL: string
const IFACE_CHANNEL_TYPE_CONTACT_LIST: string
const IFACE_CHANNEL_TYPE_CONTACT_SEARCH: string
const IFACE_CHANNEL_TYPE_DBUS_TUBE: string
const IFACE_CHANNEL_TYPE_FILE_TRANSFER: string
const IFACE_CHANNEL_TYPE_ROOM_LIST: string
const IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION: string
const IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION: string
const IFACE_CHANNEL_TYPE_STREAMED_MEDIA: string
const IFACE_CHANNEL_TYPE_STREAM_TUBE: string
const IFACE_CHANNEL_TYPE_TEXT: string
const IFACE_CHANNEL_TYPE_TUBES: string
const IFACE_CLIENT: string
const IFACE_CLIENT_APPROVER: string
const IFACE_CLIENT_HANDLER: string
const IFACE_CLIENT_INTERFACE_REQUESTS: string
const IFACE_CLIENT_OBSERVER: string
const IFACE_CONNECTION: string
const IFACE_CONNECTION_INTERFACE_ADDRESSING: string
const IFACE_CONNECTION_INTERFACE_ALIASING: string
const IFACE_CONNECTION_INTERFACE_ANONYMITY: string
const IFACE_CONNECTION_INTERFACE_AVATARS: string
const IFACE_CONNECTION_INTERFACE_BALANCE: string
const IFACE_CONNECTION_INTERFACE_CAPABILITIES: string
const IFACE_CONNECTION_INTERFACE_CELLULAR: string
const IFACE_CONNECTION_INTERFACE_CLIENT_TYPES: string
const IFACE_CONNECTION_INTERFACE_CONTACTS: string
const IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING: string
const IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES: string
const IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS: string
const IFACE_CONNECTION_INTERFACE_CONTACT_INFO: string
const IFACE_CONNECTION_INTERFACE_CONTACT_LIST: string
const IFACE_CONNECTION_INTERFACE_LOCATION: string
const IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION: string
const IFACE_CONNECTION_INTERFACE_POWER_SAVING: string
const IFACE_CONNECTION_INTERFACE_PRESENCE: string
const IFACE_CONNECTION_INTERFACE_RENAMING: string
const IFACE_CONNECTION_INTERFACE_REQUESTS: string
const IFACE_CONNECTION_INTERFACE_SERVICE_POINT: string
const IFACE_CONNECTION_INTERFACE_SIDECARS1: string
const IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE: string
const IFACE_CONNECTION_MANAGER: string
const IFACE_DBUS_DAEMON: string
const IFACE_DBUS_INTROSPECTABLE: string
const IFACE_DBUS_PEER: string
const IFACE_DBUS_PROPERTIES: string
const IFACE_DEBUG: string
const IFACE_MEDIA_SESSION_HANDLER: string
const IFACE_MEDIA_STREAM_HANDLER: string
const IFACE_PROPERTIES_INTERFACE: string
const IFACE_PROTOCOL: string
const IFACE_PROTOCOL_INTERFACE_ADDRESSING: string
const IFACE_PROTOCOL_INTERFACE_AVATARS: string
const IFACE_PROTOCOL_INTERFACE_PRESENCE: string

const NUM_ACCESS_CONTROL_TYPES: number
const NUM_CALL_CONTENT_DISPOSITIONS: number
const NUM_CALL_CONTENT_PACKETIZATION_TYPES: number
const NUM_CALL_STATES: number
const NUM_CALL_STATE_CHANGE_REASONS: number
const NUM_CALL_STREAM_CANDIDATE_TYPES: number
const NUM_CAPTCHA_CANCEL_REASONS: number
const NUM_CAPTCHA_STATUSES: number
const NUM_CHANNEL_CHAT_STATES: number
const NUM_CHANNEL_CONTACT_SEARCH_STATES: number
const NUM_CHANNEL_GROUP_CHANGE_REASONS: number
const NUM_CHANNEL_TEXT_MESSAGE_TYPES: number
const NUM_CHANNEL_TEXT_SEND_ERRORS: number
const NUM_CONNECTION_PRESENCE_TYPES: number
const NUM_CONNECTION_STATUSES: number
const NUM_CONNECTION_STATUS_REASONS: number
const NUM_CONTACT_FEATURES: number
const NUM_CONTACT_LIST_STATES: number
const NUM_CONTACT_METADATA_STORAGE_TYPES: number
const NUM_DBUS_ERRORS: number
const NUM_DEBUG_LEVELS: number
const NUM_DELIVERY_STATUSES: number
const NUM_DTMF_EVENTS: number
const NUM_FILE_HASH_TYPES: number
const NUM_FILE_TRANSFER_STATES: number
const NUM_FILE_TRANSFER_STATE_CHANGE_REASONS: number
const NUM_HANDLE_TYPES: number
const NUM_HTTP_METHODS: number
const NUM_LOCAL_HOLD_STATES: number
const NUM_LOCAL_HOLD_STATE_REASONS: number
const NUM_MEDIA_STREAM_BASE_PROTOS: number
const NUM_MEDIA_STREAM_DIRECTIONS: number
const NUM_MEDIA_STREAM_ERRORS: number
const NUM_MEDIA_STREAM_STATES: number
const NUM_MEDIA_STREAM_TRANSPORT_TYPES: number
const NUM_MEDIA_STREAM_TYPES: number
const NUM_RCPT_XR_RTT_MODES: number
const NUM_RICH_PRESENCE_ACCESS_CONTROL_TYPES: number
const NUM_SASL_ABORT_REASONS: number
const NUM_SASL_STATUSES: number
const NUM_SENDING_STATES: number
const NUM_SERVICE_POINT_TYPES: number
const NUM_SOCKET_ACCESS_CONTROLS: number
const NUM_SOCKET_ADDRESS_TYPES: number
const NUM_STREAM_COMPONENTS: number
const NUM_STREAM_ENDPOINT_STATES: number
const NUM_STREAM_FLOW_STATES: number
const NUM_STREAM_TRANSPORT_TYPES: number
const NUM_SUBSCRIPTION_STATES: number
const NUM_TLS_CERTIFICATE_REJECT_REASONS: number
const NUM_TLS_CERTIFICATE_STATES: number
const NUM_TUBE_CHANNEL_STATES: number
const NUM_TUBE_STATES: number
const NUM_TUBE_TYPES: number
const PROP_ACCOUNT_AUTOMATIC_PRESENCE: string
const PROP_ACCOUNT_CHANGING_PRESENCE: string
const PROP_ACCOUNT_CONNECTION: string
const PROP_ACCOUNT_CONNECTION_ERROR: string
const PROP_ACCOUNT_CONNECTION_ERROR_DETAILS: string
const PROP_ACCOUNT_CONNECTION_STATUS: string
const PROP_ACCOUNT_CONNECTION_STATUS_REASON: string
const PROP_ACCOUNT_CONNECT_AUTOMATICALLY: string
const PROP_ACCOUNT_CURRENT_PRESENCE: string
const PROP_ACCOUNT_DISPLAY_NAME: string
const PROP_ACCOUNT_ENABLED: string
const PROP_ACCOUNT_HAS_BEEN_ONLINE: string
const PROP_ACCOUNT_ICON: string
const PROP_ACCOUNT_INTERFACES: string
const PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES: string
const PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR: string
const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER: string
const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER: string
const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS: string
const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION: string
const PROP_ACCOUNT_MANAGER_INTERFACES: string
const PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS: string
const PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES: string
const PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS: string
const PROP_ACCOUNT_NICKNAME: string
const PROP_ACCOUNT_NORMALIZED_NAME: string
const PROP_ACCOUNT_PARAMETERS: string
const PROP_ACCOUNT_REQUESTED_PRESENCE: string
const PROP_ACCOUNT_SERVICE: string
const PROP_ACCOUNT_SUPERSEDES: string
const PROP_ACCOUNT_VALID: string
const PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA: string
const PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE: string
const PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS: string
const PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE: string
const PROP_CALL_CONTENT_DISPOSITION: string
const PROP_CALL_CONTENT_INTERFACES: string
const PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_INPUT_VOLUME: string
const PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_OUTPUT_VOLUME: string
const PROP_CALL_CONTENT_INTERFACE_DTMF_CURRENTLY_SENDING_TONES: string
const PROP_CALL_CONTENT_INTERFACE_DTMF_DEFERRED_TONES: string
const PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_EVENT: string
const PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_STATE: string
const PROP_CALL_CONTENT_INTERFACE_MEDIA_LOCAL_MEDIA_DESCRIPTIONS: string
const PROP_CALL_CONTENT_INTERFACE_MEDIA_MEDIA_DESCRIPTION_OFFER: string
const PROP_CALL_CONTENT_INTERFACE_MEDIA_PACKETIZATION: string
const PROP_CALL_CONTENT_INTERFACE_MEDIA_REMOTE_MEDIA_DESCRIPTIONS: string
const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_BITRATE: string
const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_FRAMERATE: string
const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MANUAL_KEY_FRAMES: string
const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MTU: string
const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_VIDEO_RESOLUTION: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_CODECS: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_FURTHER_NEGOTIATION_REQUIRED: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_HAS_REMOTE_INFORMATION: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACES: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DLRR_MAX_SIZE: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DUPLICATE_RLE_MAX_SIZE: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_ENABLE_METRICS: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_LOSS_RLE_MAX_SIZE: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_PACKET_RECEIPT_TIMES_MAX_SIZE: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_RTT_MODE: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_STATISTICS_FLAGS: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_DOES_AVPF: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_FEEDBACK_MESSAGES: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS_HEADER_EXTENSIONS: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_REMOTE_CONTACT: string
const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_SSRCS: string
const PROP_CALL_CONTENT_NAME: string
const PROP_CALL_CONTENT_STREAMS: string
const PROP_CALL_CONTENT_TYPE: string
const PROP_CALL_STREAM_CAN_REQUEST_RECEIVING: string
const PROP_CALL_STREAM_ENDPOINT_CONTROLLING: string
const PROP_CALL_STREAM_ENDPOINT_ENDPOINT_STATE: string
const PROP_CALL_STREAM_ENDPOINT_IS_ICE_LITE: string
const PROP_CALL_STREAM_ENDPOINT_REMOTE_CANDIDATES: string
const PROP_CALL_STREAM_ENDPOINT_REMOTE_CREDENTIALS: string
const PROP_CALL_STREAM_ENDPOINT_SELECTED_CANDIDATE_PAIRS: string
const PROP_CALL_STREAM_ENDPOINT_TRANSPORT: string
const PROP_CALL_STREAM_INTERFACES: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_ENDPOINTS: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_HAS_SERVER_INFO: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_ICE_RESTART_PENDING: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CANDIDATES: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CREDENTIALS: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_RECEIVING_STATE: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_RELAY_INFO: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_SENDING_STATE: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_STUN_SERVERS: string
const PROP_CALL_STREAM_INTERFACE_MEDIA_TRANSPORT: string
const PROP_CALL_STREAM_LOCAL_SENDING_STATE: string
const PROP_CALL_STREAM_REMOTE_MEMBERS: string
const PROP_CALL_STREAM_REMOTE_MEMBER_IDENTIFIERS: string
const PROP_CHANNEL_CHANNEL_TYPE: string
const PROP_CHANNEL_DISPATCHER_INTERFACES: string
const PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS: string
const PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS: string
const PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT: string
const PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS: string
const PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION: string
const PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES: string
const PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS: string
const PROP_CHANNEL_INITIATOR_HANDLE: string
const PROP_CHANNEL_INITIATOR_ID: string
const PROP_CHANNEL_INTERFACES: string
const PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY: string
const PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES: string
const PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID: string
const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAN_RETRY_CAPTCHA: string
const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR: string
const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR_DETAILS: string
const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_STATUS: string
const PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES: string
const PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS: string
const PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS: string
const PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES: string
const PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS: string
const PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE: string
const PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS: string
const PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES: string
const PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES: string
const PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES: string
const PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA: string
const PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME: string
const PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS: string
const PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS: string
const PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS: string
const PROP_CHANNEL_INTERFACE_GROUP_MEMBERS: string
const PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS: string
const PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS: string
const PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE: string
const PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT: string
const PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS: string
const PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES: string
const PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES: string
const PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE: string
const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE: string
const PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP: string
const PROP_CHANNEL_INTERFACE_ROOM_CREATOR: string
const PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE: string
const PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME: string
const PROP_CHANNEL_INTERFACE_ROOM_SERVER: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS: string
const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS: string
const PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED: string
const PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED: string
const PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT: string
const PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT: string
const PROP_CHANNEL_INTERFACE_SMS_FLASH: string
const PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL: string
const PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR: string
const PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE: string
const PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET: string
const PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT: string
const PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP: string
const PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS: string
const PROP_CHANNEL_INTERFACE_TUBE_STATE: string
const PROP_CHANNEL_REQUESTED: string
const PROP_CHANNEL_REQUEST_ACCOUNT: string
const PROP_CHANNEL_REQUEST_HINTS: string
const PROP_CHANNEL_REQUEST_INTERFACES: string
const PROP_CHANNEL_REQUEST_PREFERRED_HANDLER: string
const PROP_CHANNEL_REQUEST_REQUESTS: string
const PROP_CHANNEL_REQUEST_USER_ACTION_TIME: string
const PROP_CHANNEL_TARGET_HANDLE: string
const PROP_CHANNEL_TARGET_HANDLE_TYPE: string
const PROP_CHANNEL_TARGET_ID: string
const PROP_CHANNEL_TYPE_CALL_CALL_FLAGS: string
const PROP_CHANNEL_TYPE_CALL_CALL_MEMBERS: string
const PROP_CHANNEL_TYPE_CALL_CALL_STATE: string
const PROP_CHANNEL_TYPE_CALL_CALL_STATE_DETAILS: string
const PROP_CHANNEL_TYPE_CALL_CALL_STATE_REASON: string
const PROP_CHANNEL_TYPE_CALL_CONTENTS: string
const PROP_CHANNEL_TYPE_CALL_HARDWARE_STREAMING: string
const PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO: string
const PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO_NAME: string
const PROP_CHANNEL_TYPE_CALL_INITIAL_TRANSPORT: string
const PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO: string
const PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO_NAME: string
const PROP_CHANNEL_TYPE_CALL_MEMBER_IDENTIFIERS: string
const PROP_CHANNEL_TYPE_CALL_MUTABLE_CONTENTS: string
const PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS: string
const PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT: string
const PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE: string
const PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER: string
const PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES: string
const PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME: string
const PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_FILE_COLLECTION: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES: string
const PROP_CHANNEL_TYPE_FILE_TRANSFER_URI: string
const PROP_CHANNEL_TYPE_ROOM_LIST_SERVER: string
const PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD: string
const PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME: string
const PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES: string
const PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE: string
const PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS: string
const PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO: string
const PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO: string
const PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE: string
const PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES: string
const PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER: string
const PROP_CLIENT_HANDLER_BYPASS_APPROVAL: string
const PROP_CLIENT_HANDLER_CAPABILITIES: string
const PROP_CLIENT_HANDLER_HANDLED_CHANNELS: string
const PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER: string
const PROP_CLIENT_INTERFACES: string
const PROP_CLIENT_OBSERVER_DELAY_APPROVERS: string
const PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER: string
const PROP_CLIENT_OBSERVER_RECOVER: string
const PROP_CONNECTION_HAS_IMMORTAL_HANDLES: string
const PROP_CONNECTION_INTERFACES: string
const PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY: string
const PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES: string
const PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES: string
const PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES: string
const PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT: string
const PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH: string
const PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT: string
const PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH: string
const PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT: string
const PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH: string
const PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES: string
const PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE: string
const PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI: string
const PROP_CONNECTION_INTERFACE_CELLULAR_IMSI: string
const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET: string
const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET: string
const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE: string
const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD: string
const PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE: string
const PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES: string
const PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES: string
const PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS: string
const PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS: string
const PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE: string
const PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS: string
const PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS: string
const PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST: string
const PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS: string
const PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE: string
const PROP_CONNECTION_INTERFACE_CONTACT_LIST_DOWNLOAD_AT_CONNECTION: string
const PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE: string
const PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL: string
const PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES: string
const PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES: string
const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS: string
const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS: string
const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS: string
const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT: string
const PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE: string
const PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS: string
const PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES: string
const PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS: string
const PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH: string
const PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES: string
const PROP_CONNECTION_MANAGER_INTERFACES: string
const PROP_CONNECTION_MANAGER_PROTOCOLS: string
const PROP_CONNECTION_SELF_HANDLE: string
const PROP_CONNECTION_SELF_ID: string
const PROP_CONNECTION_STATUS: string
const PROP_DEBUG_ENABLED: string
const PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY: string
const PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL: string
const PROP_MEDIA_STREAM_HANDLER_RELAY_INFO: string
const PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS: string
const PROP_PROTOCOL_AUTHENTICATION_TYPES: string
const PROP_PROTOCOL_CONNECTION_INTERFACES: string
const PROP_PROTOCOL_ENGLISH_NAME: string
const PROP_PROTOCOL_ICON: string
const PROP_PROTOCOL_INTERFACES: string
const PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES: string
const PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS: string
const PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES: string
const PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT: string
const PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH: string
const PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT: string
const PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH: string
const PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT: string
const PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH: string
const PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES: string
const PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES: string
const PROP_PROTOCOL_PARAMETERS: string
const PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES: string
const PROP_PROTOCOL_VCARD_FIELD: string
const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P: string
const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP: string
const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009: string
const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5: string
const TOKEN_CHANNEL_TYPE_CALL_AUDIO: string
const TOKEN_CHANNEL_TYPE_CALL_GTALK_P2P: string
const TOKEN_CHANNEL_TYPE_CALL_ICE: string
const TOKEN_CHANNEL_TYPE_CALL_SHM: string
const TOKEN_CHANNEL_TYPE_CALL_VIDEO: string
const TOKEN_CHANNEL_TYPE_CALL_WLM_2009: string
const TOKEN_CONNECTION_CONTACT_ID: string
const TOKEN_CONNECTION_INTERFACE_ADDRESSING_ADDRESSES: string
const TOKEN_CONNECTION_INTERFACE_ADDRESSING_URIS: string
const TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS: string
const TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN: string
const TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS: string
const TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES: string
const TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED: string
const TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES: string
const TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS: string
const TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO: string
const TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH: string
const TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST: string
const TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE: string
const TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION: string
const TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE: string
const UNKNOWN_CONNECTION_STATUS: ConnectionStatus
const UNKNOWN_HANDLE_TYPE: HandleType
const USER_ACTION_TIME_NOT_USER_ACTION: number
function asvGetBoolean(asv: GLib.HashTable, key: string): [ /* returnType */ boolean, /* valid */ boolean ]
function asvGetBoxed(asv: GLib.HashTable, key: string, type: GObject.Type): object | null
function asvGetBytes(asv: GLib.HashTable, key: string): Uint8Array | null
function asvGetDouble(asv: GLib.HashTable, key: string): [ /* returnType */ number, /* valid */ boolean ]
function asvGetInt32(asv: GLib.HashTable, key: string): [ /* returnType */ number, /* valid */ boolean ]
function asvGetInt64(asv: GLib.HashTable, key: string): [ /* returnType */ number, /* valid */ boolean ]
function asvGetObjectPath(asv: GLib.HashTable, key: string): string | null
function asvGetString(asv: GLib.HashTable, key: string): string | null
function asvGetStrv(asv: GLib.HashTable, key: string): string[] | null
function asvGetUint32(asv: GLib.HashTable, key: string): [ /* returnType */ number, /* valid */ boolean ]
function asvGetUint64(asv: GLib.HashTable, key: string): [ /* returnType */ number, /* valid */ boolean ]
function dbusCheckValidBusName(name: string, allowTypes: DBusNameType): boolean
function dbusCheckValidInterfaceName(name: string): boolean
function dbusCheckValidMemberName(name: string): boolean
function dbusCheckValidObjectPath(path: string): boolean
function dbusErrorsQuark(): GLib.Quark
function dbusPropertiesMixinClassInit(cls: GObject.ObjectClass, offset: number): void
function dbusPropertiesMixinDupAll(self: GObject.Object, interfaceName: string): GLib.HashTable
function dbusPropertiesMixinEmitPropertiesChanged(object: GObject.Object, interfaceName: string, properties?: string | null): void
function dbusPropertiesMixinGet(self: GObject.Object, interfaceName: string, propertyName: string, value: any): boolean
function dbusPropertiesMixinGetterGobjectProperties(object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, getterData?: object | null): void
function dbusPropertiesMixinIfaceInit(gIface?: object | null, ifaceData?: object | null): void
function dbusPropertiesMixinSet(self: GObject.Object, interfaceName: string, propertyName: string, value: any): boolean
function dbusPropertiesMixinSetterGobjectProperties(object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, setterData?: object | null): boolean
function debugDivertMessages(filename: string): void
function debugSetFlags(flagsString: string): void
function debugSetPersistent(persistent: boolean): void
function debugTimestampedLogHandler(logDomain: string, logLevel: GLib.LogLevelFlags, message: string, ignored?: object | null): void
function errorGetDbusName(error: Error): string
function errorQuark(): GLib.Quark
function errorsDisconnectedQuark(): GLib.Quark
function errorsRemovedFromGroupQuark(): GLib.Quark
function escapeAsIdentifier(name: string): string
function handleEnsure(self: HandleRepoIface, id: string, context?: object | null): Handle
function handleTypeIsValid(type: HandleType): boolean
function handleTypeToString(type: HandleType): string
function ifaceQuarkAccount(): GLib.Quark
function ifaceQuarkAccountInterfaceAddressing(): GLib.Quark
function ifaceQuarkAccountInterfaceAvatar(): GLib.Quark
function ifaceQuarkAccountInterfaceStorage(): GLib.Quark
function ifaceQuarkAccountManager(): GLib.Quark
function ifaceQuarkAuthenticationTlsCertificate(): GLib.Quark
function ifaceQuarkCallContent(): GLib.Quark
function ifaceQuarkCallContentInterfaceAudioControl(): GLib.Quark
function ifaceQuarkCallContentInterfaceDtmf(): GLib.Quark
function ifaceQuarkCallContentInterfaceMedia(): GLib.Quark
function ifaceQuarkCallContentInterfaceVideoControl(): GLib.Quark
function ifaceQuarkCallContentMediaDescription(): GLib.Quark
function ifaceQuarkCallContentMediaDescriptionInterfaceRtcpExtendedReports(): GLib.Quark
function ifaceQuarkCallContentMediaDescriptionInterfaceRtcpFeedback(): GLib.Quark
function ifaceQuarkCallContentMediaDescriptionInterfaceRtpHeaderExtensions(): GLib.Quark
function ifaceQuarkCallStream(): GLib.Quark
function ifaceQuarkCallStreamEndpoint(): GLib.Quark
function ifaceQuarkCallStreamInterfaceMedia(): GLib.Quark
function ifaceQuarkChannel(): GLib.Quark
function ifaceQuarkChannelDispatchOperation(): GLib.Quark
function ifaceQuarkChannelDispatcher(): GLib.Quark
function ifaceQuarkChannelDispatcherInterfaceMessages1(): GLib.Quark
function ifaceQuarkChannelDispatcherInterfaceOperationList(): GLib.Quark
function ifaceQuarkChannelInterfaceAnonymity(): GLib.Quark
function ifaceQuarkChannelInterfaceCallState(): GLib.Quark
function ifaceQuarkChannelInterfaceCaptchaAuthentication(): GLib.Quark
function ifaceQuarkChannelInterfaceChatState(): GLib.Quark
function ifaceQuarkChannelInterfaceConference(): GLib.Quark
function ifaceQuarkChannelInterfaceDestroyable(): GLib.Quark
function ifaceQuarkChannelInterfaceDtmf(): GLib.Quark
function ifaceQuarkChannelInterfaceFileTransferMetadata(): GLib.Quark
function ifaceQuarkChannelInterfaceGroup(): GLib.Quark
function ifaceQuarkChannelInterfaceHold(): GLib.Quark
function ifaceQuarkChannelInterfaceMediaSignalling(): GLib.Quark
function ifaceQuarkChannelInterfaceMessages(): GLib.Quark
function ifaceQuarkChannelInterfacePassword(): GLib.Quark
function ifaceQuarkChannelInterfaceRoom(): GLib.Quark
function ifaceQuarkChannelInterfaceRoomConfig(): GLib.Quark
function ifaceQuarkChannelInterfaceSaslAuthentication(): GLib.Quark
function ifaceQuarkChannelInterfaceSecurable(): GLib.Quark
function ifaceQuarkChannelInterfaceServicePoint(): GLib.Quark
function ifaceQuarkChannelInterfaceSms(): GLib.Quark
function ifaceQuarkChannelInterfaceSubject(): GLib.Quark
function ifaceQuarkChannelInterfaceTube(): GLib.Quark
function ifaceQuarkChannelRequest(): GLib.Quark
function ifaceQuarkChannelTypeCall(): GLib.Quark
function ifaceQuarkChannelTypeContactList(): GLib.Quark
function ifaceQuarkChannelTypeContactSearch(): GLib.Quark
function ifaceQuarkChannelTypeDbusTube(): GLib.Quark
function ifaceQuarkChannelTypeFileTransfer(): GLib.Quark
function ifaceQuarkChannelTypeRoomList(): GLib.Quark
function ifaceQuarkChannelTypeServerAuthentication(): GLib.Quark
function ifaceQuarkChannelTypeServerTlsConnection(): GLib.Quark
function ifaceQuarkChannelTypeStreamTube(): GLib.Quark
function ifaceQuarkChannelTypeStreamedMedia(): GLib.Quark
function ifaceQuarkChannelTypeText(): GLib.Quark
function ifaceQuarkChannelTypeTubes(): GLib.Quark
function ifaceQuarkClient(): GLib.Quark
function ifaceQuarkClientApprover(): GLib.Quark
function ifaceQuarkClientHandler(): GLib.Quark
function ifaceQuarkClientInterfaceRequests(): GLib.Quark
function ifaceQuarkClientObserver(): GLib.Quark
function ifaceQuarkConnection(): GLib.Quark
function ifaceQuarkConnectionInterfaceAddressing(): GLib.Quark
function ifaceQuarkConnectionInterfaceAliasing(): GLib.Quark
function ifaceQuarkConnectionInterfaceAnonymity(): GLib.Quark
function ifaceQuarkConnectionInterfaceAvatars(): GLib.Quark
function ifaceQuarkConnectionInterfaceBalance(): GLib.Quark
function ifaceQuarkConnectionInterfaceCapabilities(): GLib.Quark
function ifaceQuarkConnectionInterfaceCellular(): GLib.Quark
function ifaceQuarkConnectionInterfaceClientTypes(): GLib.Quark
function ifaceQuarkConnectionInterfaceContactBlocking(): GLib.Quark
function ifaceQuarkConnectionInterfaceContactCapabilities(): GLib.Quark
function ifaceQuarkConnectionInterfaceContactGroups(): GLib.Quark
function ifaceQuarkConnectionInterfaceContactInfo(): GLib.Quark
function ifaceQuarkConnectionInterfaceContactList(): GLib.Quark
function ifaceQuarkConnectionInterfaceContacts(): GLib.Quark
function ifaceQuarkConnectionInterfaceLocation(): GLib.Quark
function ifaceQuarkConnectionInterfaceMailNotification(): GLib.Quark
function ifaceQuarkConnectionInterfacePowerSaving(): GLib.Quark
function ifaceQuarkConnectionInterfacePresence(): GLib.Quark
function ifaceQuarkConnectionInterfaceRenaming(): GLib.Quark
function ifaceQuarkConnectionInterfaceRequests(): GLib.Quark
function ifaceQuarkConnectionInterfaceServicePoint(): GLib.Quark
function ifaceQuarkConnectionInterfaceSidecars1(): GLib.Quark
function ifaceQuarkConnectionInterfaceSimplePresence(): GLib.Quark
function ifaceQuarkConnectionManager(): GLib.Quark
function ifaceQuarkDbusDaemon(): GLib.Quark
function ifaceQuarkDbusIntrospectable(): GLib.Quark
function ifaceQuarkDbusPeer(): GLib.Quark
function ifaceQuarkDbusProperties(): GLib.Quark
function ifaceQuarkDebug(): GLib.Quark
function ifaceQuarkMediaSessionHandler(): GLib.Quark
function ifaceQuarkMediaStreamHandler(): GLib.Quark
function ifaceQuarkPropertiesInterface(): GLib.Quark
function ifaceQuarkProtocol(): GLib.Quark
function ifaceQuarkProtocolInterfaceAddressing(): GLib.Quark
function ifaceQuarkProtocolInterfaceAvatars(): GLib.Quark
function ifaceQuarkProtocolInterfacePresence(): GLib.Quark
function intsetFromArray(array: number[]): Intset
function listConnectionManagers(busDaemon: DBusDaemon, callback: ConnectionManagerListCb, weakObject?: GObject.Object | null): void
function listConnectionManagersAsync(dbusDaemon?: DBusDaemon | null, callback?: Gio.AsyncReadyCallback | null): void
function listConnectionManagersFinish(result: Gio.AsyncResult): ConnectionManager[]
function listConnectionNames(busDaemon: DBusDaemon, callback: ConnectionNameListCb, weakObject?: GObject.Object | null): void
function simpleAsyncReportSuccessInIdle(source?: GObject.Object | null, callback?: Gio.AsyncReadyCallback | null, sourceTag?: object | null): void
function svcInterfaceSetDbusPropertiesInfo(gInterface: GObject.Type, info: DBusPropertiesMixinIfaceInfo): void
function userActionTimeFromX11(x11Time: number): number
function userActionTimeShouldPresent(userActionTime: number): [ /* returnType */ boolean, /* x11Time */ number | null ]
function utf8MakeValid(name: string): string
function valueArrayFree(va: GObject.ValueArray): void
interface AccountChannelRequestDelegatedChannelCb {
    (request: AccountChannelRequest, channel: Channel): void
}
interface BaseClientClassAddDispatchOperationImpl {
    (client: BaseClient, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation, context: AddDispatchOperationContext): void
}
interface BaseClientClassHandleChannelsImpl {
    (client: BaseClient, account: Account, connection: Connection, channels: Channel[], requestsSatisfied: ChannelRequest[], userActionTime: number, context: HandleChannelsContext): void
}
interface BaseClientClassObserveChannelsImpl {
    (client: BaseClient, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation | null, requests: ChannelRequest[], context: ObserveChannelsContext): void
}
interface BaseClientDelegatedChannelsCb {
    (client: BaseClient, channels: Channel[]): void
}
interface BaseConnectionGetUniqueConnectionNameImpl {
    (self: BaseConnection): string
}
interface BaseConnectionProc {
    (self: BaseConnection): void
}
interface BaseConnectionStartConnectingImpl {
    (self: BaseConnection): boolean
}
interface ChannelWhenReadyCb {
    (channel: Channel, error: GLib.Error): void
}
interface ConnectionContactsByHandleCb {
    (connection: Connection, contacts: Contact[], failed: Handle[], error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionContactsByIdCb {
    (connection: Connection, contacts: Contact[], requestedIds: string[], failedIdErrors: GLib.HashTable, error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionHoldHandlesCb {
    (connection: Connection, handleType: HandleType, nHandles: number, handles: Handle, error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionManagerListCb {
    (cms: ConnectionManager[], nCms: number, error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionManagerWhenReadyCb {
    (cm: ConnectionManager, error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionNameListCb {
    (names: string[], n: number, cms: string[], protocols: string[], error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionRequestHandlesCb {
    (connection: Connection, handleType: HandleType, handles: number[], ids: string[], error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionUpgradeContactsCb {
    (connection: Connection, contacts: Contact[], error: GLib.Error, weakObject: GObject.Object): void
}
interface ConnectionWhenReadyCb {
    (connection: Connection, error: GLib.Error): void
}
interface DBusDaemonListNamesCb {
    (busDaemon: DBusDaemon, names: string, error: GLib.Error, weakObject: GObject.Object): void
}
interface DBusDaemonNameOwnerChangedCb {
    (busDaemon: DBusDaemon, name: string, newOwner: string): void
}
interface DBusPropertiesMixinGetter {
    (object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, getterData?: object | null): void
}
interface DBusPropertiesMixinSetter {
    (object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, setterData?: object | null): boolean
}
interface GroupMixinAddMemberFunc {
    (obj: GObject.Object, handle: Handle, message: string): boolean
}
interface GroupMixinRemMemberFunc {
    (obj: GObject.Object, handle: Handle, message: string): boolean
}
interface GroupMixinRemMemberWithReasonFunc {
    (obj: GObject.Object, handle: Handle, message: string, reason: number): boolean
}
interface IntFunc {
    (i: number, userdata?: object | null): void
}
interface PresenceMixinGetMaximumStatusMessageLengthFunc {
    (obj: GObject.Object): number
}
interface PresenceMixinSetOwnStatusFunc {
    (obj: GObject.Object, status: PresenceStatus): boolean
}
interface PresenceMixinStatusAvailableFunc {
    (obj: GObject.Object, which: number): boolean
}
interface ProxyPrepareAsync {
    (proxy: Proxy, feature: ProxyFeature, callback?: Gio.AsyncReadyCallback | null): void
}
interface SimpleApproverAddDispatchOperationImpl {
    (approver: SimpleApprover, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation | null, context: AddDispatchOperationContext): void
}
interface SimpleHandlerHandleChannelsImpl {
    (handler: SimpleHandler, account: Account, connection: Connection, channels: Channel[], requestsSatisfied: ChannelRequest[], userActionTime: number, context: HandleChannelsContext): void
}
interface SimpleObserverObserveChannelsImpl {
    (observer: SimpleObserver, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation | null, requests: ChannelRequest[], context: ObserveChannelsContext): void
}
class ClientChannelFactory {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactory */
    createChannel(conn: Connection, path: string, properties: GLib.HashTable): Channel
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    static name: string
}
class HandleRepoIface {
    static name: string
}
interface Account_ConstructProps extends Proxy_ConstructProps {
}
class Account {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Account */
    readonly automaticPresenceType: number
    readonly automaticStatus: string
    readonly automaticStatusMessage: string
    readonly changingPresence: boolean
    readonly cmName: string
    readonly connectAutomatically: boolean
    readonly connection: Connection
    readonly connectionError: string
    readonly connectionErrorDetails: GLib.HashTable
    readonly connectionManager: string
    readonly connectionStatus: number
    readonly connectionStatusReason: number
    readonly currentPresenceType: number
    readonly currentStatus: string
    readonly currentStatusMessage: string
    readonly displayName: string
    readonly enabled: boolean
    readonly hasBeenOnline: boolean
    readonly iconName: string
    readonly nickname: string
    readonly normalizedName: string
    readonly protocol: string
    readonly protocolName: string
    readonly requestedPresenceType: number
    readonly requestedStatus: string
    readonly requestedStatusMessage: string
    readonly service: string
    readonly storageIdentifier: any
    readonly storageIdentifierVariant: GLib.Variant
    readonly storageProvider: string
    readonly storageRestrictions: number
    readonly supersedes: string[]
    readonly uriSchemes: string[]
    readonly valid: boolean
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Account */
    associatedWithUriScheme(scheme: string): boolean
    bindConnectionStatusToProperty(target: object | null, targetProperty: string, invert: boolean): GObject.Binding
    dupDetailedErrorVardict(): [ /* returnType */ string | null, /* details */ GLib.Variant | null ]
    dupParametersVardict(): GLib.Variant
    dupStorageIdentifierVariant(): GLib.Variant
    dupStorageSpecificInformationVardictAsync(callback?: Gio.AsyncReadyCallback | null): void
    dupStorageSpecificInformationVardictFinish(result: Gio.AsyncResult): GLib.Variant
    ensureConnection(path: string): Connection
    getAutomaticPresence(): [ /* returnType */ ConnectionPresenceType, /* status */ string, /* statusMessage */ string ]
    getAvatarAsync(callback?: Gio.AsyncReadyCallback | null): void
    getAvatarFinish(result: Gio.AsyncResult): Uint8Array
    getChangingPresence(): boolean
    getCmName(): string
    getConnectAutomatically(): boolean
    getConnection(): Connection
    getConnectionManager(): string
    getConnectionStatus(): [ /* returnType */ ConnectionStatus, /* reason */ ConnectionStatusReason ]
    getCurrentPresence(): [ /* returnType */ ConnectionPresenceType, /* status */ string, /* statusMessage */ string ]
    getDisplayName(): string
    getHasBeenOnline(): boolean
    getIconName(): string
    getNickname(): string
    getNormalizedName(): string
    getParameters(): GLib.HashTable
    getPathSuffix(): string
    getProtocol(): string
    getProtocolName(): string
    getRequestedPresence(): [ /* returnType */ ConnectionPresenceType, /* status */ string, /* statusMessage */ string ]
    getService(): string
    getStorageIdentifier(): any
    getStorageProvider(): string
    getStorageRestrictions(): StorageRestrictionFlags
    getStorageSpecificInformationAsync(callback?: Gio.AsyncReadyCallback | null): void
    getStorageSpecificInformationFinish(result: Gio.AsyncResult): GLib.HashTable
    getSupersedes(): string[]
    getUriSchemes(): string[]
    isEnabled(): boolean
    isValid(): boolean
    reconnectAsync(callback?: Gio.AsyncReadyCallback | null): void
    reconnectFinish(result: Gio.AsyncResult): boolean
    removeAsync(callback?: Gio.AsyncReadyCallback | null): void
    removeFinish(result: Gio.AsyncResult): boolean
    requestPresenceAsync(type: ConnectionPresenceType, status: string, message: string, callback?: Gio.AsyncReadyCallback | null): void
    requestPresenceFinish(result: Gio.AsyncResult): boolean
    setAutomaticPresenceAsync(type: ConnectionPresenceType, status: string, message: string, callback?: Gio.AsyncReadyCallback | null): void
    setAutomaticPresenceFinish(result: Gio.AsyncResult): boolean
    setAvatarAsync(avatar: Uint8Array | null, mimeType?: string | null, callback?: Gio.AsyncReadyCallback | null): void
    setAvatarFinish(result: Gio.AsyncResult): boolean
    setConnectAutomaticallyAsync(connectAutomatically: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setConnectAutomaticallyFinish(result: Gio.AsyncResult): boolean
    setDisplayNameAsync(displayName: string, callback?: Gio.AsyncReadyCallback | null): void
    setDisplayNameFinish(result: Gio.AsyncResult): boolean
    setEnabledAsync(enabled: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setEnabledFinish(result: Gio.AsyncResult): boolean
    setIconNameAsync(iconName: string, callback?: Gio.AsyncReadyCallback | null): void
    setIconNameFinish(result: Gio.AsyncResult): boolean
    setNicknameAsync(nickname: string, callback?: Gio.AsyncReadyCallback | null): void
    setNicknameFinish(result: Gio.AsyncResult): boolean
    setServiceAsync(service: string, callback?: Gio.AsyncReadyCallback | null): void
    setServiceFinish(result: Gio.AsyncResult): boolean
    setUriSchemeAssociationAsync(scheme: string, associate: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setUriSchemeAssociationFinish(result: Gio.AsyncResult): boolean
    updateParametersAsync(parameters: GLib.HashTable, unsetParameters: string, callback?: Gio.AsyncReadyCallback | null): void
    updateParametersFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* reconnectRequired */ string[] ]
    updateParametersVardictAsync(parameters: GLib.Variant, unsetParameters: string[], callback?: Gio.AsyncReadyCallback | null): void
    updateParametersVardictFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* reconnectRequired */ string[] ]
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Account */
    connect(sigName: "avatar-changed", callback: (() => void)): number
    on(sigName: "avatar-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "avatar-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "avatar-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "avatar-changed"): void
    connect(sigName: "presence-changed", callback: ((presence: number, status: string, statusMessage: string) => void)): number
    on(sigName: "presence-changed", callback: (presence: number, status: string, statusMessage: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "presence-changed", callback: (presence: number, status: string, statusMessage: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "presence-changed", callback: (presence: number, status: string, statusMessage: string) => void): NodeJS.EventEmitter
    emit(sigName: "presence-changed", presence: number, status: string, statusMessage: string): void
    connect(sigName: "status-changed", callback: ((oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void)): number
    on(sigName: "status-changed", callback: (oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "status-changed", callback: (oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "status-changed", callback: (oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "status-changed", oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::automatic-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::changing-presence", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::changing-presence", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::changing-presence", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::changing-presence", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::changing-presence", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cm-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cm-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connect-automatically", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connect-automatically", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-error", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-error", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-error-details", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-error-details", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-error-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-error-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-error-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-status-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-status-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::current-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::current-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::current-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::current-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::current-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::current-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::current-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::current-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::current-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::current-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::current-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::current-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::display-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::display-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::display-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::display-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::display-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-been-online", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-been-online", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-been-online", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-been-online", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-been-online", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::nickname", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nickname", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::normalized-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::normalized-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::normalized-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::normalized-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::normalized-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-identifier-variant", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-identifier-variant", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-identifier-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-identifier-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-identifier-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-restrictions", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-restrictions", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-restrictions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-restrictions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-restrictions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::supersedes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supersedes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::uri-schemes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uri-schemes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::valid", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::valid", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::valid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::valid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::valid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Account_ConstructProps)
    _init (config?: Account_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon, objectPath: string): Account
    static getFeatureQuarkAddressing(): GLib.Quark
    static getFeatureQuarkConnection(): GLib.Quark
    static getFeatureQuarkCore(): GLib.Quark
    static getFeatureQuarkStorage(): GLib.Quark
    static initKnownInterfaces(): void
    static parseObjectPath(objectPath: string): [ /* returnType */ boolean, /* cm */ string, /* protocol */ string, /* accountId */ string ]
    static $gtype: GObject.Type
}
interface AccountChannelRequest_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.AccountChannelRequest */
    account?: Account
    requestVardict?: GLib.Variant
    userActionTime?: number
}
class AccountChannelRequest {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.AccountChannelRequest */
    readonly channelRequest: ChannelRequest
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AccountChannelRequest */
    createAndHandleChannelAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    createAndHandleChannelFinish(result: Gio.AsyncResult): [ /* returnType */ Channel | null, /* context */ HandleChannelsContext | null ]
    createAndObserveChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    createAndObserveChannelFinish(result: Gio.AsyncResult): Channel
    createChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    createChannelFinish(result: Gio.AsyncResult): boolean
    dupRequest(): GLib.Variant
    ensureAndHandleChannelAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    ensureAndHandleChannelFinish(result: Gio.AsyncResult): [ /* returnType */ Channel | null, /* context */ HandleChannelsContext | null ]
    ensureAndObserveChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    ensureAndObserveChannelFinish(result: Gio.AsyncResult): Channel
    ensureChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    ensureChannelFinish(result: Gio.AsyncResult): boolean
    getAccount(): Account
    getChannelRequest(): ChannelRequest
    getRequest(): GLib.HashTable
    getUserActionTime(): number
    setChannelFactory(factory: ClientChannelFactory): void
    setConferenceInitialChannels(channels: string): void
    setDelegateToPreferredHandler(delegate: boolean): void
    setDelegatedChannelCallback(callback: AccountChannelRequestDelegatedChannelCb): void
    setFileTransferDescription(description: string): void
    setFileTransferHash(hashType: FileHashType, hash: string): void
    setFileTransferInitialOffset(offset: number): void
    setFileTransferTimestamp(timestamp: number): void
    setFileTransferUri(uri: string): void
    setHint(key: string, value: GLib.Variant): void
    setHints(hints: GLib.HashTable): void
    setInitialInviteeIds(ids: string): void
    setInitialInvitees(contacts: Contact[]): void
    setRequestProperty(name: string, value: GLib.Variant): void
    setSmsChannel(isSmsChannel: boolean): void
    setTargetContact(contact: Contact): void
    setTargetId(handleType: HandleType, identifier: string): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.AccountChannelRequest */
    connect(sigName: "re-handled", callback: ((channel: Channel, userActionTime: number, context: HandleChannelsContext) => void)): number
    on(sigName: "re-handled", callback: (channel: Channel, userActionTime: number, context: HandleChannelsContext) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "re-handled", callback: (channel: Channel, userActionTime: number, context: HandleChannelsContext) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "re-handled", callback: (channel: Channel, userActionTime: number, context: HandleChannelsContext) => void): NodeJS.EventEmitter
    emit(sigName: "re-handled", channel: Channel, userActionTime: number, context: HandleChannelsContext): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel-request", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-request", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AccountChannelRequest_ConstructProps)
    _init (config?: AccountChannelRequest_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(account: Account, request: GLib.HashTable, userActionTime: number): AccountChannelRequest
    static newAudioCall(account: Account, userActionTime: number): AccountChannelRequest
    static newAudioVideoCall(account: Account, userActionTime: number): AccountChannelRequest
    static newDbusTube(account: Account, serviceName: string, userActionTime: number): AccountChannelRequest
    static newFileTransfer(account: Account, filename: string, mimeType: string | null, size: number, userActionTime: number): AccountChannelRequest
    static newStreamTube(account: Account, service: string, userActionTime: number): AccountChannelRequest
    static newText(account: Account, userActionTime: number): AccountChannelRequest
    static newVardict(account: Account, request: GLib.Variant, userActionTime: number): AccountChannelRequest
    static $gtype: GObject.Type
}
interface AccountManager_ConstructProps extends Proxy_ConstructProps {
}
class AccountManager {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AccountManager */
    createAccountAsync(connectionManager: string, protocol: string, displayName: string, parameters: GLib.HashTable, properties: GLib.HashTable, callback?: Gio.AsyncReadyCallback | null): void
    createAccountFinish(result: Gio.AsyncResult): Account
    dupValidAccounts(): Account[]
    enableRestart(): void
    ensureAccount(path: string): Account
    getMostAvailablePresence(): [ /* returnType */ ConnectionPresenceType, /* status */ string, /* message */ string ]
    getValidAccounts(): Account[]
    setAllRequestedPresences(type: ConnectionPresenceType, status: string, message: string): void
    setDefault(): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.AccountManager */
    connect(sigName: "account-disabled", callback: ((account: Account) => void)): number
    on(sigName: "account-disabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-disabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-disabled", callback: (account: Account) => void): NodeJS.EventEmitter
    emit(sigName: "account-disabled", account: Account): void
    connect(sigName: "account-enabled", callback: ((account: Account) => void)): number
    on(sigName: "account-enabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-enabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-enabled", callback: (account: Account) => void): NodeJS.EventEmitter
    emit(sigName: "account-enabled", account: Account): void
    connect(sigName: "account-removed", callback: ((account: Account) => void)): number
    on(sigName: "account-removed", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-removed", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-removed", callback: (account: Account) => void): NodeJS.EventEmitter
    emit(sigName: "account-removed", account: Account): void
    connect(sigName: "account-validity-changed", callback: ((account: Account, valid: boolean) => void)): number
    on(sigName: "account-validity-changed", callback: (account: Account, valid: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-validity-changed", callback: (account: Account, valid: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-validity-changed", callback: (account: Account, valid: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "account-validity-changed", account: Account, valid: boolean): void
    connect(sigName: "most-available-presence-changed", callback: ((presence: number, status: string, message: string) => void)): number
    on(sigName: "most-available-presence-changed", callback: (presence: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "most-available-presence-changed", callback: (presence: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "most-available-presence-changed", callback: (presence: number, status: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "most-available-presence-changed", presence: number, status: string, message: string): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AccountManager_ConstructProps)
    _init (config?: AccountManager_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon): AccountManager
    static newWithFactory(factory: SimpleClientFactory): AccountManager
    static canSetDefault(): boolean
    static dup(): AccountManager
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface AccountRequest_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.AccountRequest */
    accountManager?: AccountManager
    connectionManager?: string
    displayName?: string
    protocol?: string
}
class AccountRequest {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.AccountRequest */
    readonly automaticPresenceType: number
    readonly automaticStatus: string
    readonly automaticStatusMessage: string
    readonly avatar: object[]
    readonly avatarMimeType: string
    readonly connectAutomatically: boolean
    readonly enabled: boolean
    readonly iconName: string
    readonly nickname: string
    readonly parameters: GLib.Variant
    readonly properties: GLib.Variant
    readonly requestedPresenceType: number
    readonly requestedStatus: string
    readonly requestedStatusMessage: string
    readonly service: string
    readonly storageProvider: string
    readonly supersedes: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AccountRequest */
    addSupersedes(supersededPath: string): void
    createAccountAsync(callback?: Gio.AsyncReadyCallback | null): void
    createAccountFinish(result: Gio.AsyncResult): Account
    setAutomaticPresence(presence: ConnectionPresenceType, status: string, message: string): void
    setAvatar(avatar: Uint8Array | null, mimeType?: string | null): void
    setConnectAutomatically(connectAutomatically: boolean): void
    setDisplayName(name: string): void
    setEnabled(enabled: boolean): void
    setIconName(icon: string): void
    setNickname(nickname: string): void
    setParameter(key: string, value: GLib.Variant): void
    setRequestedPresence(presence: ConnectionPresenceType, status: string, message: string): void
    setService(service: string): void
    setStorageProvider(provider: string): void
    unsetParameter(key: string): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::automatic-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-mime-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-mime-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connect-automatically", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connect-automatically", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::nickname", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nickname", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::parameters", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameters", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parameters", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parameters", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parameters", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::properties", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::properties", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-provider", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::supersedes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supersedes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AccountRequest_ConstructProps)
    _init (config?: AccountRequest_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(accountManager: AccountManager, manager: string, protocol: string, displayName: string): AccountRequest
    static newFromProtocol(accountManager: AccountManager, protocol: Protocol, displayName: string): AccountRequest
    static $gtype: GObject.Type
}
interface AddDispatchOperationContext_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.AddDispatchOperationContext */
    account?: Account
    channels?: object[]
    connection?: Connection
    dispatchOperation?: ChannelDispatchOperation
}
class AddDispatchOperationContext {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AddDispatchOperationContext */
    accept(): void
    delay(): void
    fail(error: GLib.Error): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AddDispatchOperationContext_ConstructProps)
    _init (config?: AddDispatchOperationContext_ConstructProps): void
    static $gtype: GObject.Type
}
interface AutomaticClientFactory_ConstructProps extends SimpleClientFactory_ConstructProps {
}
class AutomaticClientFactory {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.SimpleClientFactory */
    addAccountFeatures(features?: GLib.Quark[] | null): void
    addChannelFeatures(features?: GLib.Quark[] | null): void
    addConnectionFeatures(features?: GLib.Quark[] | null): void
    addContactFeatures(features?: ContactFeature[] | null): void
    dupAccountFeatures(account: Account): GLib.Quark[]
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    dupConnectionFeatures(connection: Connection): GLib.Quark[]
    dupContactFeatures(connection: Connection): ContactFeature[]
    ensureAccount(objectPath: string, immutableProperties: GLib.HashTable): Account
    ensureChannel(connection: Connection, objectPath: string, immutableProperties: GLib.HashTable): Channel
    ensureConnection(objectPath: string, immutableProperties: GLib.HashTable): Connection
    ensureContact(connection: Connection, handle: Handle, identifier: string): Contact
    ensureContactByIdAsync(connection: Connection, identifier: string, callback?: Gio.AsyncReadyCallback | null): void
    ensureContactByIdFinish(result: Gio.AsyncResult): Contact
    getDbusDaemon(): DBusDaemon
    upgradeContactsAsync(connection: Connection, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    upgradeContactsFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* contacts */ Contact[] | null ]
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AutomaticClientFactory_ConstructProps)
    _init (config?: AutomaticClientFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus?: DBusDaemon | null): AutomaticClientFactory
    /* Function overloads */
    static new(dbus?: DBusDaemon | null): AutomaticClientFactory
    static $gtype: GObject.Type
}
interface AutomaticProxyFactory_ConstructProps extends GObject.Object_ConstructProps {
}
class AutomaticProxyFactory {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactory */
    createChannel(conn: Connection, path: string, properties: GLib.HashTable): Channel
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AutomaticProxyFactory_ConstructProps)
    _init (config?: AutomaticProxyFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): AutomaticProxyFactory
    static dup(): AutomaticProxyFactory
    static $gtype: GObject.Type
}
interface BaseClient_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    accountManager?: AccountManager
    channelFactory?: GObject.Object
    dbusDaemon?: DBusDaemon
    factory?: SimpleClientFactory
    name?: string
    uniquifyName?: boolean
}
class BaseClient {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* delegated */ Channel[], /* notDelegated */ GLib.HashTable ]
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: ((account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: ((request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BaseClient_ConstructProps)
    _init (config?: BaseClient_ConstructProps): void
    static $gtype: GObject.Type
}
interface BaseConnection_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.BaseConnection */
    accountPathSuffix?: string
}
class BaseConnection {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.BaseConnection */
    readonly hasImmortalHandles: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseConnection */
    addClientInterest(uniqueName: string, token: string, onlyIfUninterested: boolean): void
    addPossibleClientInterest(token: GLib.Quark): void
    changeStatus(status: ConnectionStatus, reason: ConnectionStatusReason): void
    checkConnected(): boolean
    getAccountPathSuffix(): string
    getBusName(): string | null
    getHandles(handleType: HandleType): HandleRepoIface
    getObjectPath(): string | null
    getStatus(): ConnectionStatus
    isDestroyed(): boolean
    register(cmName: string): [ /* returnType */ boolean, /* busName */ string, /* objectPath */ string ]
    setSelfHandle(selfHandle: Handle): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseConnection */
    connect(sigName: "clients-interested", callback: ((token: string) => void)): number
    on(sigName: "clients-interested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "clients-interested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "clients-interested", callback: (token: string) => void): NodeJS.EventEmitter
    emit(sigName: "clients-interested", token: string): void
    connect(sigName: "clients-uninterested", callback: ((token: string) => void)): number
    on(sigName: "clients-uninterested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "clients-uninterested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "clients-uninterested", callback: (token: string) => void): NodeJS.EventEmitter
    emit(sigName: "clients-uninterested", token: string): void
    connect(sigName: "shutdown-finished", callback: (() => void)): number
    on(sigName: "shutdown-finished", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "shutdown-finished", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "shutdown-finished", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "shutdown-finished"): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::has-immortal-handles", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-immortal-handles", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-immortal-handles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-immortal-handles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-immortal-handles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BaseConnection_ConstructProps)
    _init (config?: BaseConnection_ConstructProps): void
    static $gtype: GObject.Type
}
interface BasicProxyFactory_ConstructProps extends GObject.Object_ConstructProps {
}
class BasicProxyFactory {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactory */
    createChannel(conn: Connection, path: string, properties: GLib.HashTable): Channel
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BasicProxyFactory_ConstructProps)
    _init (config?: BasicProxyFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): BasicProxyFactory
    static dup(): BasicProxyFactory
    static $gtype: GObject.Type
}
interface CallChannel_ConstructProps extends Channel_ConstructProps {
}
class CallChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.CallChannel */
    readonly contents: object[]
    readonly flags: number
    readonly hardwareStreaming: boolean
    readonly holdState: number
    readonly holdStateReason: number
    readonly initialAudio: boolean
    readonly initialAudioName: string
    readonly initialVideo: boolean
    readonly initialVideoName: string
    readonly mutableContents: boolean
    readonly state: number
    readonly stateDetails: GLib.HashTable
    readonly stateReason: CallStateReason
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.CallChannel */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): boolean
    addContentAsync(name: string, type: MediaStreamType, initialDirection: MediaStreamDirection, callback?: Gio.AsyncReadyCallback | null): void
    addContentFinish(result: Gio.AsyncResult): CallContent
    getContents(): CallContent[]
    getMembers(): GLib.HashTable
    getState(): [ /* returnType */ CallState, /* flags */ CallFlags | null, /* details */ GLib.HashTable | null, /* reason */ CallStateReason | null ]
    hangupAsync(reason: CallStateChangeReason, detailedReason: string, message: string, callback?: Gio.AsyncReadyCallback | null): void
    hangupFinish(result: Gio.AsyncResult): boolean
    hasDtmf(): boolean
    hasHardwareStreaming(): boolean
    hasHold(): boolean
    hasInitialAudio(): [ /* returnType */ boolean, /* initialAudioName */ string | null ]
    hasInitialVideo(): [ /* returnType */ boolean, /* initialVideoName */ string | null ]
    hasMutableContents(): boolean
    requestHoldAsync(hold: boolean, callback?: Gio.AsyncReadyCallback | null): void
    requestHoldFinish(result: Gio.AsyncResult): boolean
    sendTonesAsync(tones: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    sendTonesFinish(result: Gio.AsyncResult): boolean
    setQueuedAsync(callback?: Gio.AsyncReadyCallback | null): void
    setQueuedFinish(result: Gio.AsyncResult): boolean
    setRingingAsync(callback?: Gio.AsyncReadyCallback | null): void
    setRingingFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): [ /* returnType */ Handle, /* handleType */ HandleType ]
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): [ /* returnType */ boolean, /* actor */ Contact | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetLocalPendingInfo(localPending: Handle): [ /* returnType */ boolean, /* actor */ Handle | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.CallChannel */
    connect(sigName: "content-added", callback: ((content: GObject.Object) => void)): number
    on(sigName: "content-added", callback: (content: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "content-added", callback: (content: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "content-added", callback: (content: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "content-added", content: GObject.Object): void
    connect(sigName: "content-removed", callback: ((content: GObject.Object, reason: CallStateReason) => void)): number
    on(sigName: "content-removed", callback: (content: GObject.Object, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "content-removed", callback: (content: GObject.Object, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "content-removed", callback: (content: GObject.Object, reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "content-removed", content: GObject.Object, reason: CallStateReason): void
    connect(sigName: "members-changed", callback: ((updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void)): number
    on(sigName: "members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "members-changed", updates: GLib.HashTable, removed: Contact[], reason: CallStateReason): void
    connect(sigName: "state-changed", callback: ((state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void)): number
    on(sigName: "state-changed", callback: (state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "state-changed", callback: (state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "state-changed", callback: (state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "state-changed", state: number, flags: number, reason: CallStateReason, details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: ((contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: ((added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: ((added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: ((message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: ((added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::contents", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contents", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hardware-streaming", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hardware-streaming", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hardware-streaming", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hardware-streaming", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hardware-streaming", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hold-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hold-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hold-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hold-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hold-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hold-state-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hold-state-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hold-state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hold-state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hold-state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-audio", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-audio", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-audio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-audio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-audio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-audio-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-audio-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-audio-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-audio-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-audio-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-video", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-video", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-video", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-video", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-video", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-video-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-video-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-video-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-video-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-video-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mutable-contents", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mutable-contents", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mutable-contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mutable-contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mutable-contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state-details", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-details", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CallChannel_ConstructProps)
    _init (config?: CallChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getFeatureQuarkCore(): GLib.Quark
    static $gtype: GObject.Type
}
interface CallContent_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.CallContent */
    channel?: CallChannel
    connection?: Connection
}
class CallContent {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.CallContent */
    readonly disposition: number
    readonly mediaType: number
    readonly name: string
    readonly streams: object[]
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.CallContent */
    getDisposition(): CallContentDisposition
    getMediaType(): MediaStreamType
    getName(): string
    getStreams(): CallStream[]
    removeAsync(callback?: Gio.AsyncReadyCallback | null): void
    removeFinish(result: Gio.AsyncResult): boolean
    sendTonesAsync(tones: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    sendTonesFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.CallContent */
    connect(sigName: "removed", callback: (() => void)): number
    on(sigName: "removed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "removed"): void
    connect(sigName: "streams-added", callback: ((streams: CallStream[]) => void)): number
    on(sigName: "streams-added", callback: (streams: CallStream[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "streams-added", callback: (streams: CallStream[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "streams-added", callback: (streams: CallStream[]) => void): NodeJS.EventEmitter
    emit(sigName: "streams-added", streams: CallStream[]): void
    connect(sigName: "streams-removed", callback: ((streams: CallStream[], reason: CallStateReason) => void)): number
    on(sigName: "streams-removed", callback: (streams: CallStream[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "streams-removed", callback: (streams: CallStream[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "streams-removed", callback: (streams: CallStream[], reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "streams-removed", streams: CallStream[], reason: CallStateReason): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::disposition", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::disposition", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::disposition", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::disposition", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::disposition", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::media-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::media-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::media-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::media-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::media-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::streams", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::streams", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::streams", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::streams", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::streams", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CallContent_ConstructProps)
    _init (config?: CallContent_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface CallStream_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.CallStream */
    connection?: Connection
    content?: CallContent
}
class CallStream {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.CallStream */
    readonly canRequestReceiving: boolean
    readonly localSendingState: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.CallStream */
    getLocalSendingState(): SendingState
    getRemoteMembers(): GLib.HashTable
    requestReceivingAsync(contact: Contact, receive: boolean, callback?: Gio.AsyncReadyCallback | null): void
    requestReceivingFinish(result: Gio.AsyncResult): boolean
    setSendingAsync(send: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setSendingFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.CallStream */
    connect(sigName: "local-sending-state-changed", callback: ((state: number, reason: CallStateReason) => void)): number
    on(sigName: "local-sending-state-changed", callback: (state: number, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "local-sending-state-changed", callback: (state: number, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "local-sending-state-changed", callback: (state: number, reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "local-sending-state-changed", state: number, reason: CallStateReason): void
    connect(sigName: "remote-members-changed", callback: ((updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void)): number
    on(sigName: "remote-members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "remote-members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "remote-members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "remote-members-changed", updates: GLib.HashTable, removed: Contact[], reason: CallStateReason): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::can-request-receiving", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-request-receiving", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::can-request-receiving", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::can-request-receiving", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::can-request-receiving", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::local-sending-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local-sending-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::local-sending-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::local-sending-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::local-sending-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CallStream_ConstructProps)
    _init (config?: CallStream_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface Capabilities_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.Capabilities */
    contactSpecific?: boolean
}
class Capabilities {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Capabilities */
    readonly channelClassesVariant: GLib.Variant
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Capabilities */
    dupChannelClassesVariant(): GLib.Variant
    getChannelClasses(): GLib.HashTable[]
    isSpecificToContact(): boolean
    supportsAudioCall(handleType: HandleType): boolean
    supportsAudioVideoCall(handleType: HandleType): boolean
    supportsContactSearch(): [ /* returnType */ boolean, /* withLimit */ boolean, /* withServer */ boolean ]
    supportsDbusTubes(handleType: HandleType, serviceName: string): boolean
    supportsFileTransfer(): boolean
    supportsFileTransferDescription(): boolean
    supportsFileTransferInitialOffset(): boolean
    supportsFileTransferTimestamp(): boolean
    supportsFileTransferUri(): boolean
    supportsRoomList(): [ /* returnType */ boolean, /* withServer */ boolean ]
    supportsSms(): boolean
    supportsStreamTubes(handleType: HandleType, service: string): boolean
    supportsTextChatrooms(): boolean
    supportsTextChats(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel-classes-variant", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-classes-variant", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-classes-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-classes-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-classes-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Capabilities_ConstructProps)
    _init (config?: Capabilities_ConstructProps): void
    static $gtype: GObject.Type
}
interface Channel_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connection?: Connection
}
class Channel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): [ /* returnType */ Handle, /* handleType */ HandleType ]
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): [ /* returnType */ boolean, /* actor */ Contact | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetLocalPendingInfo(localPending: Handle): [ /* returnType */ boolean, /* actor */ Handle | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: ((contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: ((added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: ((added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: ((message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: ((added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Channel_ConstructProps)
    _init (config?: Channel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): Channel
    static newFromProperties(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): Channel
    static getFeatureQuarkChatStates(): GLib.Quark
    static getFeatureQuarkContacts(): GLib.Quark
    static getFeatureQuarkCore(): GLib.Quark
    static getFeatureQuarkGroup(): GLib.Quark
    static getFeatureQuarkPassword(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface ChannelDispatchOperation_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatchOperation */
    account?: Account
    channels?: object[]
    connection?: Connection
}
class ChannelDispatchOperation {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatchOperation */
    readonly possibleHandlers: string[]
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatchOperation */
    claimAsync(callback?: Gio.AsyncReadyCallback | null): void
    claimFinish(result: Gio.AsyncResult): boolean
    claimWithAsync(client: BaseClient, callback?: Gio.AsyncReadyCallback | null): void
    claimWithFinish(result: Gio.AsyncResult): boolean
    closeChannelsAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeChannelsFinish(result: Gio.AsyncResult): boolean
    destroyChannelsAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyChannelsFinish(result: Gio.AsyncResult): boolean
    getChannels(): Channel[]
    handleWithAsync(handler?: string | null, callback?: Gio.AsyncReadyCallback | null): void
    handleWithFinish(result: Gio.AsyncResult): boolean
    handleWithTimeAsync(handler: string | null, userActionTime: number, callback?: Gio.AsyncReadyCallback | null): void
    handleWithTimeFinish(result: Gio.AsyncResult): boolean
    leaveChannelsAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveChannelsFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatchOperation */
    connect(sigName: "channel-lost", callback: ((channel: Channel, domain: number, code: number, message: string) => void)): number
    on(sigName: "channel-lost", callback: (channel: Channel, domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "channel-lost", callback: (channel: Channel, domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "channel-lost", callback: (channel: Channel, domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "channel-lost", channel: Channel, domain: number, code: number, message: string): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::possible-handlers", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::possible-handlers", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::possible-handlers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::possible-handlers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::possible-handlers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ChannelDispatchOperation_ConstructProps)
    _init (config?: ChannelDispatchOperation_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon, objectPath: string, immutableProperties: GLib.HashTable): ChannelDispatchOperation
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface ChannelDispatcher_ConstructProps extends Proxy_ConstructProps {
}
class ChannelDispatcher {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatcher */
    presentChannelAsync(channel: Channel, userActionTime: number, callback?: Gio.AsyncReadyCallback | null): void
    presentChannelFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ChannelDispatcher_ConstructProps)
    _init (config?: ChannelDispatcher_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon): ChannelDispatcher
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface ChannelRequest_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.ChannelRequest */
    channelFactory?: GObject.Object
}
class ChannelRequest {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ChannelRequest */
    readonly account: Account
    channelFactory: GObject.Object
    readonly hintsVardict: GLib.Variant
    readonly immutablePropertiesVardict: GLib.Variant
    readonly preferredHandler: string
    readonly userActionTime: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ChannelRequest */
    dupHints(): GLib.Variant
    dupImmutableProperties(): GLib.Variant
    getAccount(): Account
    getHints(): GLib.HashTable
    getImmutableProperties(): GLib.HashTable
    getPreferredHandler(): string
    getUserActionTime(): number
    setChannelFactory(factory: ClientChannelFactory): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ChannelRequest */
    connect(sigName: "succeeded", callback: (() => void)): number
    on(sigName: "succeeded", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "succeeded", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "succeeded", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "succeeded"): void
    connect(sigName: "succeeded-with-channel", callback: ((connection: Connection, channel: Channel) => void)): number
    on(sigName: "succeeded-with-channel", callback: (connection: Connection, channel: Channel) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "succeeded-with-channel", callback: (connection: Connection, channel: Channel) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "succeeded-with-channel", callback: (connection: Connection, channel: Channel) => void): NodeJS.EventEmitter
    emit(sigName: "succeeded-with-channel", connection: Connection, channel: Channel): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::account", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::account", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::account", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::account", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::account", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-factory", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-factory", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-factory", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-factory", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-factory", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hints-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hints-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hints-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hints-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hints-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::immutable-properties-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::immutable-properties-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::immutable-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::immutable-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::immutable-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::preferred-handler", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::preferred-handler", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::preferred-handler", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::preferred-handler", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::preferred-handler", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::user-action-time", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::user-action-time", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::user-action-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::user-action-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::user-action-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ChannelRequest_ConstructProps)
    _init (config?: ChannelRequest_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon, objectPath: string, immutableProperties: GLib.HashTable): ChannelRequest
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface ClientMessage_ConstructProps extends Message_ConstructProps {
}
class ClientMessage {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Message */
    appendPart(): number
    countParts(): number
    deleteKey(part: number, key: string): boolean
    deletePart(part: number): void
    destroy(): void
    dupPart(part: number): GLib.Variant
    getMessageType(): ChannelTextMessageType
    getPendingMessageId(): [ /* returnType */ number, /* valid */ boolean ]
    getReceivedTimestamp(): number
    getSentTimestamp(): number
    getSpecificToInterface(): string
    getSupersedes(): string
    getToken(): string
    isDeliveryReport(): boolean
    isMutable(): boolean
    isRescued(): boolean
    isScrollback(): boolean
    peek(part: number): GLib.HashTable
    refHandle(handleType: HandleType, handle: Handle): void
    set(part: number, key: string, source: any): void
    setBoolean(part: number, key: string, b: boolean): void
    setBytes(part: number, key: string, len: number, bytes?: object | null): void
    setHandle(part: number, key: string, handleType: HandleType, handleOr0: Handle): void
    setInt32(part: number, key: string, i: number): void
    setInt64(part: number, key: string, i: number): void
    setString(part: number, key: string, s: string): void
    setUint32(part: number, key: string, u: number): void
    setUint64(part: number, key: string, u: number): void
    setVariant(part: number, key: string, value: GLib.Variant): void
    takeMessage(part: number, key: string, message: Message): void
    toText(): [ /* returnType */ string, /* outFlags */ ChannelTextMessageFlags ]
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ClientMessage_ConstructProps)
    _init (config?: ClientMessage_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): ClientMessage
    static newText(type: ChannelTextMessageType, text: string): ClientMessage
    static $gtype: GObject.Type
}
interface Connection_ConstructProps extends Proxy_ConstructProps {
}
class Connection {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Connection */
    readonly balance: number
    readonly balanceCurrency: string
    readonly balanceScale: number
    readonly balanceUri: string
    readonly blockedContacts: object[]
    readonly canChangeContactList: boolean
    readonly canReportAbusive: boolean
    readonly capabilities: Capabilities
    readonly cmName: string
    readonly connectionManagerName: string
    readonly connectionReady: boolean
    readonly contactGroups: string[]
    readonly contactListPersists: boolean
    readonly contactListState: number
    readonly disjointGroups: boolean
    readonly groupStorage: number
    readonly protocolName: string
    readonly requestUsesMessage: boolean
    readonly selfContact: Contact
    readonly selfHandle: number
    readonly status: number
    readonly statusReason: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Connection */
    addClientInterest(interestedIn: string): void
    addToGroupAsync(group: string, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    addToGroupFinish(result: Gio.AsyncResult): boolean
    authorizePublicationAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    authorizePublicationFinish(result: Gio.AsyncResult): boolean
    bindConnectionStatusToProperty(target: object | null, targetProperty: string, invert: boolean): GObject.Binding
    blockContactsAsync(contacts: Contact[], reportAbusive: boolean, callback?: Gio.AsyncReadyCallback | null): void
    blockContactsFinish(result: Gio.AsyncResult): boolean
    canSetContactAlias(): boolean
    disconnectAsync(callback?: Gio.AsyncReadyCallback | null): void
    disconnectFinish(result: Gio.AsyncResult): boolean
    dupContactByIdAsync(id: string, features?: ContactFeature[] | null, callback?: Gio.AsyncReadyCallback | null): void
    dupContactByIdFinish(result: Gio.AsyncResult): Contact
    dupContactIfPossible(handle: Handle, identifier: string): Contact
    dupContactInfoSupportedFields(): ContactInfoFieldSpec[]
    dupContactList(): Contact[]
    dupDetailedErrorVardict(): [ /* returnType */ string | null, /* details */ GLib.Variant | null ]
    getAccount(): Account
    getAvatarRequirements(): AvatarRequirements
    getBalance(): [ /* returnType */ boolean, /* balance */ number, /* scale */ number, /* currency */ string ]
    getBalanceUri(): string
    getBlockedContacts(): Contact[]
    getCanChangeContactList(): boolean
    getCapabilities(): Capabilities
    getCmName(): string
    getConnectionManagerName(): string
    getContactAttributes(timeoutMs: number, handles: Handle[], interfaces: string, hold: boolean, callback: GObject.Callback, weakObject: GObject.Object): void
    getContactGroups(): string[]
    getContactInfoFlags(): ContactInfoFlags
    getContactInfoSupportedFields(): ContactInfoFieldSpec[]
    getContactListAttributes(timeoutMs: number, interfaces: string, hold: boolean, callback: GObject.Callback, weakObject: GObject.Object): void
    getContactListPersists(): boolean
    getContactListState(): ContactListState
    getContactsByHandle(handles: number[], features: number[] | null, callback: ConnectionContactsByHandleCb, weakObject?: GObject.Object | null): void
    getContactsById(ids: string[], features: ContactFeature[] | null, callback: ConnectionContactsByIdCb, weakObject?: GObject.Object | null): void
    getDetailedError(): [ /* returnType */ string | null, /* details */ GLib.HashTable | null ]
    getDisjointGroups(): boolean
    getGroupStorage(): ContactMetadataStorageType
    getProtocolName(): string
    getRequestUsesMessage(): boolean
    getSelfContact(): Contact
    getSelfHandle(): Handle
    getStatus(): [ /* returnType */ ConnectionStatus, /* reason */ ConnectionStatusReason ]
    hasImmortalHandles(): boolean
    holdHandles(timeoutMs: number, handleType: HandleType, handles: Handle[], callback: ConnectionHoldHandlesCb, weakObject: GObject.Object): void
    parseObjectPath(): [ /* returnType */ boolean, /* protocol */ string, /* cmName */ string ]
    refreshContactInfo(contacts: Contact[]): void
    removeContactsAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    removeContactsFinish(result: Gio.AsyncResult): boolean
    removeFromGroupAsync(group: string, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    removeFromGroupFinish(result: Gio.AsyncResult): boolean
    removeGroupAsync(group: string, callback?: Gio.AsyncReadyCallback | null): void
    removeGroupFinish(result: Gio.AsyncResult): boolean
    renameGroupAsync(oldName: string, newName: string, callback?: Gio.AsyncReadyCallback | null): void
    renameGroupFinish(result: Gio.AsyncResult): boolean
    requestHandles(timeoutMs: number, handleType: HandleType, ids: string[], callback: ConnectionRequestHandlesCb, weakObject: GObject.Object): void
    requestSubscriptionAsync(contacts: Contact[], message: string, callback?: Gio.AsyncReadyCallback | null): void
    requestSubscriptionFinish(result: Gio.AsyncResult): boolean
    setContactInfoAsync(info: ContactInfoField[], callback?: Gio.AsyncReadyCallback | null): void
    setContactInfoFinish(result: Gio.AsyncResult): boolean
    setGroupMembersAsync(group: string, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    setGroupMembersFinish(result: Gio.AsyncResult): boolean
    unblockContactsAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    unblockContactsFinish(result: Gio.AsyncResult): boolean
    unpublishAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    unpublishFinish(result: Gio.AsyncResult): boolean
    unrefHandles(handleType: HandleType, handles: Handle[]): void
    unsubscribeAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    unsubscribeFinish(result: Gio.AsyncResult): boolean
    upgradeContacts(contacts: Contact[], features: ContactFeature[], callback: ConnectionUpgradeContactsCb, weakObject?: GObject.Object | null): void
    upgradeContactsAsync(contacts: Contact[], features: ContactFeature[], callback?: Gio.AsyncReadyCallback | null): void
    upgradeContactsFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* contacts */ Contact[] | null ]
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Connection */
    connect(sigName: "balance-changed", callback: ((balance: number, balanceScale: number, balanceCurrency: string) => void)): number
    on(sigName: "balance-changed", callback: (balance: number, balanceScale: number, balanceCurrency: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "balance-changed", callback: (balance: number, balanceScale: number, balanceCurrency: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "balance-changed", callback: (balance: number, balanceScale: number, balanceCurrency: string) => void): NodeJS.EventEmitter
    emit(sigName: "balance-changed", balance: number, balanceScale: number, balanceCurrency: string): void
    connect(sigName: "blocked-contacts-changed", callback: ((added: Contact[], removed: Contact[]) => void)): number
    on(sigName: "blocked-contacts-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "blocked-contacts-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "blocked-contacts-changed", callback: (added: Contact[], removed: Contact[]) => void): NodeJS.EventEmitter
    emit(sigName: "blocked-contacts-changed", added: Contact[], removed: Contact[]): void
    connect(sigName: "contact-list-changed", callback: ((added: Contact[], removed: Contact[]) => void)): number
    on(sigName: "contact-list-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "contact-list-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "contact-list-changed", callback: (added: Contact[], removed: Contact[]) => void): NodeJS.EventEmitter
    emit(sigName: "contact-list-changed", added: Contact[], removed: Contact[]): void
    connect(sigName: "group-renamed", callback: ((oldName: string, newName: string) => void)): number
    on(sigName: "group-renamed", callback: (oldName: string, newName: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-renamed", callback: (oldName: string, newName: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-renamed", callback: (oldName: string, newName: string) => void): NodeJS.EventEmitter
    emit(sigName: "group-renamed", oldName: string, newName: string): void
    connect(sigName: "groups-created", callback: ((added: string[]) => void)): number
    on(sigName: "groups-created", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "groups-created", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "groups-created", callback: (added: string[]) => void): NodeJS.EventEmitter
    emit(sigName: "groups-created", added: string[]): void
    connect(sigName: "groups-removed", callback: ((added: string[]) => void)): number
    on(sigName: "groups-removed", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "groups-removed", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "groups-removed", callback: (added: string[]) => void): NodeJS.EventEmitter
    emit(sigName: "groups-removed", added: string[]): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::balance", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::balance-currency", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance-currency", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance-currency", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance-currency", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance-currency", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::balance-scale", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance-scale", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance-scale", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance-scale", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance-scale", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::balance-uri", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance-uri", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance-uri", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance-uri", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance-uri", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::blocked-contacts", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::blocked-contacts", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::blocked-contacts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::blocked-contacts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::blocked-contacts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::can-change-contact-list", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-change-contact-list", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::can-change-contact-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::can-change-contact-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::can-change-contact-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::can-report-abusive", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-report-abusive", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::can-report-abusive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::can-report-abusive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::can-report-abusive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::capabilities", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cm-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cm-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-manager-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-manager-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-manager-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-manager-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-manager-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-groups", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-groups", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-list-persists", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-list-persists", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-list-persists", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-list-persists", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-list-persists", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-list-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-list-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-list-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-list-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-list-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::disjoint-groups", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::disjoint-groups", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::disjoint-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::disjoint-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::disjoint-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-storage", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-storage", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-uses-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-uses-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-uses-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-uses-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-uses-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::status-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::status-reason", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Connection_ConstructProps)
    _init (config?: Connection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, busName?: string | null, objectPath?: string | null): Connection
    static getFeatureQuarkAliasing(): GLib.Quark
    static getFeatureQuarkAvatarRequirements(): GLib.Quark
    static getFeatureQuarkBalance(): GLib.Quark
    static getFeatureQuarkCapabilities(): GLib.Quark
    static getFeatureQuarkConnected(): GLib.Quark
    static getFeatureQuarkContactBlocking(): GLib.Quark
    static getFeatureQuarkContactGroups(): GLib.Quark
    static getFeatureQuarkContactInfo(): GLib.Quark
    static getFeatureQuarkContactList(): GLib.Quark
    static getFeatureQuarkContactListProperties(): GLib.Quark
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static presenceTypeCmpAvailability(p1: ConnectionPresenceType, p2: ConnectionPresenceType): number
    static $gtype: GObject.Type
}
interface ConnectionManager_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.ConnectionManager */
    alwaysIntrospect?: boolean
    managerFile?: string
}
class ConnectionManager {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ConnectionManager */
    alwaysIntrospect: boolean
    readonly cmName: string
    readonly connectionManager: string
    readonly infoSource: number
    managerFile: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ConnectionManager */
    dupProtocolNames(): string[]
    dupProtocols(): Protocol[]
    getInfoSource(): CMInfoSource
    getName(): string
    getProtocol(protocol: string): ConnectionManagerProtocol
    getProtocolObject(protocol: string): Protocol
    hasProtocol(protocol: string): boolean
    isRunning(): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ConnectionManager */
    connect(sigName: "activated", callback: (() => void)): number
    on(sigName: "activated", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "activated", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "activated", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "activated"): void
    connect(sigName: "exited", callback: (() => void)): number
    on(sigName: "exited", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "exited", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "exited", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "exited"): void
    connect(sigName: "got-info", callback: ((source: number) => void)): number
    on(sigName: "got-info", callback: (source: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "got-info", callback: (source: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "got-info", callback: (source: number) => void): NodeJS.EventEmitter
    emit(sigName: "got-info", source: number): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::always-introspect", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::always-introspect", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::always-introspect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::always-introspect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::always-introspect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cm-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cm-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-manager", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::info-source", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::info-source", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::info-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::info-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::info-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::manager-file", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::manager-file", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::manager-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::manager-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::manager-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ConnectionManager_ConstructProps)
    _init (config?: ConnectionManager_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, name: string, managerFilename?: string | null): ConnectionManager
    static checkValidName(name: string): boolean
    static checkValidProtocolName(name: string): boolean
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface Contact_ConstructProps extends GObject.Object_ConstructProps {
}
class Contact {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Contact */
    readonly alias: string
    readonly avatarFile: Gio.File
    readonly avatarMimeType: string
    readonly avatarToken: string
    readonly capabilities: Capabilities
    readonly clientTypes: string[]
    readonly connection: Connection
    readonly contactGroups: string[]
    readonly contactInfo: any
    readonly handle: number
    readonly identifier: string
    readonly isBlocked: boolean
    readonly locationVardict: GLib.Variant
    readonly presenceMessage: string
    readonly presenceStatus: string
    readonly presenceType: number
    readonly publishRequest: string
    readonly publishState: number
    readonly subscribeState: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Contact */
    addToGroupAsync(group: string, callback?: Gio.AsyncReadyCallback | null): void
    addToGroupFinish(result: Gio.AsyncResult): boolean
    authorizePublicationAsync(callback?: Gio.AsyncReadyCallback | null): void
    authorizePublicationFinish(result: Gio.AsyncResult): boolean
    blockAsync(reportAbusive: boolean, callback?: Gio.AsyncReadyCallback | null): void
    blockFinish(result: Gio.AsyncResult): boolean
    dupContactInfo(): ContactInfoField[]
    dupLocation(): GLib.Variant
    getAccount(): Account
    getAlias(): string
    getAvatarFile(): Gio.File
    getAvatarMimeType(): string
    getAvatarToken(): string
    getCapabilities(): Capabilities
    getClientTypes(): string[]
    getConnection(): Connection
    getContactGroups(): string[]
    getContactInfo(): ContactInfoField[]
    getHandle(): Handle
    getIdentifier(): string
    getLocation(): GLib.HashTable
    getPresenceMessage(): string
    getPresenceStatus(): string
    getPresenceType(): ConnectionPresenceType
    getPublishRequest(): string
    getPublishState(): SubscriptionState
    getSubscribeState(): SubscriptionState
    hasFeature(feature: ContactFeature): boolean
    removeAsync(callback?: Gio.AsyncReadyCallback | null): void
    removeFinish(result: Gio.AsyncResult): boolean
    removeFromGroupAsync(group: string, callback?: Gio.AsyncReadyCallback | null): void
    removeFromGroupFinish(result: Gio.AsyncResult): boolean
    requestContactInfoAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    requestContactInfoFinish(result: Gio.AsyncResult): boolean
    requestSubscriptionAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    requestSubscriptionFinish(result: Gio.AsyncResult): boolean
    setContactGroupsAsync(groups?: string[] | null, callback?: Gio.AsyncReadyCallback | null): void
    setContactGroupsFinish(result: Gio.AsyncResult): boolean
    unblockAsync(callback?: Gio.AsyncReadyCallback | null): void
    unblockFinish(result: Gio.AsyncResult): boolean
    unpublishAsync(callback?: Gio.AsyncReadyCallback | null): void
    unpublishFinish(result: Gio.AsyncResult): boolean
    unsubscribeAsync(callback?: Gio.AsyncReadyCallback | null): void
    unsubscribeFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Contact */
    connect(sigName: "contact-groups-changed", callback: ((added: string[], removed: string[]) => void)): number
    on(sigName: "contact-groups-changed", callback: (added: string[], removed: string[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "contact-groups-changed", callback: (added: string[], removed: string[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "contact-groups-changed", callback: (added: string[], removed: string[]) => void): NodeJS.EventEmitter
    emit(sigName: "contact-groups-changed", added: string[], removed: string[]): void
    connect(sigName: "presence-changed", callback: ((type: number, status: string, message: string) => void)): number
    on(sigName: "presence-changed", callback: (type: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "presence-changed", callback: (type: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "presence-changed", callback: (type: number, status: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "presence-changed", type: number, status: string, message: string): void
    connect(sigName: "subscription-states-changed", callback: ((subscribe: number, publish: number, publishRequest: string) => void)): number
    on(sigName: "subscription-states-changed", callback: (subscribe: number, publish: number, publishRequest: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "subscription-states-changed", callback: (subscribe: number, publish: number, publishRequest: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "subscription-states-changed", callback: (subscribe: number, publish: number, publishRequest: string) => void): NodeJS.EventEmitter
    emit(sigName: "subscription-states-changed", subscribe: number, publish: number, publishRequest: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::alias", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alias", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-file", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-file", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-mime-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-mime-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-token", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-token", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-token", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-token", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-token", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::capabilities", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::client-types", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-types", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::client-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::client-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::client-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-groups", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-groups", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-info", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-info", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::is-blocked", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-blocked", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::is-blocked", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::is-blocked", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::is-blocked", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::location-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::location-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::location-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::location-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::location-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::presence-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::presence-message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::presence-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::presence-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::presence-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::presence-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::presence-status", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::presence-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::presence-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::presence-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::presence-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::publish-request", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::publish-request", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::publish-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::publish-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::publish-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::publish-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::publish-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::publish-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::publish-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::publish-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::subscribe-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subscribe-state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::subscribe-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::subscribe-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::subscribe-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Contact_ConstructProps)
    _init (config?: Contact_ConstructProps): void
    static $gtype: GObject.Type
}
interface ContactSearch_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.ContactSearch */
    account?: Account
    limit?: number
    server?: string
}
class ContactSearch {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ContactSearch */
    limit: number
    readonly state: number
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ContactSearch */
    getAccount(): Account
    getLimit(): number
    getSearchKeys(): string[]
    getServer(): string
    resetAsync(server: string, limit: number, callback?: Gio.AsyncReadyCallback | null): void
    resetFinish(result: Gio.AsyncResult): string[]
    start(criteria: GLib.HashTable): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    initAsync(ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    initFinish(res: Gio.AsyncResult): boolean
    newFinish(res: Gio.AsyncResult): GObject.Object
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ContactSearch */
    connect(sigName: "search-results-received", callback: ((results: ContactSearchResult[]) => void)): number
    on(sigName: "search-results-received", callback: (results: ContactSearchResult[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "search-results-received", callback: (results: ContactSearchResult[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "search-results-received", callback: (results: ContactSearchResult[]) => void): NodeJS.EventEmitter
    emit(sigName: "search-results-received", results: ContactSearchResult[]): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::limit", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::limit", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::limit", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::limit", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::limit", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ContactSearch_ConstructProps)
    _init (config?: ContactSearch_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newFinish(result: Gio.AsyncResult): ContactSearch
    static newAsync(account: Account, server: string, limit: number, callback?: Gio.AsyncReadyCallback | null): void
    static newvAsync(objectType: GObject.Type, nParameters: number, parameters: GObject.Parameter, ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    static $gtype: GObject.Type
}
interface ContactSearchResult_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.ContactSearchResult */
    identifier?: string
}
class ContactSearchResult {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ContactSearchResult */
    dupFields(): ContactInfoField[]
    getField(field: string): ContactInfoField
    getFields(): ContactInfoField[]
    getIdentifier(): string
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ContactSearchResult_ConstructProps)
    _init (config?: ContactSearchResult_ConstructProps): void
    static $gtype: GObject.Type
}
interface DBusDaemon_ConstructProps extends Proxy_ConstructProps {
}
class DBusDaemon {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DBusDaemon */
    getUniqueName(): string
    listActivatableNames(timeoutMs: number, callback: DBusDaemonListNamesCb, weakObject: GObject.Object): void
    listNames(timeoutMs: number, callback: DBusDaemonListNamesCb, weakObject: GObject.Object): void
    registerObject(objectPath: string, object: GObject.Object): void
    releaseName(wellKnownName: string): boolean
    requestName(wellKnownName: string, idempotent: boolean): boolean
    unregisterObject(object: GObject.Object): void
    watchNameOwner(name: string, callback: DBusDaemonNameOwnerChangedCb): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DBusDaemon_ConstructProps)
    _init (config?: DBusDaemon_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static dup(): DBusDaemon
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface DBusTubeChannel_ConstructProps extends Channel_ConstructProps {
}
class DBusTubeChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.DBusTubeChannel */
    readonly parametersVardict: GLib.Variant
    readonly serviceName: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DBusTubeChannel */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): Gio.DBusConnection
    dupParametersVardict(): GLib.Variant
    getServiceName(): string
    offerAsync(params?: GLib.HashTable | null, callback?: Gio.AsyncReadyCallback | null): void
    offerFinish(result: Gio.AsyncResult): Gio.DBusConnection
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): [ /* returnType */ Handle, /* handleType */ HandleType ]
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): [ /* returnType */ boolean, /* actor */ Contact | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetLocalPendingInfo(localPending: Handle): [ /* returnType */ boolean, /* actor */ Handle | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: ((contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: ((added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: ((added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: ((message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: ((added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parameters-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameters-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DBusTubeChannel_ConstructProps)
    _init (config?: DBusTubeChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static featureQuarkCore(): GLib.Quark
    static $gtype: GObject.Type
}
interface DebugClient_ConstructProps extends Proxy_ConstructProps {
}
class DebugClient {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.DebugClient */
    readonly enabled: boolean
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DebugClient */
    getMessagesAsync(callback?: Gio.AsyncReadyCallback | null): void
    getMessagesFinish(result: Gio.AsyncResult): DebugMessage[]
    isEnabled(): boolean
    setEnabledAsync(enabled: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setEnabledFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.DebugClient */
    connect(sigName: "new-debug-message", callback: ((message: DebugMessage) => void)): number
    on(sigName: "new-debug-message", callback: (message: DebugMessage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-debug-message", callback: (message: DebugMessage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-debug-message", callback: (message: DebugMessage) => void): NodeJS.EventEmitter
    emit(sigName: "new-debug-message", message: DebugMessage): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DebugClient_ConstructProps)
    _init (config?: DebugClient_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, uniqueName: string): DebugClient
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface DebugMessage_ConstructProps extends GObject.Object_ConstructProps {
}
class DebugMessage {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.DebugMessage */
    readonly category: string
    readonly domain: string
    readonly level: number
    readonly message: string
    readonly time: GLib.DateTime
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DebugMessage */
    getCategory(): string
    getDomain(): string
    getLevel(): GLib.LogLevelFlags
    getMessage(): string
    getTime(): GLib.DateTime
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::category", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::category", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::domain", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::domain", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::level", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::level", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::message", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::time", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::time", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DebugMessage_ConstructProps)
    _init (config?: DebugMessage_ConstructProps): void
    static $gtype: GObject.Type
}
interface FileTransferChannel_ConstructProps extends Channel_ConstructProps {
}
class FileTransferChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.FileTransferChannel */
    readonly date: GLib.DateTime
    readonly description: string
    readonly file: Gio.File
    readonly filename: string
    readonly initialOffset: number
    readonly mimeType: string
    readonly serviceName: string
    readonly size: number
    readonly state: number
    readonly transferredBytes: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.FileTransferChannel */
    acceptFileAsync(file: Gio.File, offset: number, callback?: Gio.AsyncReadyCallback | null): void
    acceptFileFinish(result: Gio.AsyncResult): boolean
    getDate(): GLib.DateTime
    getDescription(): string
    getFilename(): string
    getMetadata(): GLib.HashTable
    getMimeType(): string
    getServiceName(): string
    getSize(): number
    getState(): [ /* returnType */ FileTransferState, /* reason */ FileTransferStateChangeReason ]
    getTransferredBytes(): number
    provideFileAsync(file: Gio.File, callback?: Gio.AsyncReadyCallback | null): void
    provideFileFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): [ /* returnType */ Handle, /* handleType */ HandleType ]
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): [ /* returnType */ boolean, /* actor */ Contact | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetLocalPendingInfo(localPending: Handle): [ /* returnType */ boolean, /* actor */ Handle | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: ((contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: ((added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: ((added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: ((message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: ((added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::date", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::date", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::date", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::date", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::date", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::file", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::file", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-offset", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mime-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mime-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transferred-bytes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transferred-bytes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transferred-bytes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transferred-bytes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transferred-bytes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: FileTransferChannel_ConstructProps)
    _init (config?: FileTransferChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): FileTransferChannel
    /* Function overloads */
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): FileTransferChannel
    static getFeatureQuarkCore(): GLib.Quark
    static $gtype: GObject.Type
}
interface HandleChannelsContext_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.HandleChannelsContext */
    account?: Account
    channels?: object[]
    connection?: Connection
    requestsSatisfied?: object[]
    userActionTime?: number
}
class HandleChannelsContext {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.HandleChannelsContext */
    accept(): void
    delay(): void
    fail(error: GLib.Error): void
    getHandlerInfo(): GLib.HashTable
    getRequests(): ChannelRequest[]
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.HandleChannelsContext */
    connect(sigName: "done", callback: (() => void)): number
    on(sigName: "done", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "done", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "done", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "done"): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandleChannelsContext_ConstructProps)
    _init (config?: HandleChannelsContext_ConstructProps): void
    static $gtype: GObject.Type
}
interface Message_ConstructProps extends GObject.Object_ConstructProps {
}
class Message {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Message */
    appendPart(): number
    countParts(): number
    deleteKey(part: number, key: string): boolean
    deletePart(part: number): void
    destroy(): void
    dupPart(part: number): GLib.Variant
    getMessageType(): ChannelTextMessageType
    getPendingMessageId(): [ /* returnType */ number, /* valid */ boolean ]
    getReceivedTimestamp(): number
    getSentTimestamp(): number
    getSpecificToInterface(): string
    getSupersedes(): string
    getToken(): string
    isDeliveryReport(): boolean
    isMutable(): boolean
    isRescued(): boolean
    isScrollback(): boolean
    peek(part: number): GLib.HashTable
    refHandle(handleType: HandleType, handle: Handle): void
    set(part: number, key: string, source: any): void
    setBoolean(part: number, key: string, b: boolean): void
    setBytes(part: number, key: string, len: number, bytes?: object | null): void
    setHandle(part: number, key: string, handleType: HandleType, handleOr0: Handle): void
    setInt32(part: number, key: string, i: number): void
    setInt64(part: number, key: string, i: number): void
    setString(part: number, key: string, s: string): void
    setUint32(part: number, key: string, u: number): void
    setUint64(part: number, key: string, u: number): void
    setVariant(part: number, key: string, value: GLib.Variant): void
    takeMessage(part: number, key: string, message: Message): void
    toText(): [ /* returnType */ string, /* outFlags */ ChannelTextMessageFlags ]
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Message_ConstructProps)
    _init (config?: Message_ConstructProps): void
    static $gtype: GObject.Type
}
interface ObserveChannelsContext_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.ObserveChannelsContext */
    account?: Account
    channels?: object[]
    connection?: Connection
    dispatchOperation?: ChannelDispatchOperation
    requests?: object[]
}
class ObserveChannelsContext {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ObserveChannelsContext */
    accept(): void
    delay(): void
    fail(error: GLib.Error): void
    getRequests(): ChannelRequest[]
    isRecovering(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ObserveChannelsContext_ConstructProps)
    _init (config?: ObserveChannelsContext_ConstructProps): void
    static $gtype: GObject.Type
}
interface Protocol_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.Protocol */
    cmName?: string
    protocolName?: string
}
class Protocol {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Protocol */
    readonly addressableUriSchemes: string[]
    readonly addressableVcardFields: string[]
    readonly authenticationTypes: string[]
    readonly avatarRequirements: object
    readonly capabilities: Capabilities
    readonly englishName: string
    readonly iconName: string
    readonly paramNames: string[]
    readonly protocolPropertiesVardict: GLib.Variant
    readonly vcardField: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Protocol */
    canRegister(): boolean
    dupImmutableProperties(): GLib.Variant
    dupParam(param: string): ConnectionManagerParam
    dupParamNames(): string[]
    dupParams(): ConnectionManagerParam[]
    dupPresenceStatuses(): PresenceStatusSpec[]
    getAddressableUriSchemes(): string[]
    getAddressableVcardFields(): string[]
    getAuthenticationTypes(): string[]
    getAvatarRequirements(): AvatarRequirements
    getCapabilities(): Capabilities
    getCmName(): string
    getEnglishName(): string
    getIconName(): string
    getName(): string
    getParam(param: string): ConnectionManagerParam
    getVcardField(): string
    hasParam(param: string): boolean
    identifyAccountAsync(vardict: GLib.Variant, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    identifyAccountFinish(result: Gio.AsyncResult): string
    normalizeContactAsync(contact: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    normalizeContactFinish(result: Gio.AsyncResult): string
    normalizeContactUriAsync(uri: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    normalizeContactUriFinish(result: Gio.AsyncResult): string
    normalizeVcardAddressAsync(field: string, value: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    normalizeVcardAddressFinish(result: Gio.AsyncResult): string
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::addressable-uri-schemes", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addressable-uri-schemes", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::addressable-uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::addressable-uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::addressable-uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::addressable-vcard-fields", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addressable-vcard-fields", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::addressable-vcard-fields", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::addressable-vcard-fields", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::addressable-vcard-fields", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::authentication-types", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::authentication-types", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::authentication-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::authentication-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::authentication-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-requirements", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-requirements", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-requirements", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-requirements", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-requirements", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::capabilities", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::english-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::english-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::english-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::english-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::english-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon-name", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::param-names", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::param-names", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::param-names", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::param-names", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::param-names", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol-properties-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-properties-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::vcard-field", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vcard-field", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::vcard-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::vcard-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::vcard-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Protocol_ConstructProps)
    _init (config?: Protocol_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, cmName: string, protocolName: string, immutableProperties: GLib.HashTable): Protocol
    static newVardict(dbus: DBusDaemon, cmName: string, protocolName: string, immutableProperties: GLib.Variant): Protocol
    static getFeatureQuarkCore(): GLib.Quark
    static getFeatureQuarkParameters(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface Proxy_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    busName?: string
    dbusDaemon?: DBusDaemon
    factory?: SimpleClientFactory
    objectPath?: string
}
class Proxy {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Proxy_ConstructProps)
    _init (config?: Proxy_ConstructProps): void
    static $gtype: GObject.Type
}
interface RoomInfo_ConstructProps extends GObject.Object_ConstructProps {
}
class RoomInfo {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.RoomInfo */
    getChannelType(): string
    getDescription(): string
    getHandle(): Handle
    getHandleName(): string
    getInviteOnly(known: boolean): boolean
    getMembersCount(known: boolean): number
    getName(): string
    getRequiresPassword(known: boolean): boolean
    getRoomId(): string
    getServer(): string
    getSubject(): string
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: RoomInfo_ConstructProps)
    _init (config?: RoomInfo_ConstructProps): void
    static $gtype: GObject.Type
}
interface RoomList_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.RoomList */
    account?: Account
    server?: string
}
class RoomList {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.RoomList */
    readonly listing: boolean
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.RoomList */
    getAccount(): Account
    getServer(): string
    isListing(): boolean
    start(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    initAsync(ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    initFinish(res: Gio.AsyncResult): boolean
    newFinish(res: Gio.AsyncResult): GObject.Object
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.RoomList */
    connect(sigName: "failed", callback: ((error: GLib.Error) => void)): number
    on(sigName: "failed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "failed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "failed", callback: (error: GLib.Error) => void): NodeJS.EventEmitter
    emit(sigName: "failed", error: GLib.Error): void
    connect(sigName: "got-room", callback: ((room: RoomInfo) => void)): number
    on(sigName: "got-room", callback: (room: RoomInfo) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "got-room", callback: (room: RoomInfo) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "got-room", callback: (room: RoomInfo) => void): NodeJS.EventEmitter
    emit(sigName: "got-room", room: RoomInfo): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::listing", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listing", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::listing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::listing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::listing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: RoomList_ConstructProps)
    _init (config?: RoomList_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newFinish(result: Gio.AsyncResult): RoomList
    static newAsync(account: Account, server: string, callback?: Gio.AsyncReadyCallback | null): void
    static newvAsync(objectType: GObject.Type, nParameters: number, parameters: GObject.Parameter, ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    static $gtype: GObject.Type
}
interface SignalledMessage_ConstructProps extends Message_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.SignalledMessage */
    sender?: Contact
}
class SignalledMessage {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Message */
    appendPart(): number
    countParts(): number
    deleteKey(part: number, key: string): boolean
    deletePart(part: number): void
    destroy(): void
    dupPart(part: number): GLib.Variant
    getMessageType(): ChannelTextMessageType
    getPendingMessageId(): [ /* returnType */ number, /* valid */ boolean ]
    getReceivedTimestamp(): number
    getSentTimestamp(): number
    getSpecificToInterface(): string
    getSupersedes(): string
    getToken(): string
    isDeliveryReport(): boolean
    isMutable(): boolean
    isRescued(): boolean
    isScrollback(): boolean
    peek(part: number): GLib.HashTable
    refHandle(handleType: HandleType, handle: Handle): void
    set(part: number, key: string, source: any): void
    setBoolean(part: number, key: string, b: boolean): void
    setBytes(part: number, key: string, len: number, bytes?: object | null): void
    setHandle(part: number, key: string, handleType: HandleType, handleOr0: Handle): void
    setInt32(part: number, key: string, i: number): void
    setInt64(part: number, key: string, i: number): void
    setString(part: number, key: string, s: string): void
    setUint32(part: number, key: string, u: number): void
    setUint64(part: number, key: string, u: number): void
    setVariant(part: number, key: string, value: GLib.Variant): void
    takeMessage(part: number, key: string, message: Message): void
    toText(): [ /* returnType */ string, /* outFlags */ ChannelTextMessageFlags ]
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SignalledMessage_ConstructProps)
    _init (config?: SignalledMessage_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getSender(message: Message): Contact
    static $gtype: GObject.Type
}
interface SimpleApprover_ConstructProps extends BaseClient_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.SimpleApprover */
    callback?: object
    destroy?: object
    userData?: object
}
class SimpleApprover {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* delegated */ Channel[], /* notDelegated */ GLib.HashTable ]
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: ((account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: ((request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleApprover_ConstructProps)
    _init (config?: SimpleApprover_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, name: string, uniquify: boolean, callback: SimpleApproverAddDispatchOperationImpl): SimpleApprover
    static newWithAm(accountManager: AccountManager, name: string, uniquify: boolean, callback: SimpleApproverAddDispatchOperationImpl): SimpleApprover
    static newWithFactory(factory: SimpleClientFactory, name: string, uniquify: boolean, callback: SimpleApproverAddDispatchOperationImpl): SimpleApprover
    static $gtype: GObject.Type
}
interface SimpleClientFactory_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.SimpleClientFactory */
    dbusDaemon?: DBusDaemon
}
class SimpleClientFactory {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.SimpleClientFactory */
    addAccountFeatures(features?: GLib.Quark[] | null): void
    addChannelFeatures(features?: GLib.Quark[] | null): void
    addConnectionFeatures(features?: GLib.Quark[] | null): void
    addContactFeatures(features?: ContactFeature[] | null): void
    dupAccountFeatures(account: Account): GLib.Quark[]
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    dupConnectionFeatures(connection: Connection): GLib.Quark[]
    dupContactFeatures(connection: Connection): ContactFeature[]
    ensureAccount(objectPath: string, immutableProperties: GLib.HashTable): Account
    ensureChannel(connection: Connection, objectPath: string, immutableProperties: GLib.HashTable): Channel
    ensureConnection(objectPath: string, immutableProperties: GLib.HashTable): Connection
    ensureContact(connection: Connection, handle: Handle, identifier: string): Contact
    ensureContactByIdAsync(connection: Connection, identifier: string, callback?: Gio.AsyncReadyCallback | null): void
    ensureContactByIdFinish(result: Gio.AsyncResult): Contact
    getDbusDaemon(): DBusDaemon
    upgradeContactsAsync(connection: Connection, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    upgradeContactsFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* contacts */ Contact[] | null ]
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleClientFactory_ConstructProps)
    _init (config?: SimpleClientFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus?: DBusDaemon | null): SimpleClientFactory
    static $gtype: GObject.Type
}
interface SimpleHandler_ConstructProps extends BaseClient_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.SimpleHandler */
    bypassApproval?: boolean
    callback?: object
    destroy?: object
    requests?: boolean
    userData?: object
}
class SimpleHandler {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* delegated */ Channel[], /* notDelegated */ GLib.HashTable ]
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: ((account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: ((request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleHandler_ConstructProps)
    _init (config?: SimpleHandler_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, bypassApproval: boolean, requests: boolean, name: string, uniquify: boolean, callback: SimpleHandlerHandleChannelsImpl): SimpleHandler
    static newWithAm(accountManager: AccountManager, bypassApproval: boolean, requests: boolean, name: string, uniquify: boolean, callback: SimpleHandlerHandleChannelsImpl): SimpleHandler
    static newWithFactory(factory: SimpleClientFactory, bypassApproval: boolean, requests: boolean, name: string, uniquify: boolean, callback: SimpleHandlerHandleChannelsImpl): SimpleHandler
    static $gtype: GObject.Type
}
interface SimpleObserver_ConstructProps extends BaseClient_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.SimpleObserver */
    callback?: object
    destroy?: object
    recover?: boolean
    userData?: object
}
class SimpleObserver {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* delegated */ Channel[], /* notDelegated */ GLib.HashTable ]
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: ((account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: ((request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleObserver_ConstructProps)
    _init (config?: SimpleObserver_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, recover: boolean, name: string, uniquify: boolean, callback: SimpleObserverObserveChannelsImpl): SimpleObserver
    static newWithAm(accountManager: AccountManager, recover: boolean, name: string, uniquify: boolean, callback: SimpleObserverObserveChannelsImpl): SimpleObserver
    static newWithFactory(factory: SimpleClientFactory, recover: boolean, name: string, uniquify: boolean, callback: SimpleObserverObserveChannelsImpl): SimpleObserver
    static $gtype: GObject.Type
}
interface StreamTubeChannel_ConstructProps extends Channel_ConstructProps {
}
class StreamTubeChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.StreamTubeChannel */
    readonly parametersVardict: GLib.Variant
    readonly service: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.StreamTubeChannel */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): StreamTubeConnection
    dupParametersVardict(): GLib.Variant
    getService(): string
    offerAsync(params?: GLib.HashTable | null, callback?: Gio.AsyncReadyCallback | null): void
    offerFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): [ /* returnType */ Handle, /* handleType */ HandleType ]
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): [ /* returnType */ boolean, /* actor */ Contact | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetLocalPendingInfo(localPending: Handle): [ /* returnType */ boolean, /* actor */ Handle | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.StreamTubeChannel */
    connect(sigName: "incoming", callback: ((tubeConnection: StreamTubeConnection) => void)): number
    on(sigName: "incoming", callback: (tubeConnection: StreamTubeConnection) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "incoming", callback: (tubeConnection: StreamTubeConnection) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "incoming", callback: (tubeConnection: StreamTubeConnection) => void): NodeJS.EventEmitter
    emit(sigName: "incoming", tubeConnection: StreamTubeConnection): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: ((contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: ((added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: ((added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: ((message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: ((added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parameters-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameters-vardict", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: StreamTubeChannel_ConstructProps)
    _init (config?: StreamTubeChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): StreamTubeChannel
    /* Function overloads */
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): StreamTubeChannel
    static $gtype: GObject.Type
}
interface StreamTubeConnection_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.StreamTubeConnection */
    channel?: StreamTubeChannel
    contact?: Contact
    socketConnection?: Gio.SocketConnection
}
class StreamTubeConnection {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.StreamTubeConnection */
    getChannel(): StreamTubeChannel
    getContact(): Contact
    getSocketConnection(): Gio.SocketConnection
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.StreamTubeConnection */
    connect(sigName: "closed", callback: ((error: GLib.Error) => void)): number
    on(sigName: "closed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "closed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "closed", callback: (error: GLib.Error) => void): NodeJS.EventEmitter
    emit(sigName: "closed", error: GLib.Error): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: StreamTubeConnection_ConstructProps)
    _init (config?: StreamTubeConnection_ConstructProps): void
    static $gtype: GObject.Type
}
interface TLSCertificate_ConstructProps extends Proxy_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.TLSCertificate */
    parent?: Proxy
}
class TLSCertificate {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.TLSCertificate */
    readonly certData: object[]
    readonly certType: string
    readonly state: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.TLSCertificate */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): boolean
    addRejection(reason: TLSCertificateRejectReason, dbusError: string, details?: GLib.Variant | null): void
    getCertData(): any[]
    getCertType(): string
    getNthRejection(n: number): TLSCertificateRejection | null
    getRejection(): TLSCertificateRejection | null
    getState(): TLSCertificateState
    rejectAsync(callback?: Gio.AsyncReadyCallback | null): void
    rejectFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::cert-data", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cert-data", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cert-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cert-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cert-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cert-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cert-type", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cert-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cert-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cert-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TLSCertificate_ConstructProps)
    _init (config?: TLSCertificate_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(connOrChan: Proxy, objectPath: string): TLSCertificate
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
interface TLSCertificateRejection_ConstructProps extends GObject.Object_ConstructProps {
    /* Constructor properties of TelepathyGLib-0.12.TelepathyGLib.TLSCertificateRejection */
    dbusError?: string
    details?: GLib.Variant
    error?: GLib.Error
    reason?: number
}
class TLSCertificateRejection {
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.TLSCertificateRejection */
    getDbusError(): string
    getDetails(): GLib.Variant
    getError(): GLib.Error
    getReason(): TLSCertificateRejectReason
    raiseError(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TLSCertificateRejection_ConstructProps)
    _init (config?: TLSCertificateRejection_ConstructProps): void
    static $gtype: GObject.Type
}
interface TextChannel_ConstructProps extends Channel_ConstructProps {
}
class TextChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.TextChannel */
    readonly deliveryReportingSupport: number
    readonly isSmsChannel: boolean
    readonly messagePartSupportFlags: number
    readonly smsFlash: boolean
    readonly supportedContentTypes: string[]
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    readonly gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.TextChannel */
    ackAllPendingMessagesAsync(callback?: Gio.AsyncReadyCallback | null): void
    ackAllPendingMessagesFinish(result: Gio.AsyncResult): boolean
    ackMessageAsync(message: Message, callback?: Gio.AsyncReadyCallback | null): void
    ackMessageFinish(result: Gio.AsyncResult): boolean
    ackMessagesAsync(messages: SignalledMessage[], callback?: Gio.AsyncReadyCallback | null): void
    ackMessagesFinish(result: Gio.AsyncResult): boolean
    dupPendingMessages(): SignalledMessage[]
    getChatState(contact: Contact): ChannelChatState
    getDeliveryReportingSupport(): DeliveryReportingSupportFlags
    getMessagePartSupportFlags(): MessagePartSupportFlags
    getMessageTypes(): ChannelTextMessageType[]
    getPendingMessages(): SignalledMessage[]
    getSmsFlash(): boolean
    getSmsLengthAsync(message: Message, callback?: Gio.AsyncReadyCallback | null): void
    getSmsLengthFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* chunksRequired */ number, /* remainingCharacters */ number, /* estimatedCost */ number ]
    getSupportedContentTypes(): string[]
    sendMessageAsync(message: Message, flags: MessageSendingFlags, callback?: Gio.AsyncReadyCallback | null): void
    sendMessageFinish(result: Gio.AsyncResult): [ /* returnType */ boolean, /* token */ string ]
    setChatStateAsync(state: ChannelChatState, callback?: Gio.AsyncReadyCallback | null): void
    setChatStateFinish(result: Gio.AsyncResult): boolean
    supportsMessageType(messageType: ChannelTextMessageType): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): [ /* returnType */ Handle, /* handleType */ HandleType ]
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): [ /* returnType */ boolean, /* actor */ Contact | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetLocalPendingInfo(localPending: Handle): [ /* returnType */ boolean, /* actor */ Handle | null, /* reason */ ChannelGroupChangeReason | null, /* message */ string | null ]
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.TextChannel */
    connect(sigName: "contact-chat-state-changed", callback: ((contact: Contact, state: number) => void)): number
    on(sigName: "contact-chat-state-changed", callback: (contact: Contact, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "contact-chat-state-changed", callback: (contact: Contact, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "contact-chat-state-changed", callback: (contact: Contact, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "contact-chat-state-changed", contact: Contact, state: number): void
    connect(sigName: "message-received", callback: ((message: SignalledMessage) => void)): number
    on(sigName: "message-received", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "message-received", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "message-received", callback: (message: SignalledMessage) => void): NodeJS.EventEmitter
    emit(sigName: "message-received", message: SignalledMessage): void
    connect(sigName: "message-sent", callback: ((message: SignalledMessage, flags: number, token: string) => void)): number
    on(sigName: "message-sent", callback: (message: SignalledMessage, flags: number, token: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "message-sent", callback: (message: SignalledMessage, flags: number, token: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "message-sent", callback: (message: SignalledMessage, flags: number, token: string) => void): NodeJS.EventEmitter
    emit(sigName: "message-sent", message: SignalledMessage, flags: number, token: string): void
    connect(sigName: "pending-message-removed", callback: ((message: SignalledMessage) => void)): number
    on(sigName: "pending-message-removed", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pending-message-removed", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pending-message-removed", callback: (message: SignalledMessage) => void): NodeJS.EventEmitter
    emit(sigName: "pending-message-removed", message: SignalledMessage): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: ((contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: ((added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: ((added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: ((message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: ((added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: ((id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: ((domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::delivery-reporting-support", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delivery-reporting-support", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delivery-reporting-support", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delivery-reporting-support", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delivery-reporting-support", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::is-sms-channel", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-sms-channel", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::is-sms-channel", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::is-sms-channel", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::is-sms-channel", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::message-part-support-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-part-support-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::message-part-support-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::message-part-support-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::message-part-support-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::sms-flash", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sms-flash", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::sms-flash", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::sms-flash", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::sms-flash", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::supported-content-types", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-content-types", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::supported-content-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::supported-content-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::supported-content-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: ((pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TextChannel_ConstructProps)
    _init (config?: TextChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): TextChannel
    /* Function overloads */
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): TextChannel
    static getFeatureQuarkChatStates(): GLib.Quark
    static getFeatureQuarkIncomingMessages(): GLib.Quark
    static getFeatureQuarkSms(): GLib.Quark
    static $gtype: GObject.Type
}
abstract class AccountChannelRequestClass {
    static name: string
}
class AccountChannelRequestPrivate {
    static name: string
}
abstract class AccountClass {
    static name: string
}
class AccountClassPrivate {
    static name: string
}
abstract class AccountManagerClass {
    static name: string
}
class AccountManagerClassPrivate {
    static name: string
}
class AccountManagerPrivate {
    static name: string
}
class AccountPrivate {
    static name: string
}
abstract class AccountRequestClass {
    static name: string
}
class AccountRequestPrivate {
    static name: string
}
abstract class AddDispatchOperationContextClass {
    static name: string
}
class AddDispatchOperationContextPrivate {
    static name: string
}
abstract class AutomaticClientFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.AutomaticClientFactoryClass */
    readonly parentClass: SimpleClientFactoryClass
    static name: string
}
abstract class AutomaticProxyFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.AutomaticProxyFactoryClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
class AvatarRequirements {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.AvatarRequirements */
    readonly supportedMimeTypes: string[]
    readonly minimumWidth: number
    readonly minimumHeight: number
    readonly recommendedWidth: number
    readonly recommendedHeight: number
    readonly maximumWidth: number
    readonly maximumHeight: number
    readonly maximumBytes: number
    static name: string
    static new(supportedMimeTypes: string[], minimumWidth: number, minimumHeight: number, recommendedWidth: number, recommendedHeight: number, maximumWidth: number, maximumHeight: number, maximumBytes: number): AvatarRequirements
    constructor(supportedMimeTypes: string[], minimumWidth: number, minimumHeight: number, recommendedWidth: number, recommendedHeight: number, maximumWidth: number, maximumHeight: number, maximumBytes: number)
    /* Static methods and pseudo-constructors */
    static new(supportedMimeTypes: string[], minimumWidth: number, minimumHeight: number, recommendedWidth: number, recommendedHeight: number, maximumWidth: number, maximumHeight: number, maximumBytes: number): AvatarRequirements
}
abstract class BaseClientClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.BaseClientClass */
    readonly parentClass: GObject.ObjectClass
    readonly observeChannels: BaseClientClassObserveChannelsImpl
    readonly addDispatchOperation: BaseClientClassAddDispatchOperationImpl
    readonly handleChannels: BaseClientClassHandleChannelsImpl
    static name: string
}
class BaseClientClassPrivate {
    static name: string
}
class BaseClientPrivate {
    static name: string
}
abstract class BaseConnectionClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.BaseConnectionClass */
    readonly parentClass: GObject.ObjectClass
    readonly getUniqueConnectionName: BaseConnectionGetUniqueConnectionNameImpl
    readonly connecting: BaseConnectionProc
    readonly connected: BaseConnectionProc
    readonly disconnected: BaseConnectionProc
    readonly shutDown: BaseConnectionProc
    readonly startConnecting: BaseConnectionStartConnectingImpl
    static name: string
}
class BaseConnectionPrivate {
    static name: string
}
abstract class BasicProxyFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.BasicProxyFactoryClass */
    readonly parentClass: GObject.ObjectClass
    static name: string
}
abstract class CallChannelClass {
    static name: string
}
class CallChannelPrivate {
    static name: string
}
abstract class CallContentClass {
    static name: string
}
class CallContentPrivate {
    static name: string
}
class CallStateReason {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.CallStateReason */
    readonly actor: Handle
    readonly reason: CallStateChangeReason
    readonly dbusReason: string
    readonly message: string
    static name: string
}
abstract class CallStreamClass {
    static name: string
}
class CallStreamPrivate {
    static name: string
}
abstract class CapabilitiesClass {
    static name: string
}
class CapabilitiesPrivate {
    static name: string
}
abstract class ChannelClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ChannelClass */
    readonly parentClass: ProxyClass
    static name: string
}
abstract class ChannelDispatchOperationClass {
    static name: string
}
class ChannelDispatchOperationClassPrivate {
    static name: string
}
class ChannelDispatchOperationPrivate {
    static name: string
}
abstract class ChannelDispatcherClass {
    static name: string
}
class ChannelDispatcherClassPrivate {
    static name: string
}
class ChannelDispatcherPrivate {
    static name: string
}
class ChannelManagerIter {
    static name: string
}
class ChannelPrivate {
    static name: string
}
abstract class ChannelRequestClass {
    static name: string
}
class ChannelRequestClassPrivate {
    static name: string
}
class ChannelRequestPrivate {
    static name: string
}
abstract class ClientChannelFactoryInterface {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactoryInterface */
    readonly parent: GObject.TypeInterface
    static name: string
}
abstract class ClientMessageClass {
    static name: string
}
abstract class ConnectionClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ConnectionClass */
    readonly parentClass: ProxyClass
    static name: string
}
abstract class ConnectionManagerClass {
    static name: string
}
class ConnectionManagerParam {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ConnectionManagerParam */
    copy(): ConnectionManagerParam
    dupDefaultVariant(): GLib.Variant
    dupVariantType(): GLib.VariantType
    free(): void
    getDbusSignature(): string
    getDefault(value: any): boolean
    getName(): string
    isDbusProperty(): boolean
    isRequired(): boolean
    isRequiredForRegistration(): boolean
    isSecret(): boolean
    static name: string
}
class ConnectionManagerPrivate {
    static name: string
}
class ConnectionManagerProtocol {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ConnectionManagerProtocol */
    readonly name: string
    readonly params: ConnectionManagerParam
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ConnectionManagerProtocol */
    canRegister(): boolean
    copy(): ConnectionManagerProtocol
    dupParamNames(): string[]
    free(): void
    getParam(param: string): ConnectionManagerParam
    hasParam(param: string): boolean
    static name: string
}
class ConnectionPrivate {
    static name: string
}
abstract class ContactClass {
    static name: string
}
class ContactInfoField {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ContactInfoField */
    readonly fieldName: string
    readonly parameters: string[]
    readonly fieldValue: string[]
    static name: string
    static new(fieldName: string, parameters: string[], fieldValue: string[]): ContactInfoField
    constructor(fieldName: string, parameters: string[], fieldValue: string[])
    /* Static methods and pseudo-constructors */
    static new(fieldName: string, parameters: string[], fieldValue: string[]): ContactInfoField
}
class ContactInfoFieldSpec {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ContactInfoFieldSpec */
    readonly name: string
    readonly parameters: string[]
    readonly flags: ContactInfoFieldFlags
    readonly max: number
    static name: string
}
class ContactPrivate {
    static name: string
}
abstract class ContactSearchClass {
    static name: string
}
class ContactSearchPrivate {
    static name: string
}
abstract class ContactSearchResultClass {
    static name: string
}
class ContactSearchResultPrivate {
    static name: string
}
class ContactsMixin {
    static name: string
}
class ContactsMixinClass {
    static name: string
}
class ContactsMixinClassPrivate {
    static name: string
}
class ContactsMixinPrivate {
    static name: string
}
abstract class DBusDaemonClass {
    static name: string
}
class DBusDaemonPrivate {
    static name: string
}
class DBusPropertiesMixinClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinClass */
    readonly interfaces: DBusPropertiesMixinIfaceImpl
    static name: string
    /* Static methods and pseudo-constructors */
    static init(cls: GObject.ObjectClass, offset: number): void
}
class DBusPropertiesMixinIfaceImpl {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinIfaceImpl */
    readonly name: string
    readonly getter: DBusPropertiesMixinGetter
    readonly setter: DBusPropertiesMixinSetter
    readonly props: DBusPropertiesMixinPropImpl
    static name: string
}
class DBusPropertiesMixinIfaceInfo {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinIfaceInfo */
    readonly dbusInterface: GLib.Quark
    readonly props: DBusPropertiesMixinPropInfo
    static name: string
}
class DBusPropertiesMixinPropImpl {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinPropImpl */
    readonly name: string
    readonly getterData: object
    readonly setterData: object
    static name: string
}
class DBusPropertiesMixinPropInfo {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinPropInfo */
    readonly name: GLib.Quark
    readonly flags: DBusPropertiesMixinFlags
    readonly dbusSignature: string
    readonly type: GObject.Type
    static name: string
}
abstract class DBusTubeChannelClass {
    static name: string
}
class DBusTubeChannelPrivate {
    static name: string
}
abstract class DebugClientClass {
    static name: string
}
class DebugClientPrivate {
    static name: string
}
abstract class DebugMessageClass {
    static name: string
}
class DebugMessagePriv {
    static name: string
}
abstract class FileTransferChannelClass {
    static name: string
}
class FileTransferChannelPrivate {
    static name: string
}
class GroupMixin {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.GroupMixin */
    readonly handleRepo: HandleRepoIface
    readonly selfHandle: Handle
    readonly groupFlags: ChannelGroupFlags
    readonly members: HandleSet
    readonly localPending: HandleSet
    readonly remotePending: HandleSet
    readonly priv: GroupMixinPrivate
    static name: string
}
class GroupMixinClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.GroupMixinClass */
    readonly addMember: GroupMixinAddMemberFunc
    readonly removeMember: GroupMixinRemMemberFunc
    readonly priv: GroupMixinClassPrivate
    static name: string
}
class GroupMixinClassPrivate {
    static name: string
}
class GroupMixinPrivate {
    static name: string
}
abstract class HandleChannelsContextClass {
    static name: string
}
class HandleChannelsContextPrivate {
    static name: string
}
class HandleRepoIfaceClass {
    static name: string
}
class HandleSet {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.HandleSet */
    dump(): string
    toIdentifierMap(): GLib.HashTable
    static name: string
}
class Intset {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Intset */
    add(element: number): void
    clear(): void
    copy(): Intset
    destroy(): void
    difference(right: Intset): Intset
    differenceUpdate(other: Intset): void
    dump(): string
    foreach(func: IntFunc): void
    intersection(right: Intset): Intset
    isEmpty(): boolean
    isEqual(right: Intset): boolean
    isMember(element: number): boolean
    remove(element: number): boolean
    size(): number
    symmetricDifference(right: Intset): Intset
    toArray(): number[]
    union(right: Intset): Intset
    unionUpdate(other: Intset): void
    static name: string
    static new(): Intset
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): Intset
    static newContaining(element: number): Intset
    static sizedNew(size: number): Intset
    static fromArray(array: number[]): Intset
}
class IntsetFastIter {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.IntsetFastIter */
    init(set: Intset): void
    next(output: number): boolean
    static name: string
}
class IntsetIter {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.IntsetIter */
    readonly set: Intset
    readonly element: number
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.IntsetIter */
    init(set: Intset): void
    next(): boolean
    reset(): void
    static name: string
}
abstract class MessageClass {
    static name: string
}
abstract class ObserveChannelsContextClass {
    static name: string
}
class ObserveChannelsContextPrivate {
    static name: string
}
class PresenceMixin {
    static name: string
}
class PresenceMixinClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceMixinClass */
    readonly statusAvailable: PresenceMixinStatusAvailableFunc
    readonly setOwnStatus: PresenceMixinSetOwnStatusFunc
    readonly statuses: PresenceStatusSpec
    readonly getMaximumStatusMessageLength: PresenceMixinGetMaximumStatusMessageLengthFunc
    static name: string
}
class PresenceMixinClassPrivate {
    static name: string
}
class PresenceMixinPrivate {
    static name: string
}
class PresenceStatus {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceStatus */
    readonly index: number
    readonly optionalArguments: GLib.HashTable
    static name: string
}
class PresenceStatusOptionalArgumentSpec {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceStatusOptionalArgumentSpec */
    readonly name: string
    readonly dtype: string
    static name: string
}
class PresenceStatusSpec {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceStatusSpec */
    readonly name: string
    readonly presenceType: ConnectionPresenceType
    readonly self: boolean
    readonly optionalArguments: PresenceStatusOptionalArgumentSpec
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.PresenceStatusSpec */
    canSetOnSelf(): boolean
    copy(): PresenceStatusSpec
    free(): void
    getName(): string
    getPresenceType(): ConnectionPresenceType
    hasMessage(): boolean
    static name: string
    static new(name: string, type: ConnectionPresenceType, canSetOnSelf: boolean, hasMessage: boolean): PresenceStatusSpec
    constructor(name: string, type: ConnectionPresenceType, canSetOnSelf: boolean, hasMessage: boolean)
    /* Static methods and pseudo-constructors */
    static new(name: string, type: ConnectionPresenceType, canSetOnSelf: boolean, hasMessage: boolean): PresenceStatusSpec
}
class PresenceStatusSpecPrivate {
    static name: string
}
abstract class ProtocolClass {
    static name: string
}
class ProtocolClassPrivate {
    static name: string
}
class ProtocolPrivate {
    static name: string
}
abstract class ProxyClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ProxyClass */
    readonly parentClass: GObject.ObjectClass
    readonly interface: GLib.Quark
    readonly mustHaveUniqueName: number
    static name: string
}
class ProxyFeature {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ProxyFeature */
    readonly name: GLib.Quark
    readonly core: boolean
    readonly prepareAsync: ProxyPrepareAsync
    readonly prepareBeforeSignallingConnectedAsync: ProxyPrepareAsync
    readonly interfacesNeeded: GLib.Quark
    readonly dependsOn: GLib.Quark
    readonly canRetry: boolean
    static name: string
}
class ProxyFeaturePrivate {
    static name: string
}
class ProxyPendingCall {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ProxyPendingCall */
    cancel(): void
    static name: string
}
class ProxyPrivate {
    static name: string
}
class ProxySignalConnection {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ProxySignalConnection */
    disconnect(): void
    static name: string
}
abstract class RoomInfoClass {
    static name: string
}
class RoomInfoPriv {
    static name: string
}
abstract class RoomListClass {
    static name: string
}
class RoomListPrivate {
    static name: string
}
abstract class SignalledMessageClass {
    static name: string
}
abstract class SimpleApproverClass {
    static name: string
}
class SimpleApproverPrivate {
    static name: string
}
abstract class SimpleClientFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.SimpleClientFactoryClass */
    readonly parentClass: GObject.ObjectClass
    readonly dupAccountFeatures: (self: SimpleClientFactory, account: Account) => GLib.Quark[]
    readonly dupConnectionFeatures: (self: SimpleClientFactory, connection: Connection) => GLib.Quark[]
    readonly dupChannelFeatures: (self: SimpleClientFactory, channel: Channel) => GLib.Quark[]
    readonly dupContactFeatures: (self: SimpleClientFactory, connection: Connection) => ContactFeature[]
    static name: string
}
class SimpleClientFactoryPrivate {
    static name: string
}
abstract class SimpleHandlerClass {
    static name: string
}
class SimpleHandlerPrivate {
    static name: string
}
abstract class SimpleObserverClass {
    static name: string
}
class SimpleObserverPrivate {
    static name: string
}
abstract class StreamTubeChannelClass {
    static name: string
}
class StreamTubeChannelPrivate {
    static name: string
}
abstract class StreamTubeConnectionClass {
    static name: string
}
class StreamTubeConnectionPrivate {
    static name: string
}
abstract class TLSCertificateClass {
    static name: string
}
class TLSCertificateClassPrivate {
    static name: string
}
class TLSCertificatePrivate {
    static name: string
}
abstract class TLSCertificateRejectionClass {
    static name: string
}
class TLSCertificateRejectionPriv {
    static name: string
}
abstract class TextChannelClass {
    static name: string
}
class TextChannelPrivate {
    static name: string
}
class WeakRef {
    static name: string
}
    type Handle = number
}
export default TelepathyGLib;