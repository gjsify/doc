/* gxml-0.4.vapi generated by valac 0.26.0.7-2832-dirty, do not modify. */

[CCode (gir_namespace = "GXml", gir_version = "0.4")]
namespace GXml {
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Attr : GXml.BackedNode {
		public override bool copy (ref GXml.Node node, bool deep = false);
		public override string to_string (bool format = false, int level = 0);
		public override GXml.NodeList? child_nodes { owned get; internal set; }
		public string name { get; private set; }
		public override GXml.Node? next_sibling { get; internal set; }
		public override string? node_value { get; internal set; }
		public override GXml.Node? parent_node { get; internal set; }
		public override GXml.Node? previous_sibling { get; internal set; }
		public bool specified { get; private set; }
		public string value { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class BackedNode : GXml.Node {
		public override GXml.NamespaceAttr? add_namespace_attr (string uri, string prefix);
		public override unowned GXml.Node? append_child (GXml.Node new_child);
		public override unowned GXml.Node? clone_node (bool deep);
		public override bool has_child_nodes ();
		public override unowned GXml.Node? insert_before (GXml.Node new_child, GXml.Node? ref_child);
		public override unowned GXml.Node? remove_child (GXml.Node old_child);
		public override unowned GXml.Node? replace_child (GXml.Node new_child, GXml.Node old_child);
		public override string to_string (bool format = true, int level = 0);
		public override GXml.NodeList? child_nodes { owned get; internal set; }
		public override GXml.Node? first_child { get; internal set; }
		public override GXml.Node? last_child { get; internal set; }
		public override string? local_name { get; internal set; }
		public override GXml.NodeList? namespace_definitions { get; internal set; }
		public override string? namespace_uri { get; internal set; }
		public override GXml.Node? next_sibling { get; internal set; }
		public override string node_name { get; internal set; }
		public override GXml.NodeType node_type { get; internal set; }
		public override string? node_value { get; internal set; }
		public override GXml.Node? parent_node { get; internal set; }
		public override string? prefix { get; internal set; }
		public override GXml.Node? previous_sibling { get; internal set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CDATASection : GXml.Text {
		public override string node_name { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CharacterData : GXml.BackedNode {
		public void append_data (string new_segment);
		public void delete_data (ulong offset, ulong count);
		public void insert_data (ulong offset, string new_segment);
		public void replace_data (ulong offset, ulong count, string new_segment);
		public string substring_data (ulong offset, ulong count);
		public string data { get; set; }
		public ulong length { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Comment : GXml.CharacterData {
		public override string node_name { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Document : GXml.Node {
		public Document ();
		public override unowned GXml.Node? append_child (GXml.Node new_child);
		public unowned GXml.Node copy_node (GXml.Node foreign_node, bool deep = true);
		public GXml.Attr create_attribute (string name);
		public unowned GXml.CDATASection create_cdata_section (string cdata_data);
		public unowned GXml.Comment create_comment (string comment_data);
		public unowned GXml.DocumentFragment create_document_fragment ();
		public unowned GXml.Element create_element (string tag_name);
		public GXml.EntityReference create_entity_reference (string name);
		public GXml.ProcessingInstruction create_processing_instruction (string target, string data);
		public unowned GXml.Text create_text_node (string text_data);
		public Document.from_gfile (GLib.File fin, GLib.Cancellable? can = null) throws GXml.Error, GLib.Error;
		public Document.from_libxml2 (Xml.Doc* doc, bool require_root = true);
		public Document.from_path (string file_path) throws GXml.Error;
		public Document.from_stream (GLib.InputStream instream, GLib.Cancellable? can = null) throws GXml.Error;
		public Document.from_string (string xml);
		public Document.from_string_with_options (string xml, string? url = null, string? encoding = null, int options = 0);
		public GXml.NodeList get_elements_by_tag_name (string tag_name);
		public override bool has_child_nodes ();
		public override unowned GXml.Node? insert_before (GXml.Node new_child, GXml.Node? ref_child);
		public override unowned GXml.Node? remove_child (GXml.Node old_child);
		public override unowned GXml.Node? replace_child (GXml.Node new_child, GXml.Node old_child);
		public void save_to_path (string file_path) throws GXml.Error;
		public void save_to_stream (GLib.OutputStream outstream, GLib.Cancellable? can = null) throws GXml.Error;
		public override string to_string (bool format = true, int level = 0);
		public override GXml.NodeList? child_nodes { owned get; internal set; }
		public GXml.DocumentType? doctype { get; private set; }
		public GXml.Element document_element { get; private set; }
		public GXml.Implementation implementation { get; private set; }
		public override string node_name { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DocumentFragment : GXml.BackedNode {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DocumentType : GXml.Node {
		public GLib.HashTable<string,GXml.Entity>? entities { get; private set; }
		public string name { get; private set; }
		public GLib.HashTable<string,GXml.Notation>? notations { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Element : GXml.BackedNode {
		public override unowned GXml.Node? append_child (GXml.Node new_child);
		public override bool copy (ref GXml.Node node, bool deep = false);
		public string get_attribute (string name);
		public GXml.Attr? get_attribute_node (string name);
		public GXml.NodeList get_elements_by_tag_name (string tag_name);
		public override unowned GXml.Node? insert_before (GXml.Node new_child, GXml.Node? ref_child);
		public void normalize ();
		public void remove_attribute (string name);
		public GXml.Attr remove_attribute_node (GXml.Attr old_attr);
		public override unowned GXml.Node? remove_child (GXml.Node old_child);
		public override unowned GXml.Node? replace_child (GXml.Node new_child, GXml.Node old_child);
		public void set_attribute (string name, string value);
		public GXml.Attr set_attribute_node (GXml.Attr new_attr);
		public override string to_string (bool format = false, int level = 0);
		public override GXml.NamedAttrMap? attributes { get; internal set; }
		public string content { owned get; set; }
		public override string? node_value { get; private set; }
		public string tag_name { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Entity : GXml.Node {
		public override unowned GXml.Node? append_child (GXml.Node new_child);
		public override unowned GXml.Node? clone_node (bool deep);
		public override bool has_child_nodes ();
		public override unowned GXml.Node? insert_before (GXml.Node new_child, GXml.Node? ref_child);
		public override unowned GXml.Node? remove_child (GXml.Node old_child);
		public override unowned GXml.Node? replace_child (GXml.Node new_child, GXml.Node old_child);
		public override GXml.NodeList? child_nodes { owned get; internal set; }
		public override string node_name { get; internal set; }
		public string notation_name { get; private set; }
		public override GXml.Node? parent_node { get; internal set; }
		public string public_id { get; private set; }
		public string system_id { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class EntityReference : GXml.Node {
		public override string node_name { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Enumeration {
		public Enumeration ();
		public static string get_nick (GLib.Type enumeration, int val) throws GLib.Error;
		public static string get_nick_camelcase (GLib.Type enumeration, int val) throws GLib.Error;
		public static string get_string (GLib.Type enumeration, int val, bool use_nick = false, bool camelcase = false) throws GLib.Error;
		public static GLib.EnumValue? parse (GLib.Type enumeration, string val) throws GLib.Error;
		public static unowned GLib.EnumValue[] to_array (GLib.Type enumeration);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Implementation : GLib.Object {
		public GXml.Document create_document (string? namespace_uri, string? qualified_name, GXml.DocumentType? doctype);
		public bool has_feature (string feature, string? version = null);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NamedAttrMap : GLib.Object, GXml.NamedNodeMap<GXml.Attr?> {
		public Gee.Collection<GXml.Attr> get_values ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NamespaceAttr : GXml.Node {
		public string defined_namespace_uri { get; internal set; }
		public string defined_prefix { get; internal set; }
		public override string? local_name { get; internal set; }
		public override string? namespace_uri { get; internal set; }
		public override string node_name { get; internal set; }
		public override string? node_value { get; internal set; }
		public override string? prefix { get; internal set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Node : GLib.Object {
		public virtual GXml.NamespaceAttr? add_namespace_attr (string uri, string prefix);
		public virtual unowned GXml.Node? append_child (GXml.Node new_child);
		public virtual unowned GXml.Node? clone_node (bool deep);
		public virtual bool copy (ref GXml.Node node, bool deep = false);
		public virtual bool has_child_nodes ();
		public virtual unowned GXml.Node? insert_before (GXml.Node new_child, GXml.Node? ref_child);
		public virtual unowned GXml.Node? remove_child (GXml.Node old_child);
		public virtual unowned GXml.Node? replace_child (GXml.Node new_child, GXml.Node old_child);
		public virtual string to_string (bool format = false, int level = 0);
		public virtual GXml.NamedAttrMap? attributes { get; internal set; }
		public virtual GXml.NodeList? child_nodes { owned get; internal set; }
		public virtual GXml.Node? first_child { get; internal set; }
		public virtual GXml.Node? last_child { get; internal set; }
		public virtual string? local_name { get; internal set; }
		public virtual GXml.NodeList? namespace_definitions { get; internal set; }
		public virtual string? namespace_uri { get; internal set; }
		public virtual GXml.Node? next_sibling { get; internal set; }
		public virtual string node_name { get; internal set; }
		public virtual GXml.NodeType node_type { get; internal set; }
		public virtual string? node_value { get; internal set; }
		public GXml.Document owner_document { get; internal set; }
		public virtual GXml.Node? parent_node { get; internal set; }
		public virtual string? prefix { get; internal set; }
		public virtual GXml.Node? previous_sibling { get; internal set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Notation : GXml.Node {
		public override string node_name { get; private set; }
		public string? public_id { get; private set; }
		public string? system_id { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class ProcessingInstruction : GXml.Node {
		public string data { get; set; }
		public override string node_name { get; private set; }
		public override string? node_value { get; private set; }
		public string target { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableArrayList<G> : Gee.ArrayList<G>, GXml.Serializable, GXml.SerializableCollection {
		public SerializableArrayList ();
		public GXml.Node? default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual GXml.Node? deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual void get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public virtual void init_properties ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual void set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public virtual bool transform_from_string (string str, ref GLib.Value dest);
		public virtual bool transform_to_string (GLib.Value val, ref string str);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class SerializableContainer : GXml.SerializableObjectModel {
		public SerializableContainer ();
		public abstract void init_containers ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableDualKeyMap<P,S,V> : GLib.Object, GXml.Serializable, GXml.SerializableCollection {
		protected Gee.HashMultiMap<P,Gee.HashMap<S,V>> storage;
		public SerializableDualKeyMap ();
		public GXml.Node? default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual GXml.Node? deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public new V @get (P primary_key, S secondary_key);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual void get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public virtual void init_properties ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public Gee.Collection<S> secondary_keys (P key);
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public new void @set (P primary_key, S secundary_key, V val);
		public virtual void set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public virtual bool transform_from_string (string str, ref GLib.Value dest);
		public virtual bool transform_to_string (GLib.Value val, ref string str);
		public Gee.Collection<V> values ();
		public Gee.Collection<V> values_for_key (P primary_key);
		public GLib.Type primary_key_type { get; }
		public Gee.Collection<P> primary_keys { owned get; }
		public GLib.Type secondary_key_type { get; }
		public int size { get; }
		public GLib.Type value_type { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableHashMap<K,V> : Gee.HashMap<K,V>, GXml.Serializable, GXml.SerializableCollection {
		public SerializableHashMap ();
		public GXml.Node? default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual GXml.Node? deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual void get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public virtual void init_properties ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual void set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public virtual bool transform_from_string (string str, ref GLib.Value dest);
		public virtual bool transform_to_string (GLib.Value val, ref string str);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableJson : GLib.Object, GXml.Serializable {
		public SerializableJson ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual void get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public virtual void init_properties ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual void set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public virtual bool transform_from_string (string str, ref GLib.Value dest) throws GLib.Error;
		public virtual bool transform_to_string (GLib.Value val, ref string str) throws GLib.Error;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class SerializableObjectModel : GLib.Object, GXml.Serializable {
		public SerializableObjectModel ();
		public GXml.Node? default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public string default_node_name ();
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual GXml.Node? deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public static bool equals (GXml.SerializableObjectModel a, GXml.SerializableObjectModel b);
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual void get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public virtual void init_properties ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual void set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public abstract string to_string ();
		public virtual bool transform_from_string (string str, ref GLib.Value dest) throws GLib.Error;
		public virtual bool transform_to_string (GLib.Value val, ref string str) throws GLib.Error;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableTreeMap<K,V> : Gee.TreeMap<K,V>, GXml.Serializable, GXml.SerializableCollection {
		public SerializableTreeMap ();
		public GXml.Node? default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual GXml.Node? deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual void get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public virtual void init_properties ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual void set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public virtual bool transform_from_string (string str, ref GLib.Value dest);
		public virtual bool transform_to_string (GLib.Value val, ref string str);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Serialization : GLib.Object {
		public Serialization ();
		public static void clear_cache ();
		public static GLib.Object deserialize_object (GLib.Type type, GXml.Document doc) throws GLib.Error;
		public static GXml.Document serialize_object (GLib.Object object) throws GLib.Error;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Text : GXml.CharacterData {
		public GXml.Text split_text (ulong offset);
		public override string node_name { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface NamedNodeMap<T> : GLib.Object {
		public abstract T get_named_item (string name);
		public abstract T item (ulong index);
		public abstract T remove_named_item (string name);
		public abstract T set_named_item (T item);
		public abstract ulong length { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface NodeList : GLib.Object, Gee.Iterable<GXml.Node>, Gee.Collection<GXml.Node> {
		public abstract unowned GXml.Node? append_child (GXml.Node new_child);
		public abstract GXml.Node first ();
		public abstract new GXml.Node @get (int n);
		public abstract unowned GXml.Node? insert_before (GXml.Node new_child, GXml.Node? ref_child);
		public abstract GXml.Node item (ulong idx);
		public abstract GXml.Node last ();
		public abstract unowned GXml.Node? remove_child (GXml.Node old_child);
		public abstract unowned GXml.Node? replace_child (GXml.Node new_child, GXml.Node old_child);
		public abstract string to_string (bool in_line);
		public abstract ulong length { get; private set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Serializable : GLib.Object {
		public virtual GLib.ParamSpec? default_find_property_spec (string property_name);
		public virtual void default_get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public virtual void default_init_properties ();
		public virtual GLib.ParamSpec[] default_list_serializable_properties ();
		public virtual void default_set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public abstract GXml.Node? deserialize (GXml.Node node) throws GLib.Error;
		public abstract bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public abstract GLib.ParamSpec? find_property_spec (string property_name);
		public abstract bool get_enable_unknown_serializable_property ();
		public abstract void get_property_value (GLib.ParamSpec spec, ref GLib.Value val);
		public static string gvalue_to_string (GLib.Value val) throws GXml.SerializableError;
		public abstract void init_properties ();
		public abstract GLib.ParamSpec[] list_serializable_properties ();
		public abstract string node_name ();
		public abstract bool property_use_nick ();
		public abstract GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public abstract GXml.Node? serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public abstract bool serialize_use_xml_node_value ();
		public abstract void set_property_value (GLib.ParamSpec spec, GLib.Value val);
		public static bool string_to_gvalue (string str, ref GLib.Value dest) throws GXml.SerializableError;
		public abstract bool transform_from_string (string str, ref GLib.Value dest) throws GLib.Error;
		public abstract bool transform_to_string (GLib.Value val, ref string str) throws GLib.Error;
		public abstract GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected abstract GLib.ParamSpec[] properties { get; set; }
		public abstract string? serialized_xml_node_value { get; protected set; }
		public abstract GLib.HashTable<string,GXml.Node> unknown_serializable_property { get; protected set; }
		public signal void deserialize_unknown_property (GXml.Node node, GLib.ParamSpec prop);
		public signal void deserialize_unknown_property_type (GXml.Node node, GLib.ParamSpec prop);
		public signal void serialize_unknown_property (GXml.Node element, GLib.ParamSpec prop, out GXml.Node node);
		public signal void serialize_unknown_property_type (GXml.Node element, GLib.ParamSpec prop, out GXml.Node node);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableCollection : GLib.Object, GXml.Serializable {
		public virtual bool is_collection ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableMapDualKey<P,S> : GLib.Object {
		public abstract P get_map_primary_key ();
		public abstract S get_map_secondary_key ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableMapKey<K> : GLib.Object {
		public abstract K get_map_key ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum DomException {
		NONE,
		INDEX_SIZE,
		DOMSTRING_SIZE,
		HIERARCHY_REQUEST,
		WRONG_DOCUMENT,
		INVALID_CHARACTER,
		NO_DATA_ALLOWED,
		NO_MODIFICATION_ALLOWED,
		NOT_FOUND,
		NOT_SUPPORTED,
		INUSE_ATTRIBUTE,
		DOM,
		INVALID_DOC,
		INVALID_ROOT,
		NAMESPACE,
		X_OTHER
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum NodeType {
		X_UNKNOWN,
		ELEMENT,
		ATTRIBUTE,
		TEXT,
		CDATA_SECTION,
		ENTITY_REFERENCE,
		ENTITY,
		PROCESSING_INSTRUCTION,
		COMMENT,
		DOCUMENT,
		DOCUMENT_TYPE,
		DOCUMENT_FRAGMENT,
		NOTATION
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain EnumerationError {
		INVALID_VALUE,
		INVALID_TEXT
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain Error {
		NOT_SUPPORTED,
		PARSER,
		WRITER
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain SerializableError {
		UNSUPPORTED_TYPE_ERROR,
		STR_TO_VALUE_ERROR
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain SerializationError {
		UNKNOWN_TYPE,
		UNKNOWN_PROPERTY,
		UNSUPPORTED_OBJECT_TYPE,
		UNSUPPORTED_PROPERTY_TYPE,
		UNSUPPORTED_TYPE,
		UNSUPPORTED_FILE_FORMAT
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public static GXml.DomException last_error;
	[CCode (cheader_filename = "gxml/gxml.h")]
	public static void warning (GXml.DomException exception, string message);
}
