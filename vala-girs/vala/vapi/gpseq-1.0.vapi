/* gpseq-1.0.vapi generated by valac 0.48.2.127-d906, do not modify. */

namespace Gpseq {
	/**
	 * Various collector implementations.
	 */
	namespace Collectors {
		/**
		 * Returns a collector that produces the arithmetic mean of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<double?,GLib.Object,G> average_double<G> (owned Gpseq.MapFunc<double?,G> mapper);
		/**
		 * Returns a collector that produces the arithmetic mean of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<float?,GLib.Object,G> average_float<G> (owned Gpseq.MapFunc<float?,G> mapper);
		/**
		 * Returns a collector that counts the number of elements.
		 *
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<int64?,GLib.Object,G> count<G> ();
		/**
		 * Returns a collector that only accumulates the elements matching the
		 * given predicate.
		 *
		 * @param pred a predicate function
		 * @param downstream a downstream collector
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<A,GLib.Object,G> filter<A,G> (owned Gpseq.Predicate<G> pred, Gpseq.Collector<A,GLib.Object,G> downstream);
		/**
		 * Returns a collector that performs a reduction operation on the
		 * elements.
		 *
		 * @param accumulator an accumulate function
		 * @param combiner a combine function
		 * @param identity an identity value
		 * @return the collector implementation
		 * @see Seq.fold
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<A,GLib.Object,G> fold<A,G> (owned Gpseq.FoldFunc<A,G> accumulator, owned Gpseq.CombineFunc<A> combiner, A identity);
		/**
		 * Returns a collector that groups the elements based on the
		 * //classifier// function.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the returned map and list.
		 *
		 * @param classifier a classifier function mapping elements to keys
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.Map<K,Gee.List<G>>,GLib.Object,G> group_by<K,G> (owned Gpseq.MapFunc<K,G> classifier);
		/**
		 * Returns a collector that groups the elements based on the
		 * //classifier// function, and performs a reduction operation on the
		 * values of each key using the //downstream// collector.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the returned map.
		 *
		 * @param classifier a classifier function mapping elements to keys
		 * @param downstream a downstream collector
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.Map<K,V>,GLib.Object,G> group_by_with<K,V,G> (owned Gpseq.MapFunc<K,G> classifier, Gpseq.Collector<V,GLib.Object,G> downstream);
		/**
		 * Returns a collector that concatenates the elements into a string, in
		 * encounter order.
		 *
		 * @param delimiter a delimiter
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<string,GLib.Object,string> join (owned string delimiter = "");
		/**
		 * Returns a collector that applies the given mapper function to the
		 * elements, and performs a reduction operation on the results using
		 * the //downstream// collector.
		 *
		 * @param mapper a mapper function
		 * @param downstream a downstream collector
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<R,GLib.Object,G> map<R,A,G> (owned Gpseq.MapFunc<A,G> mapper, Gpseq.Collector<R,GLib.Object,A> downstream);
		/**
		 * Returns a collector that produces the maximum element based on the
		 * given compare function.
		 *
		 * @param compare a compare function. if not specified,
		 * {@link Gee.Functions.get_compare_func_for} is used to get a proper
		 * function.
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gpseq.Optional<G>,GLib.Object,G> max<G> (owned GLib.CompareDataFunc<G>? compare = null);
		/**
		 * Returns a collector that produces the minimum element based on the
		 * given compare function.
		 *
		 * @param compare a compare function. if not specified,
		 * {@link Gee.Functions.get_compare_func_for} is used to get a proper
		 * function.
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gpseq.Optional<G>,GLib.Object,G> min<G> (owned GLib.CompareDataFunc<G>? compare = null);
		/**
		 * Returns a collector that partitions the elements based on the
		 * //pred// function.
		 *
		 * The result map always contains lists for both true and false keys.
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the returned map and list.
		 *
		 * @param pred a predicate function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.Map<bool,Gee.List<G>>,GLib.Object,G> partition<G> (owned Gpseq.Predicate<G> pred);
		/**
		 * Returns a collector that partitions the elements based on the
		 * //pred// function, and performs a reduction operation on the
		 * values of each partition using the //downstream// collector.
		 *
		 * The result map always contains mappings for both true and false keys.
		 * If a partition has no elements, its value will be obtained from the
		 * //downstream.create_accumulator// and the //downstream.finish//
		 * function applied.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the returned map.
		 *
		 * @param pred a predicate function
		 * @param downstream a downstream collector
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.Map<bool,V>,GLib.Object,G> partition_with<V,G> (owned Gpseq.Predicate<G> pred, Gpseq.Collector<V,GLib.Object,G> downstream);
		/**
		 * Returns a collector that performs a reduction operation on the
		 * elements.
		 *
		 * @param accumulator an accumulate function
		 * @return the collector implementation
		 * @see Seq.reduce
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gpseq.Optional<G>,GLib.Object,G> reduce<G> (owned Gpseq.CombineFunc<G> accumulator);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The result can vary because of accumulated rounding error.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<double?,GLib.Object,G> sum_double<G> (owned Gpseq.MapFunc<double?,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The result can vary because of accumulated rounding error.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<float?,GLib.Object,G> sum_float<G> (owned Gpseq.MapFunc<float?,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * The arithmetic wraps around on overflow;
		 * e.g. //the sum of int.MAX and 1 => int.MIN//
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<int,GLib.Object,G> sum_int<G> (owned Gpseq.MapFunc<int,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * The arithmetic wraps around on overflow;
		 * e.g. //the sum of int32.MAX and 1 => int32.MIN//
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<int32,GLib.Object,G> sum_int32<G> (owned Gpseq.MapFunc<int32,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * The arithmetic wraps around on overflow;
		 * e.g. //the sum of int64.MAX and 1 => int64.MIN//
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<int64?,GLib.Object,G> sum_int64<G> (owned Gpseq.MapFunc<int64?,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * The arithmetic wraps around on overflow;
		 * e.g. //the sum of long.MAX and 1 => long.MIN//
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<long,GLib.Object,G> sum_long<G> (owned Gpseq.MapFunc<long,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<uint,GLib.Object,G> sum_uint<G> (owned Gpseq.MapFunc<uint,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<uint32,GLib.Object,G> sum_uint32<G> (owned Gpseq.MapFunc<uint32,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<uint64?,GLib.Object,G> sum_uint64<G> (owned Gpseq.MapFunc<uint64?,G> mapper);
		/**
		 * Returns a collector that produces the sum of the given function
		 * applied to the elements. If there are no elements, the result is 0.
		 *
		 * The //mapper// function must not return null.
		 *
		 * @param mapper a mapping function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<ulong,GLib.Object,G> sum_ulong<G> (owned Gpseq.MapFunc<ulong,G> mapper);
		/**
		 * Returns a collector that consists of multiple downstream collectors.
		 * The elements are processed by all the downstream collectors, and
		 * then their results are merged using the //merger// function into the
		 * final result.
		 *
		 * The {@link Collector.features} of the returned collector is
		 * intersection of the downstream collectors' features.
		 *
		 * @param downstreams an array of the downstream collectors -- must
		 * have at least one collector
		 * @param merger the merge function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<A,GLib.Object,G> tee<A,G> (owned Gpseq.Collector<GLib.Object,GLib.Object,G>[] downstreams, owned Gpseq.TeeMergeFunc<A> merger);
		/**
		 * Returns a collector that accumulates the elements into a new
		 * collection, in encounter order.
		 *
		 * @param factory a supplier which supplies a new empty collection
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.Collection<G>,GLib.Object,G> to_collection<G> (Gpseq.Supplier<Gee.Collection<G>> factory);
		/**
		 * Returns a collector that accumulates the elements into a new generic
		 * array, in encounter order.
		 *
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<GLib.GenericArray<G>,GLib.Object,G> to_generic_array<G> ();
		/**
		 * Returns a collector that accumulates the elements into a new list,
		 * in encounter order.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the list.
		 *
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.List<G>,GLib.Object,G> to_list<G> ();
		/**
		 * Returns a collector that accumulates the elements into a new map.
		 *
		 * If there are key duplications, the values are merged using the
		 * //merger// function, or throws a {@link MapError.DUPLICATE_KEY} if
		 * the function is not specified.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the map.
		 *
		 * @param key_mapper a mapping function for keys
		 * @param val_mapper a mapping function for values
		 * @param merger a function used to resolve key collisions. if not
		 * specified, //(a, b) => { throw new MapError.DUPLICATE_KEY(...); }//
		 * is used.
		 * @param key_hash a hash function for keys. if not specified,
		 * {@link Gee.Functions.get_hash_func_for} is used to get a proper
		 * function
		 * @param key_equal an equal function for keys. if not specified,
		 * {@link Gee.Functions.get_equal_func_for} is used to get a proper
		 * function
		 * @param value_equal an equal function for values. if not specified,
		 * {@link Gee.Functions.get_equal_func_for} is used to get a proper
		 * function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.Map<K,V>,GLib.Object,G> to_map<K,V,G> (owned Gpseq.MapFunc<K,G> key_mapper, owned Gpseq.MapFunc<V,G> val_mapper, owned Gpseq.CombineFunc<V>? merger = null, owned Gee.HashDataFunc<K>? key_hash = null, owned Gee.EqualDataFunc<K>? key_equal = null, owned Gee.EqualDataFunc<V>? value_equal = null);
		/**
		 * Returns a collector that accumulates the elements into a new set.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the set.
		 *
		 * @param hash a hash function. if not specified,
		 * {@link Gee.Functions.get_hash_func_for} is used to get a proper
		 * function
		 * @param equal an equal function. if not specified,
		 * {@link Gee.Functions.get_equal_func_for} is used to get a proper
		 * function
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gee.Set<G>,GLib.Object,G> to_set<G> (owned Gee.HashDataFunc<G>? hash = null, owned Gee.EqualDataFunc<G>? equal = null);
		/**
		 * Returns a collector wrapping the given collector. The returned
		 * collector will produce a wrapper object containing the result of the
		 * given collector.
		 *
		 * @param collector a collector
		 * @return the collector implementation
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static Gpseq.Collector<Gpseq.Wrapper<A>,GLib.Object,G> wrap<A,G> (Gpseq.Collector<A,GLib.Object,G> collector);
	}
	[Version (since = "0.4.0-alpha")]
	namespace Compares {
		/**
		 * Joins the given two compare functions and returns the combined compare
		 * function.
		 *
		 *  i. It compares using //cmp// first
		 *  i. If both are considered equal, it compares them using //cmp2//.
		 *
		 * @param cmp a compare function
		 * @param cmp2 a compare function
		 * @return the new compare function
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static GLib.CompareDataFunc<G> join<G> (owned GLib.CompareDataFunc<G> cmp, owned GLib.CompareDataFunc<G> cmp2);
		/**
		 * Returns a compare function which is a reversed version of the given
		 * function.
		 *
		 * @param cmp a compare function. if not specified,
		 * {@link Gee.Functions.get_compare_func_for} is used to get a proper
		 * function.
		 * @return the new compare function
		 */
		[CCode (cheader_filename = "gpseq.h")]
		public static GLib.CompareDataFunc<G> reverse<G> (owned GLib.CompareDataFunc<G>? cmp = null);
	}
	namespace Overflow {
		/**
		 * Performs an operation that adds //a// and //b// and returns the result,
		 * with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int32_add")]
		public static bool int32_add (int32 a, int32 b, out int32 result = null);
		/**
		 * Performs an operation that multiplies //a// and //b// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int32_mul")]
		public static bool int32_mul (int32 a, int32 b, out int32 result = null);
		/**
		 * Performs an operation that subtracts //b// from //a// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int32_sub")]
		public static bool int32_sub (int32 a, int32 b, out int32 result = null);
		/**
		 * Performs an operation that adds //a// and //b// and returns the result,
		 * with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int64_add")]
		public static bool int64_add (int64 a, int64 b, out int64 result = null);
		/**
		 * Performs an operation that multiplies //a// and //b// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int64_mul")]
		public static bool int64_mul (int64 a, int64 b, out int64 result = null);
		/**
		 * Performs an operation that subtracts //b// from //a// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int64_sub")]
		public static bool int64_sub (int64 a, int64 b, out int64 result = null);
		/**
		 * Performs an operation that adds //a// and //b// and returns the result,
		 * with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int_add")]
		public static bool int_add (int a, int b, out int result = null);
		/**
		 * Performs an operation that multiplies //a// and //b// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int_mul")]
		public static bool int_mul (int a, int b, out int result = null);
		/**
		 * Performs an operation that subtracts //b// from //a// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_int_sub")]
		public static bool int_sub (int a, int b, out int result = null);
		/**
		 * Performs an operation that adds //a// and //b// and returns the result,
		 * with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_long_add")]
		public static bool long_add (long a, long b, out long result = null);
		/**
		 * Performs an operation that multiplies //a// and //b// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_long_mul")]
		public static bool long_mul (long a, long b, out long result = null);
		/**
		 * Performs an operation that subtracts //b// from //a// and returns the
		 * result, with checking whether the operation overflowed.
		 *
		 * If the operation not overflowed, sets //result// to the result of the
		 * operation and returns false. If the operation overflowed, set //result//
		 * to the operation result wrapped around and returns true.
		 *
		 * @param a an integer
		 * @param b an integer
		 * @param result returns the result of the arithmetic operation
		 * @return true if the operation overflowed, and false otherwise
		 **/
		[CCode (cheader_filename = "gpseq.h", cname = "gpseq_overflow_long_sub")]
		public static bool long_sub (long a, long b, out long result = null);
	}
	/**
	 * A spliterator of an array.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class ArraySpliterator<G> : GLib.Object, Gpseq.Spliterator<G> {
		/**
		 * Creates a new array spliterator.
		 * @param array a gpointer array
		 * @param start zero-based index of the begin
		 * @param stop zero-based index after the end
		 */
		public ArraySpliterator (owned G[] array, int start, int stop);
	}
	/**
	 * A base class for fork-join tasks that run within a worker pool.
	 *
	 * Note. Fork-join tasks are not reusable.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public abstract class ForkJoinTask<G> : GLib.Object, Gpseq.Task<G> {
		public class SharedResult<G> {
			public SharedResult ();
			/**
			 * Sets the value or error to the promise.
			 *
			 * The ownership of the value or error is transferred to the
			 * promise, therefore this result should not be used after this
			 * method called.
			 */
			public void bake_promise (Gpseq.Promise<G> promise);
			public GLib.Error? error { get; owned set; }
			/**
			 * Whether or not this is ready -- the value has been assigned or
			 * an error has been set.
			 */
			public bool ready { get; }
			public G value { get; owned set; }
		}
		/**
		 * Creates a fork-join task.
		 *
		 * @param parent the parent of this task
		 * @param threshold sequential computation threshold
		 * @param max_depth max task split depth. unlimited if negative
		 * @param executor an executor that will invoke the task
		 */
		protected ForkJoinTask (Gpseq.ForkJoinTask<G>? parent, int64 threshold, int max_depth, Gpseq.Executor executor);
		/**
		 * Marks this task as cancelled.
		 */
		protected void cancel ();
		/**
		 * {@inheritDoc}
		 */
		public abstract void compute ();
		/**
		 * Submits this task to the {@link executor}.
		 */
		public void fork ();
		/**
		 * Blocks until this task is done, and returns the task result.
		 * @throws Error an error occurred in the {@link future}
		 */
		public G join () throws GLib.Error;
		/**
		 * The split depth of this task.
		 */
		public int depth { get; set; }
		/**
		 * The executor that will invoke this task
		 */
		public Gpseq.Executor executor { get; }
		/**
		 * Whether or not this task have been cancelled.
		 *
		 * A task is considered cancelled if it or any of its ancestors have
		 * been cancelled.
		 */
		protected bool is_cancelled { get; }
		/**
		 * Whether or not this task is root.
		 */
		public bool is_root { get; }
		/**
		 * The max task split depth. unlimited if negative
		 */
		public int max_depth { get; }
		/**
		 * Gets the parent of this task.
		 */
		public Gpseq.ForkJoinTask<G>? parent { get; }
		/**
		 * The promise to set a result of {@link future}.
		 */
		protected Gpseq.Promise<G> promise { get; }
		/**
		 * Gets the root task.
		 */
		public Gpseq.ForkJoinTask<G> root { get; }
		/**
		 * Gets the shared result.
		 *
		 * All tasks share the same shared result instance with their root task.
		 */
		public Gpseq.ForkJoinTask.SharedResult<G> shared_result { get; }
		/**
		 * The sequential computation threshold.
		 */
		public int64 threshold { get; }
	}
	/**
	 * A function task.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class FuncTask<G> : GLib.Object, Gpseq.Task<G> {
		/**
		 * Creates a new func task.
		 *
		 * @param func a task function
		 */
		public FuncTask (owned Gpseq.TaskFunc<G> func);
	}
	/**
	 * A value which might not yet be available, but will be available at some
	 * point.
	 *
	 * Futures are thread-safe.
	 *
	 * @see Promise
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public abstract class Future<G> : GLib.Object, Gee.Hashable<Gpseq.Result<G>>, Gpseq.Result<G> {
		protected Future ();
		/**
		 * Creates a future completed with the given result.
		 *
		 * @param result a result
		 * @return the future
		 */
		[Version (since = "0.3.0-alpha")]
		public static Gpseq.Future<G> done<G> (Gpseq.Result<G> result);
		/**
		 * Creates a future completed with the given exception.
		 *
		 * @param exception an error
		 * @return the future completed with the given exception
		 */
		[Version (since = "0.2.0-beta")]
		public static Gpseq.Future<G> err<G> (owned GLib.Error exception);
		/**
		 * Creates a future completed with the given value.
		 *
		 * @return the future completed with the given value
		 */
		public static Gpseq.Future<G> of<G> (owned G value);
		/**
		 * Creates a new future by applying the given function to this future,
		 * in future -- when this future is completed.
		 *
		 * The returned object of the function may or may not be directly used.
		 * Depending on the internal implementation, A new future object will
		 * be created with the value or exception of it and returned, instead
		 * of returning it directly.
		 *
		 * If the function returns not a Future but a Result, the result is
		 * mapped to a future.
		 *
		 * @param func a function applied to this result
		 * @return [Future<A>] the new future
		 */
		public abstract Gpseq.Result<A> transform<A> (owned Gpseq.Result.TransformFunc<A,G> func);
		/**
		 * Waits until the future is completed and gets ths result.
		 *
		 * @return the value associated with the future if the future is
		 * completed with a value
		 *
		 * @throws Error if the future is completed with an exception, the
		 * exception will be thrown
		 */
		public abstract unowned G wait () throws GLib.Error;
		/**
		 * Waits until the future is completed or deadline have passed.
		 *
		 * @param end_time the monotonic time to wait until, in microseconds
		 * @param value the value associated with the future if the wait was
		 * successful
		 * @return true if the future was completed within deadline, or false
		 * otherwise
		 *
		 * @throws Error if the future is completed with an exception, the
		 * exception will be thrown
		 */
		public abstract bool wait_until (int64 end_time, out unowned G value = null) throws GLib.Error;
		/**
		 * Whether or not the future had already been completed with a value or
		 * an exception.
		 */
		public abstract bool ready { get; }
	}
	/**
	 * A spliterator of a generic array.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class GenericArraySpliterator<G> : GLib.Object, Gpseq.Spliterator<G> {
		/**
		 * Creates a new generic array spliterator.
		 * @param array a generic array
		 * @param start zero-based index of the begin
		 * @param stop zero-based index after the end
		 */
		public GenericArraySpliterator (GLib.GenericArray<G> array, int start, int stop);
	}
	/**
	 * A spliterator of an iterator.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class IteratorSpliterator<G> : GLib.Object, Gpseq.Spliterator<G> {
		/**
		 * Creates a new iterator spliterator.
		 * @param iterator an iterator
		 * @param estimated_size the estimated size of the iterator, or negative
		 * if infinite, unknown, etc. If the given iterator points at some
		 * element it is included in this size.
		 * @param size_known true if //estimated_size// is an accurate size,
		 * false otherwise.
		 */
		public IteratorSpliterator (Gee.Iterator<G> iterator, int64 estimated_size, bool size_known);
		/**
		 * Creates a new iterator spliterator with the given collection.
		 * @param collection a collection
		 */
		public IteratorSpliterator.from_collection (Gee.Collection<G> collection);
	}
	/**
	 * A spliterator of a list.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class ListSpliterator<G> : GLib.Object, Gpseq.Spliterator<G> {
		/**
		 * Creates a new list spliterator.
		 * @param list a list
		 * @param start zero-based index of the begin
		 * @param stop zero-based index after the end
		 */
		public ListSpliterator (Gee.List<G> list, int start, int stop);
	}
	/**
	 * A container object which may or may not contain a value.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class Optional<G> : GLib.Object {
		public Optional ();
		/**
		 * Creates an empty optional instance.
		 */
		public Optional.empty ();
		/**
		 * If a value is present and matches the given predicate, returns an
		 * optional containing the value, otherwise returns an empty optional.
		 *
		 * @return an optional containing the value if a value is present,
		 * otherwise an empty optional
		 */
		public Gpseq.Optional<G> filter (Gee.Predicate<G> pred);
		/**
		 * If a value is present, performs the given consumer function with the
		 * value.
		 *
		 * @param consumer a function that will be executed if a value is
		 * present
		 */
		public void if_present (GLib.Func<G> consumer);
		/**
		 * If a value is present, performs the mapper function with the value,
		 * and returns the result. Otherwise returns an empty optional.
		 *
		 * The given mapper function must not return null.
		 *
		 * @param mapper a mapper function that will be performed with the value
		 * if a value is present
		 * @return the result of the mapper function if a value is present,
		 * otherwise an empty optional
		 */
		public Gpseq.Optional<A> map<A> (Gee.MapFunc<Gpseq.Optional<A>,G> mapper);
		/**
		 * Creates an optional instance with the given value present.
		 *
		 * @param value the value to be present, which can be null if nullable
		 * type
		 */
		public Optional.of (owned G value);
		/**
		 * If a value is present, returns the value, otherwise returns the given
		 * other.
		 *
		 * @param other other value that will be returned if no value is present
		 * @return the value if present, otherwise the given other.
		 */
		public G or_else (G other);
		/**
		 * If a value is present, returns the value, otherwise fails with
		 * {@link GLib.error}.
		 *
		 * @return the value if present
		 */
		public G or_else_fail ();
		/**
		 * If a value is present, returns the value, otherwise returns the
		 * result produced by the supply function.
		 *
		 * @param supplier the supply function
		 * @return the value if present, otherwise the result produced by the
		 * supply function
		 */
		public G or_else_get (Gpseq.SupplyFunc<G> supplier);
		/**
		 * If a value is present, returns the value, otherwise throws an error
		 * produced by the supply function -- or an
		 * {@link OptionalError.NOT_PRESENT} error if the function is not
		 * specified.
		 *
		 * @param error_supplier the supply function
		 * @return the value if present
		 *
		 * @throws Error an error produced by the supply function if no value
		 * is present
		 */
		public G or_else_throw (Gpseq.SupplyFunc<GLib.Error>? error_supplier = null) throws GLib.Error;
		public string to_string ();
		/**
		 * Whether or not there is a value present.
		 */
		public bool is_present { get; }
		/**
		 * The value held by this optional.
		 *
		 * If a value is present in this optional, returns the value, otherwise
		 * (assertion) fails.
		 */
		public G value { get; }
		/**
		 * The type of the value.
		 */
		public GLib.Type value_type { get; }
	}
	/**
	 * A promise allows to set a value or an exception with an associated
	 * future.
	 *
	 * @see Future
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class Promise<G> {
		public Promise ();
		/**
		 * Sets the exception to the associated future.
		 *
		 * @param exception an exception
		 */
		public void set_exception (owned GLib.Error exception);
		/**
		 * Sets the value to the associated future.
		 *
		 * @param value a value
		 */
		public void set_value (owned G value);
		/**
		 * The future of this promise.
		 */
		public Gpseq.Future<G> future { get; }
	}
	/**
	 * A sequence of elements, supporting sequential and parallel operations.
	 *
	 * == Seq pipelines ==
	 *
	 * There are two kinds of operations in seq; //intermediate// and
	 * //terminal// operations. A seq pipeline consists of zero or more
	 * intermediate operations and a terminal operation.
	 *
	 * === Intermediate operations ===
	 *
	 * Intermediate operations are always //lazy//. It means that traversal of
	 * the source does not begin until a terminal operation is executed. They
	 * return a new seq that will perform the operation, and the operation will
	 * be performed just before a terminal operation is executed. The previous
	 * seq, that has called the intermediate operation method, of the new one
	 * is closed and can no longer be used.
	 *
	 * Intermediate operations are further divided into //stateless// and
	 * //stateful// operations. Stateless operations retain no state from
	 * previously seen element when processing a new element. Therefore, each
	 * element can be processed independently on other elements. Stateful
	 * operations may incorporate state from previously seen elements when
	 * processing new elements, and may need to process the entire input
	 * before producing a result. Consequently, seq pipelines containing
	 * stateful intermediate operations may require multiple passes or may need
	 * to buffer significant data. On the contrary, seq pipelines containing
	 * only stateless intermediate (and terminal) operations can be processed
	 * in a single pass.
	 *
	 * === Terminal operations ===
	 *
	 * Terminal operations may traverse the source to produce a result or a
	 * side-effect. Almost all of terminal operations are //eager//. They
	 * complete their traversal of the input and processing of the pipeline
	 * before the future completed. The only exceptions are {@link Seq.iterator}
	 * and {@link Seq.spliterator}. They are provided for client-controlled
	 * traversals. After a terminal operation is performed, the seq is closed
	 * and can no longer be used.
	 *
	 * === Short-circuiting ===
	 *
	 * Some operations are regarded as //short-circuiting// operations.
	 * A short-circuiting intermediate operation may produce a finite seq as a
	 * result when infinite input given. A short-circuiting terminal operation
	 * may terminate in finite time when infinite input given. For processing
	 * a seq of infinite source to terminate normally in finite time, it is
	 * necessary that the pipeline contains a short-circuiting operation.
	 *
	 * === Parallelism ===
	 *
	 * When the terminal operation is started, the seq pipeline is executed
	 * sequentially or in parallel depending on the mode of the seq on which it
	 * is invoked. The mode is sequential in an initial seq, and can be changed
	 * by {@link Seq.sequential} and {@link Seq.parallel} intermediate
	 * operations.
	 *
	 * All operations respect encounter order in sequential execution. In
	 * parallel execution, however, all stateful intermediate and terminal
	 * operations may not respect the encounter order, except for operations
	 * identified as explicitly ordered such as {@link Seq.find_first}.
	 *
	 * === Non-interference ===
	 *
	 * If a data source, such as list, is used to create a seq, the data source
	 * must not be //interfered// until the execution of the seq pipeline is
	 * completed. It means ensuring that the data source is not modified until
	 * the execution of the seq pipeline is completed. Except for the non-eager
	 * operations iterator() and spliterator(), execution is performed when the
	 * terminal operation is invoked. In case of the non-eager operations, the
	 * data source must not be modified while the iterator/spliterator is used.
	 *
	 * === Stateless ===
	 *
	 * The result of seq pipeline may be nondeterministic or incorrect if the
	 * behaviors to the seq operations are //stateful// -- its result depends on
	 * any state that might change during the execution of the seq pipeline.
	 *
	 * === Associativity ===
	 *
	 * An //associative// operator or function '~' follows:
	 * //(a ~ b) ~ c == a ~ (b ~ c)//
	 *
	 * Numeric addition, numeric multiplication, min, max, and string
	 * concatenation are examples of associative operations.
	 *
	 * == Notes ==
	 *
	 * With nullable primitive types, operations using
	 * {@link GLib.CompareDataFunc} function, such as order_by(), produce an
	 * undesirable result if the compare function is not specified. You should
	 * provide specified compare function to get a proper result.
	 *
	 * Some operation might not work properly with unowned types. The best
	 * approach is never to use unowned types for seq.
	 *
	 * If an operation method is tried after the seq has been closed, the try
	 * is (assertion) failed.
	 *
	 * A result future of a sequential pipeline is already completed when
	 * returned from the terminal operation method, and therefore you do not
	 * have to wait the future for getting the value.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class Seq<G> : GLib.Object {
		/**
		 * Creates a new sequential seq, optionally with a task environment.
		 *
		 * The seq can be changed to parallel mode by {@link Seq.parallel}.
		 *
		 * @param spliterator a spliterator used by the seq
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 */
		public Seq (Gpseq.Spliterator<G> spliterator, Gpseq.TaskEnv? env = null);
		/**
		 * Returns whether or not all elements of this seq match the given
		 * predicate. If the seq is empty, the result is true.
		 *
		 * This is a short-circuiting terminal operation.
		 *
		 * @param pred a //non-interfering// and //stateless// predicate
		 * @return a future of the result -- true if either all elements match
		 * the given predicate or the seq is empty, otherwise false
		 */
		public Gpseq.Future<bool?> all_match (Gpseq.Predicate<G> pred);
		/**
		 * Returns whether or not any elements of this seq match the given
		 * predicate. If the seq is empty, the result is false.
		 *
		 * This is a short-circuiting terminal operation.
		 *
		 * @param pred a //non-interfering// and //stateless// predicate
		 * @return a future of the result -- true if any elements match the
		 * given predicate, otherwise false
		 */
		public Gpseq.Future<bool?> any_match (Gpseq.Predicate<G> pred);
		/**
		 * Returns a seq which contains the remaining elements of this seq after
		 * discarding the first //n// elements, truncated to be no longer than
		 * //n// in length.
		 *
		 * On parallel execution, this operation doesn't respect encounter
		 * order.
		 *
		 * This is a stateful intermediate operation, and also short-circuiting
		 * if the given length is not negative.
		 *
		 * @param offset the number of elements to skip
		 * @param length maximum number of elements the seq may contain, or a
		 * negative value if unlimited
		 * @return the new seq
		 */
		public Gpseq.Seq<G> chop (int64 offset, int64 length = -1);
		/**
		 * Returns a seq which contains the remaining elements of this seq after
		 * discarding the first //n// elements, truncated to be no longer than
		 * //n// in length.
		 *
		 * This operation always respects encounter order.
		 *
		 * This is a stateful intermediate operation, and also short-circuiting
		 * if the given length is not negative.
		 *
		 * This operation is quite expensive on parallel execution.
		 * Using {@link chop} instead or switching to sequential execution may
		 * improve performance.
		 *
		 * @param offset the number of elements to skip
		 * @param length maximum number of elements the seq may contain, or a
		 * negative value if unlimited
		 * @return the new seq
		 */
		public Gpseq.Seq<G> chop_ordered (int64 offset, int64 length = -1);
		/**
		 * Closes this seq.
		 *
		 * This method unreferences (i.e. decreases the reference count of) the
		 * internal pipeline source input.
		 *
		 * If this seq has already been closed, this method does nothing.
		 */
		public void close ();
		/**
		 * Performs a mutable reduction operation on the elements of this seq.
		 *
		 * If the seq is in parallel mode and the collector is CONCURRENT,
		 * performs a concurrent reduction.
		 *
		 * This is a terminal operation.
		 *
		 * @param collector the collector describing the reduction
		 * @return a future of the result of the reduction
		 * @see Collector
		 */
		public Gpseq.Future<R> collect<R,A> (Gpseq.Collector<R,A,G> collector);
		/**
		 * Performs a mutable reduction operation on the elements of this seq.
		 *
		 * This operation preserves encounter order even though the seq is in
		 * parallel mode, if the collector is not CONCURRENT or not UNORDERED.
		 * If the seq is in parallel mode and the collector is CONCURRENT and
		 * UNORDERED, performs an unordered concurrent reduction.
		 *
		 * This is a terminal operation.
		 *
		 * @param collector the collector describing the reduction
		 * @return a future of the result of the reduction
		 * @see Collector
		 */
		public Gpseq.Future<R> collect_ordered<R,A> (Gpseq.Collector<R,A,G> collector);
		/**
		 * Returns the count of elements in this seq.
		 *
		 * This operation may or may not traverse input, depending on the
		 * internal conditions.
		 *
		 * This is a terminal operation.
		 *
		 * @return a future of the count of elements
		 */
		public Gpseq.Future<int64?> count ();
		/**
		 * Returns a seq which contains the distinct elements of this seq, based
		 * on the given functions.
		 *
		 * This is a stateful intermediate operation.
		 *
		 * @param hash a //non-interfering// and //stateless// hash function. if
		 * not specified, {@link Gee.Functions.get_hash_func_for} is used to get
		 * a proper function
		 * @param equal a //non-interfering// and //stateless// equal function.
		 * if not specified, {@link Gee.Functions.get_equal_func_for} is used to
		 * get a proper function
		 * @return the new seq
		 */
		public Gpseq.Seq<G> distinct (owned Gee.HashDataFunc<G>? hash = null, owned Gee.EqualDataFunc<G>? equal = null);
		/**
		 * Creates a new sequential empty seq.
		 * @return an empty sequential seq
		 */
		public static Gpseq.Seq<G> empty<G> ();
		/**
		 * Returns a seq which contains the elements of this seq that match the
		 * given predicate.
		 *
		 * This is a stateless intermediate operation.
		 *
		 * @param pred a //non-interfering// and //stateless// predicate
		 * @return the new seq
		 */
		public Gpseq.Seq<G> filter (owned Gpseq.Predicate<G> pred);
		/**
		 * Returns an optional describing the any element that matches the given
		 * predicate, or an empty optional if not found.
		 *
		 * This is a short-circuiting terminal operation.
		 *
		 * @param pred a //non-interfering// and //stateless// predicate
		 * @return a future of an optional describing the any element that
		 * matches the given, or an empty optional if not found.
		 */
		public Gpseq.Future<Gpseq.Optional<G>> find_any (Gpseq.Predicate<G> pred);
		/**
		 * Returns an optional describing the first element that matches the
		 * given predicate, or an empty optional if not found.
		 *
		 * This operation respects encounter order even though the seq is
		 * in parallel mode.
		 *
		 * This is a short-circuiting terminal operation.
		 *
		 * @param pred a //non-interfering// and //stateless// predicate
		 * @return a future of an optional describing the first element that
		 * matches the given, or an empty optional if not found.
		 */
		public Gpseq.Future<Gpseq.Optional<G>> find_first (Gpseq.Predicate<G> pred);
		/**
		 * Returns a seq which contains the elements of the results of applying
		 * the given mapper function to the elements of this seq.
		 *
		 * This is a stateless intermediate operation.
		 *
		 * @param mapper a //non-interfering// and //stateless// mapping
		 * function. if it returns an {@link Gee.Iterator.valid} iterator, the
		 * element that the iterator points is also included in the result.
		 * @return the new seq
		 */
		public Gpseq.Seq<A> flat_map<A> (owned Gpseq.FlatMapFunc<A,G> mapper);
		/**
		 * Performs a reduction operation on the elements of this seq. This is
		 * equivalent to:
		 *
		 * {{{
		 * A result = identity;
		 * foreach (G g in seq) {
		 *     result = accumulator(g, result);
		 * }
		 * return result;
		 * }}}
		 *
		 * but is not constrained to execute sequentially.
		 *
		 * The identity value must be an identity for the combiner function. it
		 * means that: //a// is equal to //combiner(identity, a)//
		 *
		 * The combiner function must be compatible with the accumulator
		 * function. it means that: //accumulator(g, a)// is equal to
		 * //combiner(accumulator(identity, g), a)//
		 *
		 * This is a terminal operation.
		 *
		 * @param accumulator an //associative//, //non-interfering//, and
		 * //stateless// function for accumulating
		 * @param combiner an //associative//, //non-interfering//, and
		 * //stateless// function for combining two values
		 * @param identity the identity value for the combiner function
		 * @return a future of the result of the reduction
		 */
		public Gpseq.Future<A> fold<A> (Gpseq.FoldFunc<A,G> accumulator, Gpseq.CombineFunc<A> combiner, A identity);
		/**
		 * Applies the given function to each element of this seq.
		 *
		 * This is a terminal operation.
		 *
		 * @param f a //non-interfering// function
		 * @return a future that will be completed with null, or the error if
		 * an error occurs during the operation
		 */
		public Gpseq.Future<void*> @foreach (owned Gpseq.Func<G> f);
		/**
		 * Groups the elements based on the //classifier// function and returns
		 * the results in a map.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the returned map and list.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * seq.collect( Collectors.group_by(classifier) );
		 * }}}
		 *
		 * This is a terminal operation.
		 *
		 * @param classifier a classifier function mapping elements to keys
		 * @return a future of the result map
		 * @see Collectors.group_by
		 */
		public Gpseq.Future<Gee.Map<K,Gee.List<G>>> group_by<K> (owned Gpseq.MapFunc<K,G> classifier);
		/**
		 * Creates a new sequential seq, which each element is generated by the
		 * given //next// function applied to the previous element, and the
		 * initial element is the //seed//. The seq terminates when
		 * //pred(item)// returns false.
		 *
		 * The returned seq is similar to the for-loop below:
		 *
		 * {{{
		 * for (G item = seed; pred(item); item = next(item)) {
		 *     // Operations on the item.
		 * }
		 * }}}
		 *
		 * @param seed the initial element
		 * @param pred a predicate function to determine when the seq
		 * terminates
		 * @param next a mapping function to produce a new element by applying
		 * to the previous element
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> iterate<G> (owned G seed, owned Gee.Predicate<G> pred, owned Gee.MapFunc<G,G> next, Gpseq.TaskEnv? env = null);
		/**
		 * Returns an iterator for the elements of this seq.
		 *
		 * This is a non-eager terminal operation.
		 *
		 * @return an iterator for the elements
		 */
		public Gee.Iterator<G> iterator ();
		/**
		 * Returns a seq which contains the remaining elements of this seq,
		 * truncated to be no longer than //n// in length.
		 *
		 * On parallel execution, this operation doesn't respect encounter
		 * order.
		 *
		 * This is a short-circuiting stateful intermediate operation.
		 *
		 * @param n maximum number of elements the seq may contain
		 * @return the new seq
		 */
		public Gpseq.Seq<G> limit (int64 n);
		/**
		 * Returns a seq which contains the remaining elements of this seq,
		 * truncated to be no longer than //n// in length.
		 *
		 * This operation always respects encounter order.
		 *
		 * This is a short-circuiting stateful intermediate operation.
		 *
		 * This operation is quite expensive on parallel execution.
		 * Using {@link limit} instead or switching to sequential execution may
		 * improve performance.
		 *
		 * @param n maximum number of elements the seq may contain
		 * @return the new seq
		 */
		public Gpseq.Seq<G> limit_ordered (int64 n);
		/**
		 * Returns a seq which contains the results of applying the given mapper
		 * function to the elements of this seq.
		 *
		 * This is a stateless intermediate operation.
		 *
		 * @param mapper a //non-interfering// and //stateless// mapping
		 * function
		 * @return the new seq
		 */
		public Gpseq.Seq<A> map<A> (owned Gpseq.MapFunc<A,G> mapper);
		/**
		 * Returns the maximum element of this seq, based on the given compare
		 * function.
		 *
		 * This is a terminal operation.
		 *
		 * @param compare a //non-interfering// and //stateless// compare
		 * function. if not specified, {@link Gee.Functions.get_compare_func_for}
		 * is used to get a proper function
		 * @return a future of an optional describing the maximum element, or
		 * an empty optional if the seq is empty
		 */
		public Gpseq.Future<Gpseq.Optional<G>> max (owned GLib.CompareDataFunc<G>? compare = null);
		/**
		 * Returns the minimum element of this seq, based on the given compare
		 * function.
		 *
		 * This is a terminal operation.
		 *
		 * @param compare a //non-interfering// and //stateless// compare
		 * function. if not specified, {@link Gee.Functions.get_compare_func_for}
		 * is used to get a proper function
		 * @return a future of an optional describing the minimum element, or
		 * an empty optional if the seq is empty
		 */
		public Gpseq.Future<Gpseq.Optional<G>> min (owned GLib.CompareDataFunc<G>? compare = null);
		/**
		 * Returns whether or not no elements of this seq match the given
		 * predicate. If the seq is empty, the result is true.
		 *
		 * This is a short-circuiting terminal operation.
		 *
		 * @param pred a //non-interfering// and //stateless// predicate
		 * @return a future of the result -- true if either no elements match
		 * the given predicate or the seq is empty, otherwise false
		 */
		public Gpseq.Future<bool?> none_match (Gpseq.Predicate<G> pred);
		/**
		 * Creates a new sequential seq of the given array.
		 *
		 * The given array itself will not be modified by seq operations. and
		 * the array must not be modified until the execution of the seq
		 * pipeline is completed. Except for the non-eager operations iterator()
		 * and spliterator(), execution is performed when the terminal operation
		 * is invoked. In case of the non-eager operations, the array must not
		 * be modified while the iterator/spliterator is used.
		 *
		 * This method doesn't steal the ownership of the array. The array must
		 * not be freed until the execution is completed.
		 *
		 * @param array a gpointer array
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_array<G> (G[] array, Gpseq.TaskEnv? env = null);
		/**
		 * Creates a new sequential seq of the given collection.
		 *
		 * The given collection itself will not be modified by seq operations.
		 * and the collection must not be modified until the execution of the
		 * seq pipeline is completed. Except for the non-eager operations
		 * iterator() and spliterator(), execution is performed when the
		 * terminal operation is invoked. In case of the non-eager operations,
		 * the collection must not be modified while the iterator/spliterator is
		 * used.
		 *
		 * @param collection a collection
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_collection<G> (Gee.Collection<G> collection, Gpseq.TaskEnv? env = null);
		/**
		 * Creates a new sequential seq of the given generic array.
		 *
		 * The given generic array itself will not be modified by seq
		 * operations. and the array must not be modified until the execution of
		 * the seq pipeline is completed. Except for the non-eager operations
		 * iterator() and spliterator(), execution is performed when the
		 * terminal operation is invoked. In case of the non-eager operations,
		 * the array must not be modified while the iterator/spliterator is
		 * used.
		 *
		 * @param array a generic array
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_generic_array<G> (GLib.GenericArray<G> array, Gpseq.TaskEnv? env = null);
		/**
		 * Creates a new sequential seq of the given iterator.
		 *
		 * Most of the seq operations affect the state of the given iterator by
		 * moving it forward. and the iterator must not be modified until the
		 * execution of the seq pipeline is completed. Except for the non-eager
		 * operations iterator() and spliterator(), execution is performed when
		 * the terminal operation is invoked. In case of the non-eager
		 * operations, the iterator must not be modified while the result
		 * iterator/spliterator is used.
		 *
		 * @param iterator an iterator
		 * @param estimated_size an estimate of the number of elements
		 * @param size_known whether or not the estimated_size is an accurate
		 * size
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_iterator<G> (Gee.Iterator<G> iterator, int64 estimated_size, bool size_known, Gpseq.TaskEnv? env = null);
		/**
		 * Creates a new sequential seq of the given list.
		 *
		 * The given list itself will not be modified by seq operations. and the
		 * list must not be modified until the execution of the seq pipeline is
		 * completed. Except for the non-eager operations iterator() and
		 * spliterator(), execution is performed when the terminal operation is
		 * invoked. In case of the non-eager operations, the list must not be
		 * modified while the iterator/spliterator is used.
		 *
		 * The result seq of this method will show better performance than the
		 * result of {@link of_collection}.
		 *
		 * @param list a list
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_list<G> (Gee.List<G> list, Gpseq.TaskEnv? env = null);
		/**
		 * Creates a new sequential seq of the given array.
		 *
		 * The given array itself will not be modified by seq operations. and
		 * the array must not be modified until the execution of the seq
		 * pipeline is completed. Except for the non-eager operations iterator()
		 * and spliterator(), execution is performed when the terminal operation
		 * is invoked. In case of the non-eager operations, the array must not
		 * be modified while the iterator/spliterator is used.
		 *
		 * This method steals the ownership of the array. The array wil be
		 * freed after the execution is completed.
		 *
		 * @param array a gpointer array
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_owned_array<G> (owned G[] array, Gpseq.TaskEnv? env = null);
		/**
		 * Creates a new sequential infinite unordered seq, which each element
		 * is generated by the given supplier.
		 *
		 * @param supplier a supplier
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_supplier<G> (Gpseq.Supplier<G> supplier, Gpseq.TaskEnv? env = null);
		/**
		 * Creates a new sequential infinite unordered seq, which each element
		 * is generated by the given supply function.
		 *
		 * @param func a supply function
		 * @param env a task environment. If not specified,
		 * {@link TaskEnv.get_common_task_env} is used.
		 * @return the result seq
		 */
		public static Gpseq.Seq<G> of_supply_func<G> (owned Gpseq.SupplyFunc<G> func, Gpseq.TaskEnv? env = null);
		/**
		 * Returns a seq which contains the elements of this seq, sorted based
		 * on the given compare function. The sort is stable.
		 *
		 * This is a stateful intermediate operation.
		 *
		 * @param compare a //non-interfering// and //stateless// compare
		 * function. if not specified, {@link Gee.Functions.get_compare_func_for}
		 * is used to get a proper function
		 * @return the new seq
		 */
		public Gpseq.Seq<G> order_by (owned GLib.CompareDataFunc<G>? compare = null);
		/**
		 * Returns a new equivalent seq that is parallel.
		 *
		 * This is a stateless intermediate operation.
		 *
		 * @return a new equivalent seq that is parallel
		 */
		public Gpseq.Seq<G> parallel ();
		/**
		 * Partitions the elements based on the //pred// function and returns
		 * the results in a map.
		 *
		 * The result map always contains lists for both true and false keys.
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the returned map and list.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * seq.collect( Collectors.partition(pred) );
		 * }}}
		 *
		 * This is a terminal operation.
		 *
		 * @param pred a predicate function
		 * @return a future of the result map
		 * @see Collectors.partition
		 */
		public Gpseq.Future<Gee.Map<bool,Gee.List<G>>> partition (owned Gpseq.Predicate<G> pred);
		/**
		 * Performs a reduction operation on the elements of this seq. This is
		 * equivalent to:
		 *
		 * {{{
		 * G? result = null;
		 * bool found = false;
		 * foreach (G g in seq) {
		 *     if (!found) {
		 *         result = g;
		 *         found = true;
		 *     } else {
		 *         result = accumulator(g, result);
		 *     }
		 * }
		 * return found ? new Optional<G>.of(result) : new Optional<G>.empty();
		 * }}}
		 *
		 * but is not constrained to execute sequentially.
		 *
		 * This is a terminal operation.
		 *
		 * @param accumulator an //associative//, //non-interfering//, and
		 * //stateless// function for combining two values
		 * @return a future of the result of the reduction
		 */
		public Gpseq.Future<Gpseq.Optional<G>> reduce (Gpseq.CombineFunc<G> accumulator);
		/**
		 * Returns a seq which contains the elements of this seq, sorted based
		 * on the given compare function, but in descending order. The sort is
		 * stable.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * seq.order_by( Compares.reverse<G>(compare) );
		 * }}}
		 *
		 * This is a stateful intermediate operation.
		 *
		 * @param compare a //non-interfering// and //stateless// compare
		 * function. if not specified, {@link Gee.Functions.get_compare_func_for}
		 * is used to get a proper function
		 * @return the new seq
		 * @see order_by
		 * @see Compares.reverse
		 */
		[Version (since = "0.4.0-alpha")]
		public Gpseq.Seq<G> reverse_order_by (owned GLib.CompareDataFunc<G>? compare = null);
		/**
		 * Returns a new equivalent seq that is sequential.
		 *
		 * This is a stateless intermediate operation.
		 *
		 * @return a new equivalent seq that is sequential
		 */
		public Gpseq.Seq<G> sequential ();
		/**
		 * Returns a seq which contains the remaining elements of this seq after
		 * discarding the first //n// elements.
		 *
		 * On parallel execution, this operation doesn't respect encounter
		 * order.
		 *
		 * This is a stateful intermediate operation.
		 *
		 * @param n the number of elements to skip
		 * @return the new seq
		 */
		public Gpseq.Seq<G> skip (int64 n);
		/**
		 * Returns a seq which contains the remaining elements of this seq after
		 * discarding the first //n// elements.
		 *
		 * This operation always respects encounter order.
		 *
		 * This is a stateful intermediate operation.
		 *
		 * This operation is quite expensive on parallel execution.
		 * Using {@link skip} instead or switching to sequential execution may
		 * improve performance.
		 *
		 * @param n the number of elements to skip
		 * @return the new seq
		 */
		public Gpseq.Seq<G> skip_ordered (int64 n);
		/**
		 * Returns a spliterator for the elements of this seq.
		 *
		 * This is a non-eager terminal operation.
		 *
		 * @return a spliterator for the elements
		 */
		public Gpseq.Spliterator<G> spliterator ();
		/**
		 * Accumulates the elements into a new generic array, in encounter
		 * order.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * seq.collect( Collectors.to_generic_array<G>() );
		 * }}}
		 *
		 * This is a terminal operation.
		 *
		 * @return a future of the result generic array
		 * @see Collectors.to_generic_array
		 */
		[Version (since = "0.4.0-alpha")]
		public Gpseq.Future<GLib.GenericArray<G>> to_generic_array ();
		/**
		 * Accumulates the elements into a new list, in encounter order.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the list.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * seq.collect( Collectors.to_list<G>() );
		 * }}}
		 *
		 * This is a terminal operation.
		 *
		 * @return a future of the result list
		 * @see Collectors.to_list
		 */
		[Version (since = "0.4.0-alpha")]
		public Gpseq.Future<Gee.List<G>> to_list ();
		/**
		 * Accumulates the elements into a new map.
		 *
		 * If there are key duplications, the values are merged using the
		 * //merger// function, or the future is completed with a
		 * {@link MapError.DUPLICATE_KEY} if the function is not specified.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the map.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * seq.collect( Collectors.to_map<K,V,G>(...) );
		 * }}}
		 *
		 * This is a terminal operation.
		 *
		 * @param key_mapper a mapping function for keys
		 * @param val_mapper a mapping function for values
		 * @param merger a function used to resolve key collisions. if not
		 * specified, //(a, b) => { throw new MapError.DUPLICATE_KEY(...); }//
		 * is used.
		 * @param key_hash a hash function for keys. if not specified,
		 * {@link Gee.Functions.get_hash_func_for} is used to get a proper
		 * function
		 * @param key_equal an equal function for keys. if not specified,
		 * {@link Gee.Functions.get_equal_func_for} is used to get a proper
		 * function
		 * @param value_equal an equal function for values. if not specified,
		 * {@link Gee.Functions.get_equal_func_for} is used to get a proper
		 * function
		 * @return a future of the result map
		 * @see Collectors.to_map
		 */
		[Version (since = "0.4.0-alpha")]
		public Gpseq.Future<Gee.Map<K,V>> to_map<K,V> (owned Gpseq.MapFunc<K,G> key_mapper, owned Gpseq.MapFunc<V,G> val_mapper, owned Gpseq.CombineFunc<V>? merger = null, owned Gee.HashDataFunc<K>? key_hash = null, owned Gee.EqualDataFunc<K>? key_equal = null, owned Gee.EqualDataFunc<V>? value_equal = null);
		/**
		 * Accumulates the elements into a new set.
		 *
		 * There are no guarantees on the type, mutability, or thread-safety of
		 * the set.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * seq.collect( Collectors.to_set<G>(hash, equal) );
		 * }}}
		 *
		 * This is a terminal operation.
		 *
		 * @param hash a hash function. if not specified,
		 * {@link Gee.Functions.get_hash_func_for} is used to get a proper
		 * function
		 * @param equal an equal function. if not specified,
		 * {@link Gee.Functions.get_equal_func_for} is used to get a proper
		 * function
		 * @return a future of the result set
		 * @see Collectors.to_set
		 */
		[Version (since = "0.4.0-alpha")]
		public Gpseq.Future<Gee.Set<G>> to_set (owned Gee.HashDataFunc<G>? hash = null, owned Gee.EqualDataFunc<G>? equal = null);
		/**
		 * The type of the elements.
		 */
		public GLib.Type element_type { get; }
		/**
		 * Whether or not this seq has been closed.
		 */
		public bool is_closed { get; }
		/**
		 * Whether or not this seq is in parallel mode.
		 *
		 * This can be accessed even though this seq has been closed.
		 */
		public bool is_parallel { get; }
		/**
		 * The task environment of this seq.
		 *
		 * This can be accessed even though this seq has been closed.
		 */
		public Gpseq.TaskEnv task_env { get; }
	}
	/**
	 * A base class for spliterator based fork-join tasks.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public abstract class SpliteratorTask<R,G> : Gpseq.ForkJoinTask<R> {
		/**
		 * Creates a spliterator task.
		 *
		 * @param spliterator a spliterator that may or may not be a container
		 * @param parent the parent of this task
		 * @param threshold sequential computation threshold
		 * @param max_depth max task split depth. unlimited if negative
		 * @param executor an executor that will invoke the task
		 */
		protected SpliteratorTask (Gpseq.Spliterator<G> spliterator, Gpseq.SpliteratorTask<R,G>? parent, int64 threshold, int max_depth, Gpseq.Executor executor);
		/**
		 * Cancels all tasks which following this in the encounter order.
		 */
		protected void cancel_later_nodes ();
		protected override void compute ();
		/**
		 * Computes this leaf node task.
		 *
		 * This method will be called by compute() if this task is a leaf node.
		 *
		 * You should override this method instead of {@link compute}.
		 */
		protected abstract R leaf_compute () throws GLib.Error;
		/**
		 * Creates a child task with the given spliterator.
		 */
		protected abstract Gpseq.SpliteratorTask<R,G> make_child (Gpseq.Spliterator<G> spliterator);
		/**
		 * Merges the left and right result, then returns the merged result.
		 */
		protected abstract R merge_results (owned R left, owned R right) throws GLib.Error;
		/**
		 * Gets an empty result.
		 *
		 * When the {@link ForkJoinTask.shared_result} is already ready without
		 * exceptions, this task has been cancelled, or a class that inherits
		 * this class needs, the empty result is used and set to the promise of
		 * this task.
		 */
		protected abstract R empty_result { owned get; }
		/**
		 * Whether or not this task is a leaf node.
		 *
		 * A task is a leaf node if it has no children.
		 */
		protected bool is_leaf { get; }
		/**
		 * Whether or not the path from the root to this involves only left
		 * child of each node.
		 */
		protected bool is_leftmost { get; }
		/**
		 * The left child of this task.
		 *
		 * If {@link right_child} is non-null, this is also non-null, but not
		 * vice versa. There is no similar rule applied to null.
		 */
		protected Gpseq.SpliteratorTask<R,G>? left_child { get; }
		/**
		 * The right child of this task.
		 *
		 * If this is non-null, {@link left_child} is also non-null, but not
		 * vice versa. There is no similar rule applied to null.
		 */
		protected Gpseq.SpliteratorTask<R,G>? right_child { get; }
		protected Gpseq.Spliterator<G> spliterator { get; }
	}
	/**
	 * An unowned slice of an array.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class SubArray<G> : GLib.Object, Gee.Traversable<G>, Gee.Iterable<G> {
		/**
		 * Creates a new sub array with an unowned view of an array.
		 * @param data an unowned view of a gpointer array
		 */
		public SubArray (G[] data);
		/**
		 * Copies the data from src into this.
		 * @param start zero-based index of this to store data
		 * @param src the data source to copy
		 * @param src_start zero-based index of the begin to copy
		 * @param count the number of elements to copy
		 */
		public void copy (int start, Gpseq.SubArray<G> src, int src_start, int count);
		/**
		 * Copies the data from src into this.
		 * @param start zero-based index of this to store data
		 * @param src the data source to copy
		 * @param src_start zero-based index of the begin to copy
		 * @param count the number of elements to copy
		 */
		public void copy_array (int start, G[] src, int src_start, int count);
		/**
		 * Creates a new sub array with another sub array.
		 * @param array a sub array
		 * @param start zero-based index of the begin of the slice
		 * @param stop zero-based index after the end of the slice
		 */
		public SubArray.from_sub_array (Gpseq.SubArray<G> array, int start, int stop);
		public new unowned G @get (int index);
		/**
		 * Gets the array data.
		 * @return the internal array
		 */
		public new unowned G[] get_data ();
		public new void @set (int index, owned G item);
		/**
		 * Sorts the elements by comparing with the specified compare function.
		 * The sort is stable.
		 *
		 * @param compare_func compare function to compare elements. if it is
		 * not specified, the result of
		 * {@link Gee.Functions.get_compare_func_for} is used
		 */
		public void sort (owned GLib.CompareDataFunc<G>? compare_func = null);
		/**
		 * Creates a new sub array slice.
		 * @param start zero-based index of the begin of the slice
		 * @param stop zero-based index after the end of the slice
		 * @return the new sub array
		 */
		public Gpseq.SubArray<G> sub_array (int start, int stop);
		/**
		 * The number of elements.
		 */
		public int size { get; }
	}
	/**
	 * A spliterator of a sub array.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class SubArraySpliterator<G> : GLib.Object, Gpseq.Spliterator<G> {
		/**
		 * Creates a new sub array spliterator.
		 * @param array a sub array
		 * @param start zero-based index of the begin
		 * @param stop zero-based index after the end
		 */
		public SubArraySpliterator (Gpseq.SubArray<G> array, int start, int stop);
	}
	/**
	 * An infinite unordered spliterator, which each element is generated by a
	 * supplier.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class SupplierSpliterator<G> : GLib.Object, Gpseq.Spliterator<G> {
		/**
		 * Creates a new supplier spliterator.
		 * @param supplier a supplier
		 */
		public SupplierSpliterator (Gpseq.Supplier<G> supplier);
	}
	/**
	 * An object to configure the environment of execution of tasks
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public abstract class TaskEnv : GLib.Object {
		protected TaskEnv ();
		/**
		 * Runs the function with the given task environment as the common task
		 * environment.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * TaskEnv.push(task_env);
		 * func();
		 * TaskEnv.pop();
		 * }}}
		 *
		 * @see get_common_task_env
		 * @see push
		 * @see pop
		 */
		[Version (since = "0.2.0-alpha")]
		public static void apply (Gpseq.TaskEnv task_env, Gpseq.VoidFunc func);
		/**
		 * Gets the common task environment.
		 *
		 * If //task env stack// is not empty, returns the top of the stack. If
		 * empty, returns the default task environment.
		 *
		 * @return the common task environment
		 * @see get_default_task_env
		 * @see push
		 * @see pop
		 */
		[Version (since = "0.2.0-alpha")]
		public static Gpseq.TaskEnv get_common_task_env ();
		/**
		 * Gets the default task environment.
		 *
		 * The default task environment is constructed when this method is
		 * called initially, if has not yet been set.
		 *
		 * @return the default task environment
		 */
		public static Gpseq.TaskEnv get_default_task_env ();
		/**
		 * Remove an element from the top of //task env stack//.
		 *
		 * @see push
		 * @see get_common_task_env
		 */
		[Version (since = "0.2.0-alpha")]
		public static void pop ();
		/**
		 * Pushs the given task environment into //task env stack//.
		 *
		 * @param task_env a task environment
		 * @see pop
		 * @see get_common_task_env
		 */
		[Version (since = "0.2.0-alpha")]
		public static void push (Gpseq.TaskEnv task_env);
		/**
		 * Calculates the proper max depth.
		 *
		 * @param elements an estimate of the number of elements. it is negative
		 * if infinite or unknown.
		 * @param threads the number of threads (always >= 1)
		 * @return max depth. 0: no split, 1: one split, 2: two split, ... (a
		 * split may generate one or more child nodes). unlimited if negative
		 * @see ForkJoinTask.max_depth
		 */
		public abstract int resolve_max_depth (int64 elements, int threads);
		/**
		 * Calculates the proper threshold.
		 *
		 * @param elements an estimate of the number of elements. it is negative
		 * if infinite or unknown.
		 * @param threads the number of threads (always >= 1)
		 * @return threshold (must be >= 1)
		 * @see ForkJoinTask.threshold
		 */
		public abstract int64 resolve_threshold (int64 elements, int threads);
		/**
		 * Sets the default task environment.
		 * @param task_env a task environment
		 */
		public static void set_default_task_env (Gpseq.TaskEnv task_env);
		/**
		 * The executor for parallel tasks.
		 */
		public abstract Gpseq.Executor executor { get; }
	}
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.3.0-alpha")]
	public class WaitGroup : GLib.Object {
		public WaitGroup ();
		/**
		 * Adds //delta// to the counter.
		 *
		 * All threads blocked on wait()/wait_until() are awakened if the
		 * counter becomes zero.
		 *
		 * If the counter becomes negative, fails with {@link GLib.error}.
		 *
		 * @param delta a delta which may be negative
		 */
		public void add (int delta = 1);
		/**
		 * Decreases the counter by one.
		 *
		 * All threads blocked on wait()/wait_until() are awakened if the
		 * counter becomes zero.
		 *
		 * If the counter becomes negative, fails with {@link GLib.error}.
		 */
		public void done ();
		/**
		 * Increases the counter by one and schedules the given function to
		 * execute. Next, decreases the counter by one after the function is
		 * executed.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * waitgroup.add();
		 * return Gpseq.run(() => {
		 *     try {
		 *         func();
		 *     } catch (Error err) {
		 *         throw err;
		 *     } finally {
		 *         waitgroup.done();
		 *     }
		 * });
		 * }}}
		 *
		 * @param func a task function to execute
		 * @return a future of the execution
		 *
		 * @see Gpseq.run
		 */
		[Version (since = "0.4.0-alpha")]
		public Gpseq.Future<void*> run (owned Gpseq.VoidTaskFunc func);
		/**
		 * Increases the counter by one and schedules the given function to
		 * execute. Next, decreases the counter by one after the function is
		 * executed.
		 *
		 * This is equivalent to:
		 *
		 * {{{
		 * waitgroup.add();
		 * return Gpseq.task<G>(() => {
		 *     try {
		 *         G result = func();
		 *         return (owned) result;
		 *     } catch (Error err) {
		 *         throw err;
		 *     } finally {
		 *         waitgroup.done();
		 *     }
		 * });
		 * }}}
		 *
		 * @param func a task function to execute
		 * @return a future of the execution
		 *
		 * @see Gpseq.task
		 */
		[Version (since = "0.4.0-alpha")]
		public Gpseq.Future<G> task<G> (owned Gpseq.TaskFunc<G> func);
		/**
		 * Waits until the counter is zero.
		 */
		public void wait ();
		/**
		 * Waits until the counter is zero or //end_time// has passed.
		 *
		 * @return false on a timeout, true otherwise
		 */
		public bool wait_until (int64 end_time);
	}
	/**
	 * A thread pool for executing tasks in parallel.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class WorkerPool : GLib.Object, Gpseq.Executor {
		/**
		 * Creates a new worker pool.
		 *
		 * @param parallels the number of threads
		 * @param factory a thread factory to create new threads
		 *
		 * @throws Error if threads can not be created, due to resource limits,
		 * etc.
		 */
		public WorkerPool (int parallels, Gpseq.ThreadFactory factory) throws GLib.Error;
		/**
		 * Gets the default thread factory. the factory is constructed when this
		 * method is called initially.
		 *
		 * @return the default thread factory
		 */
		public static Gpseq.ThreadFactory get_default_factory ();
		/**
		 * Starts terminating threads.
		 *
		 * This method does not wait for all threads to complete termination.
		 *
		 * This method does nothing if this pool has been terminating or
		 * terminated.
		 */
		public void terminate ();
		/**
		 * Starts terminating threads and wait for all threads to complete
		 * termination.
		 */
		public void terminate_now ();
		/**
		 * Blocks until all threads have completed termination.
		 * @see terminate
		 * @see wait_termination_until
		 */
		public void wait_termination ();
		/**
		 * Blocks until either all threads have completed termination or
		 * //end_time// has passed.
		 *
		 * @param end_time the monotonic time to wait until
		 * @see terminate
		 * @see wait_termination
		 */
		public void wait_termination_until (int64 end_time);
		/**
		 * Creates a new worker pool, with default settings.
		 *
		 * @throws Error if threads can not be created, due to resource limits,
		 * etc.
		 */
		public WorkerPool.with_defaults () throws GLib.Error;
		/**
		 * The thread factory to create new threads.
		 */
		public Gpseq.ThreadFactory factory { get; }
		/**
		 * Whether or not this pool has been terminated.
		 */
		public bool is_terminated { get; }
		/**
		 * Whether or not this pool has been terminating.
		 *
		 * true if {@link terminate} has been called and this pool has not yet
		 * been terminated, false otherwise.
		 */
		public bool is_terminating { get; }
		/**
		 * Whether or not {@link terminate} has been called.
		 */
		public bool is_terminating_started { get; }
		/**
		 * The maximum number of threads that this pool can use.
		 *
		 * The actual limit may be less than this value, due to resource limits.
		 *
		 * This value is always >= {@link parallels}.
		 */
		[Version (since = "0.2.0-alpha")]
		public int max_threads { get; set; }
		/**
		 * The current number of threads.
		 */
		[Version (since = "0.2.0-alpha")]
		public int num_threads { get; }
	}
	/**
	 * A worker thread.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class WorkerThread : GLib.Object {
		/**
		 * Creates a new worker thread.
		 *
		 * @param pool a worker pool
		 */
		public WorkerThread (Gpseq.WorkerPool pool);
		/**
		 * Runs the given blocking task and returns the result.
		 *
		 * This method tries to create a new thread.
		 *
		 * -> If succeed, the new thread takes the context of this thread and
		 * runs the remaining tasks in the context. This thread runs the
		 * blocking task and is marked as //blocked// until the task ends.
		 * After it ends, this thread is unblocked and takes the context back,
		 * and the new thread is terminated.
		 *
		 * -> If failed, e.g. the maximum number of threads exceeded, this
		 * method just runs the function without any further work.
		 *
		 * This method must be called in //this// thread.
		 *
		 * @param func a task function
		 * @return the result produced by the function
		 *
		 * @throws Error the error thrown by the function
		 *
		 * @see Gpseq.blocking
		 * @see Gpseq.blocking_get
		 */
		[Version (since = "0.2.0-alpha")]
		public G blocking<G> (Gpseq.TaskFunc<G> func) throws GLib.Error;
		/**
		 * Gets the worker thread corresponding to the given thread.
		 *
		 * @return the worker thread corresponding to the given Thread, or
		 * null if not found
		 */
		public static Gpseq.WorkerThread? get_by (GLib.Thread thread);
		/**
		 * Waits until this thread finishes.
		 *
		 * @see GLib.Thread.join
		 */
		public void join ();
		/**
		 * Gets the worker thread corresponding to the current thread.
		 *
		 * @return the worker thread corresponding to the current thread, or
		 * null if the current thread is not a worker thread
		 */
		public static Gpseq.WorkerThread? self ();
		/**
		 * Starts this thread.
		 *
		 * @throws Error if a system thread can not be created, due to resource
		 * limits, etc.
		 */
		public void start () throws GLib.Error;
		/**
		 * Whether or not this thread is alive. A thread is alive if it has been
		 * started and has not yet terminated.
		 */
		public bool is_alive { get; }
		/**
		 * Whether or not this thread has been started.
		 */
		public bool is_started { get; }
		/**
		 * Whether or not this thread has been terminated.
		 */
		public bool is_terminated { get; }
		/**
		 * The name of this thread.
		 */
		public string name { get; }
		/**
		 * The worker pool to which this thread belongs.
		 */
		public Gpseq.WorkerPool pool { get; }
		/**
		 * The internal thread object, or null if this worker thread has not
		 * yet started.
		 */
		public GLib.Thread<void*>? thread { get; }
	}
	/**
	 * A wrapper object containing a value.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public class Wrapper<G> : GLib.Object {
		public Wrapper (owned G value);
		public G value { get; }
		public GLib.Type value_type { get; }
	}
	/**
	 * Multi-producer multi-consumer channels. Channels are the pipes that
	 * provide communication between threads.
	 *
	 * @see Sender
	 * @see Receiver
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.3.0-alpha")]
	public interface Channel<G> : Gpseq.Sender<G>, Gpseq.Receiver<G> {
		/**
		 * Creates a bounded channel.
		 *
		 * If //proposed_capacity// == 0, returns an unbuffered channel of
		 * which capacity is zero. It is a symmetric rendezvous queue and has
		 * no buffer to hold data, but its send and receive operations are done
		 * symmetrically, i.e., wait for one another.
		 *
		 * If //proposed_capacity// > 0, returns a buffered channel of which
		 * capacity is ''at least'' //proposed_capacity//, i.e, the actual
		 * capacity could be greater than //proposed_capacity//. It can hold
		 * data up to the capacity.
		 *
		 * @param proposed_capacity a proposed capacity.
		 * @return a bounded channel
		 */
		public static Gpseq.Channel<G> bounded<G> (int proposed_capacity);
		/**
		 * Creates an unbounded channel that has no capacity limit. It can hold
		 * any number of data.
		 *
		 * @return an unbounded channel
		 */
		public static Gpseq.Channel<G> unbounded<G> ();
	}
	/**
	 * A base interface for senders and receivers.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.3.0-alpha")]
	public interface ChannelBase : GLib.Object {
		/**
		 * Closes the channel.
		 *
		 * If the channel has already been closed, this method does nothing.
		 *
		 * Channels are automatically closed when they are freed.
		 */
		public abstract void close ();
		/**
		 * The capacity of the channel.
		 *
		 * If the channel is unbounded, the capacity is not present.
		 */
		public abstract Gpseq.Optional<int64?> capacity { owned get; }
		/**
		 * Whether or not the channel is empty.
		 *
		 * Unbuffered channels are always empty.
		 *
		 * This is a constant-time operation.
		 */
		public virtual bool is_empty { get; }
		/**
		 * Whether or not the channel is full.
		 *
		 * Unbuffered channels are always full.
		 *
		 * This is a constant-time operation.
		 */
		public virtual bool is_full { get; }
		/**
		 * The current number of data in the channel.
		 *
		 * Unbuffered channels are always zero-length.
		 *
		 * If the channel is unbounded and contains more than {@link int64.MAX}
		 * elements, returns {@link int64.MAX}.
		 *
		 * Note. This may or may not be a constant-time operation. If not, this
		 * requires a traversal of the elements, and so may return inaccurate
		 * results if modified during traversal.
		 */
		public abstract int64 length { get; }
	}
	/**
	 * An object for mutable reduction operation that accumulates input
	 * elements into a mutable accumulator, and transforms it into a final
	 * result.
	 *
	 * A collector implements four methods: {@link create_accumulator},
	 * {@link accumulate}, {@link combine}, and {@link finish}.
	 *
	 *  i. create_accumulator() - creates a new accumulator, such as {@link Gee.Collection}.
	 *  i. accumulate() - incorporates a new element into a accumulator.
	 *  i. combine() - combines two accumulators into one.
	 *  i. finish() - transforms the accumulator into a final result.
	 *
	 * The methods must satisfy an //identity// and an //associativity//
	 * constraints. The identity constraint means that combining any accumulator
	 * with an empty accumulator must produce an equivalent result. i.e. an
	 * accumulator //a// must be equivalent to
	 * //collector.accumulate(a, collector.create_accumulator())//
	 *
	 * The associativity constraint means that splitting the computation must
	 * produce an equivalent result. i.e.:
	 *
	 * {{{
	 * // the two computations below must be equivalent.
	 * // collector: a collector
	 * // g0, g1: elements
	 *
	 * A a0 = collector.create_accumulator();
	 * collector.accumulate(g0, a0);
	 * collector.accumulate(g1, a0);
	 * A r0 = collector.finish(a0);
	 *
	 * A a1 = collector.create_accumulator();
	 * collector.accumulate(g0, a1);
	 * A a2 = collector.create_accumulator();
	 * collector.accumulate(g1, a2);
	 * A r1 = collector.finish( collector.combine(a1, a2) );
	 * }}}
	 *
	 * Collectors also have a property, {@link features}. it provides hints
	 * that can be used to optimize the operation.
	 *
	 * @see Seq.collect
	 * @see Seq.collect_ordered
	 * @see Collectors
	 * @see CollectorFeatures
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public interface Collector<R,A,G> : GLib.Object {
		/**
		 * Accumulates a element into a accumulator.
		 *
		 * This method must be //associative//, //non-interfering//, and
		 * //stateless//.
		 *
		 * @param g element
		 * @param a accumulator
		 */
		public abstract void accumulate (G g, A a) throws GLib.Error;
		/**
		 * Combines two accumulators into one.
		 *
		 * This method must be //associative//, //non-interfering//, and
		 * //stateless//.
		 *
		 * @return combined accumulator.
		 */
		public abstract A combine (A a, A b) throws GLib.Error;
		/**
		 * Creates a new accumulator.
		 */
		public abstract A create_accumulator () throws GLib.Error;
		/**
		 * Transforms an accumulator into a final result.
		 * @return the final result
		 */
		public abstract R finish (A a) throws GLib.Error;
		/**
		 * Hints that can be used to optimize collect operations.
		 */
		public abstract Gpseq.CollectorFeatures features { get; }
	}
	/**
	 * An object that executes tasks. the execution is performed sequentially
	 * or in parallel, depending on the executor implementation.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public interface Executor : GLib.Object {
		/**
		 * Submits a task.
		 * @param task a task to execute
		 */
		public abstract void submit (Gpseq.Task task);
		/**
		 * The parallelism level.
		 */
		public abstract int parallels { get; }
	}
	/**
	 * The receiver side of a channel.
	 *
	 * @see Channel
	 * @see Sender
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.3.0-alpha")]
	public interface Receiver<G> : Gpseq.ChannelBase, Gee.Traversable<G> {
		/**
		 * Receives a value from the channel. This method blocks the thread
		 * until a value is received or the channel is closed and has no more
		 * data.
		 *
		 * If the channel is empty, not unbuffered, and not closed, blocks
		 * until there is a value in the channel.
		 *
		 * If the channel is unbuffered, waits for a send operation.
		 *
		 * Errors:
		 *
		 *  * ChannelError.CLOSED
		 *
		 * If the channel has been closed and no more data.
		 *
		 * @return the result which holds a value if succeeded, or an error if
		 * failed.
		 */
		public abstract Gpseq.Result<G> recv ();
		/**
		 * Receives a value from the channel. This method blocks the thread
		 * until a value is received, the channel is closed and has no more
		 * data, or //end_time// has passed.
		 *
		 * This method is the same as {@link recv} except there is a timeout.
		 *
		 * Errors:
		 *
		 *  * ChannelError.CLOSED
		 *
		 * If the channel has been closed and no more data.
		 *
		 *  * ChannelError.TIMEOUT
		 *
		 * If //end_time// has passed.
		 *
		 * @param end_time the monotonic time to wait until
		 * @return the result which holds a value if succeeded, or an error if
		 * failed.
		 */
		public abstract Gpseq.Result<G> recv_until (int64 end_time);
		/**
		 * Attempts to receive a value from the channel. This method doesn't
		 * block the thread and returns immediately, regardless of success.
		 *
		 * Errors:
		 *
		 *  * ChannelError.CLOSED
		 *
		 * If the channel has been closed and no more data.
		 *
		 *  * ChannelError.TRY_FAILED
		 *
		 * If the channel is empty (bufferd or unbounded channel), or there are
		 * no send operations waiting for receive operations (unbuffered
		 * channel).
		 *
		 * @return the result which holds a value if succeeded, or an error if
		 * failed.
		 */
		public abstract Gpseq.Result<G> try_recv ();
	}
	/**
	 * A result object that holds a value or an error.
	 *
	 * @see Future
	 * @see Optional
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[GenericAccessors]
	[Version (since = "0.3.0-alpha")]
	public interface Result<G> : Gee.Hashable<Gpseq.Result<G>> {
		public delegate Gpseq.Result<A> FlatMapFunc<A,G> (G value);
		public delegate unowned A LightMapFunc<A,G> (G value) throws GLib.Error;
		public delegate GLib.Error MapErrorFunc (owned GLib.Error err);
		public delegate A MapFunc<A,G> (G value) throws GLib.Error;
		public delegate Gpseq.Result<A> TransformFunc<A,G> (Gpseq.Result<G> result);
		public delegate C ZipFunc<A,B,C> (A a, B b) throws GLib.Error;
		/**
		 * Runs the function with the value if this result holds a value.
		 *
		 * If this result holds or the function throws an exception, the
		 * returned result holds the exception.
		 *
		 * @param func a function called
		 * @return the result
		 */
		public virtual Gpseq.Result<G> and_then (owned Gpseq.Func<G> func);
		/**
		 * Creates a result holds the given error.
		 *
		 * @param exception an error
		 * @return the result
		 */
		public static Gpseq.Result<G> err<G> (owned GLib.Error exception);
		/**
		 * Maps the value to another result by applying the given function to
		 * the value.
		 *
		 * If this result holds an exception, the returned result holds the
		 * exception too.
		 *
		 * The returned object of the function may or may not be directly used.
		 * Depending on the internal implementation, A new result object will
		 * be created with the value or exception of it and returned, instead
		 * of returning it directly.
		 *
		 * @param func a function applied to value
		 * @return the new result
		 */
		public virtual Gpseq.Result<A> flat_map<A> (owned Gpseq.Result.FlatMapFunc<A,G> func);
		/**
		 * Returns a {@link Future} version of this result.
		 *
		 * ''{@link Result} implementation:'' Creates a future completed with
		 * this result.
		 *
		 * ''{@link Future} implementation:'' Returns this.
		 *
		 * @return the future
		 */
		public virtual Gpseq.Future<G> future ();
		/**
		 * Gets the value or throws the exception.
		 *
		 * ''{@link Future} implementation:'' Waits until the future is
		 * completed. It is an alias for {@link Future.wait}.
		 *
		 * @return the value if this result holds a value
		 *
		 * @throws Error if this result holds an exception, the exception will
		 * be thrown
		 */
		public abstract unowned G @get () throws GLib.Error;
		/**
		 * Maps the value to another value by applying the given function to
		 * the value.
		 *
		 * If this result holds or the function throws an exception, the
		 * returned result holds the exception.
		 *
		 * @param func a function applied to value
		 * @return the mapped result
		 */
		public virtual Gpseq.Result<A> map<A> (owned Gpseq.Result.MapFunc<A,G> func);
		/**
		 * If this result holds an exception, maps the exception to another
		 * exception by applying the given function to the exception, otherwise
		 * the returned result holds the value of this result.
		 *
		 * @param func a function applied to exception
		 * @return the mapped result
		 */
		public virtual Gpseq.Result<G> map_err (owned Gpseq.Result.MapErrorFunc func);
		/**
		 * Creates a result holds the given value.
		 *
		 * @return the result
		 */
		public static Gpseq.Result<G> of<G> (owned G value);
		/**
		 * Ensures this result holds a value, not an error.
		 *
		 * If this holds an error, fails with {@link GLib.error}. Otherwise,
		 * returns this.
		 *
		 * ''{@link Future} implementation:'' Waits until the future is
		 * completed if not yet completed.
		 *
		 * @return this result if no error
		 */
		[Version (since = "0.3.0-beta")]
		public Gpseq.Result<G> ok ();
		/**
		 * Ensures this result holds the expected value.
		 *
		 * If this holds an error or a not expected value, fails with
		 * {@link GLib.error}. Otherwise, returns this.
		 *
		 * ''{@link Future} implementation:'' Waits until the future is
		 * completed if not yet completed.
		 *
		 * @param expected an expected value
		 * @param equal an equal function. if not specified,
		 * {@link Gee.Functions.get_equal_func_for} is used to get a proper
		 * function
		 * @return this result if it holds the expected value
		 */
		[Version (since = "0.3.0-beta")]
		public Gpseq.Result<G> ok_with (G expected, owned Gee.EqualDataFunc? equal = null);
		/**
		 * Runs the function with this result.
		 *
		 * @param func a function called
		 * @return the result
		 */
		public virtual Gpseq.Result<G> then (owned GLib.Func<Gpseq.Result<G>> func);
		/**
		 * Creates a new result by applying the given function to this result.
		 *
		 * The returned object of the function may or may not be directly used.
		 * Depending on the internal implementation, A new result object will
		 * be created with the value or exception of it and returned, instead
		 * of returning it directly.
		 *
		 * ''{@link Future} implementation:'' Creates a new future by applying
		 * the given function to this future, ''in future'' -- when this future
		 * is completed.
		 *
		 * ''{@link Future} implementation:'' If the function returns not a
		 * Future but a Result, the result is mapped to a future.
		 *
		 * @param func a function applied to this result
		 * @return the new result (''{@link Future} implementation:''
		 * [Future<A>] the new future)
		 */
		public abstract Gpseq.Result<A> transform<A> (owned Gpseq.Result.TransformFunc<A,G> func);
		/**
		 * Combines the values of two results using the given function.
		 *
		 * If two results hold or the function throws an exception, the
		 * returned result holds the exception.
		 *
		 * @param zip_func a function applied to values
		 * @param second another result
		 * @return the combined result
		 */
		public virtual Gpseq.Result<B> zip<A,B> (owned Gpseq.Result.ZipFunc<G,A,B> zip_func, Gpseq.Result<A> second);
		/**
		 * The error of this result, or null if the result is a succeeded
		 * result.
		 *
		 * ''{@link Future} implementation:'' If the future is not yet
		 * completed, getting exception will block until the future is
		 * completed.
		 */
		public GLib.Error? exception { owned get; }
		/**
		 * Whether or not this result holds an error.
		 *
		 * ''{@link Future} implementation:'' If the future is not yet
		 * completed, getting will block until the future is completed.
		 */
		public bool is_err { get; }
		/**
		 * The value of this result.
		 *
		 * If the result is a failed result, the getting value fails with
		 * {@link GLib.error}.
		 *
		 * ''{@link Future} implementation:'' If value is not ready, getting
		 * value will block until value is ready.
		 */
		public G value { get; }
		public GLib.Type value_type { get; }
	}
	/**
	 * The sender side of a channel.
	 *
	 * @see Channel
	 * @see Receiver
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.3.0-alpha")]
	public interface Sender<G> : Gpseq.ChannelBase {
		/**
		 * Sends a value into the channel. This method blocks the thread until
		 * the value is sent or the channel is closed.
		 *
		 * If the channel is full, not unbuffered, and not closed, blocks until
		 * the channel has a space to hold the value.
		 *
		 * If the channel is unbuffered, waits for a receive operation.
		 *
		 * Errors:
		 *
		 *  * ChannelError.CLOSED
		 *
		 * If the channel has been closed.
		 *
		 * @param data a value
		 * @return the result which holds null if succeeded, or an error if
		 * failed.
		 */
		public abstract Gpseq.Result<void*> send (owned G data);
		/**
		 * Sends a value into the channel. This method blocks the thread until
		 * the value is sent, the channel is closed, or //end_time// has passed.
		 *
		 * This method is the same as {@link send} except there is a timeout.
		 *
		 * Errors:
		 *
		 *  * ChannelError.CLOSED
		 *
		 * If the channel has been closed.
		 *
		 *  * ChannelError.TIMEOUT
		 *
		 * If //end_time// has passed.
		 *
		 * @param data a value
		 * @param end_time the monotonic time to wait until
		 * @return the result which holds null if succeeded, or an error if
		 * failed.
		 */
		public abstract Gpseq.Result<void*> send_until (owned G data, int64 end_time);
		/**
		 * Attempts to send a value into the channel. This method doesn't block
		 * the thread and returns immediately, regardless of success.
		 *
		 * Errors:
		 *
		 *  * ChannelError.CLOSED
		 *
		 * If the channel has been closed.
		 *
		 *  * ChannelError.TRY_FAILED
		 *
		 * If the channel is full (bufferd channel), or there are no receive
		 * operations waiting for send operations (unbuffered channel).
		 *
		 * @param data a value
		 * @return the result which holds null if succeeded, or an error if
		 * failed.
		 */
		public abstract Gpseq.Result<void*> try_send (owned G data);
	}
	/**
	 * An object for traversing and partitioning elements of a data source.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[GenericAccessors]
	public interface Spliterator<G> : GLib.Object {
		/**
		 * Applies the given function to each of the remaining elements.
		 *
		 * The function is performed in encounter order, if the data source has
		 * an encounter order.
		 *
		 * This method would be more optimized than manual {@link try_advance}
		 * calls.
		 */
		public virtual void each (Gpseq.Func<G> f) throws GLib.Error;
		/**
		 * Applies the given function to each chunk of the remaining elements,
		 * until last chunk or function returns false.
		 *
		 * The function is performed in encounter order, if the data source has
		 * an encounter order.
		 *
		 * The chunks given to the function are always non-empty.
		 *
		 * This method would be more optimized than manual {@link try_advance}
		 * calls.
		 *
		 * @return false if the argument returned false at last invocation and
		 * true otherwise.
		 */
		public virtual bool each_chunk (Gpseq.EachChunkFunc<G> f) throws GLib.Error;
		/**
		 * Creates a new empty spliterator.
		 * @return a new empty spliterator
		 */
		public static Gpseq.Spliterator<G> empty<G> ();
		/**
		 * If a remaining element exists, performs the given consumer function
		 * on it, advances to the next element if remaining, and returns true.
		 * otherwise returns false.
		 *
		 * The function is performed on the next element in encounter order, if
		 * the data source has an encounter order.
		 *
		 * @return false if no remaining elements existed, true otherwise.
		 */
		public abstract bool try_advance (Gpseq.Func<G> consumer) throws GLib.Error;
		/**
		 * If this spliterator can be partitioned, returns a spliterator
		 * covering some elements that will not be covered by this spliterator.
		 * otherwise, returns null.
		 *
		 * The returned spliterator must cover a prefix of the elements if
		 * the data source has an encounter order.
		 *
		 * The returned spliterator could not 'own' its elements.
		 * (no 'ownership'; i.e. unowned)
		 *
		 * This method may return null for any reason, including emptiness, data
		 * structure constraints, and efficiency considerations.
		 *
		 * Note. An ideal efficient work of //try_split// method is dividing
		 * its elements exactly in half.
		 *
		 * @return a partition of this spliterator.
		 */
		public abstract Gpseq.Spliterator<G>? try_split ();
		/**
		 * The type of the elements in this spliterator.
		 */
		public GLib.Type element_type { get; }
		/**
		 * The estimated size of the remaining elements. it is negative if
		 * infinite, unknown, or can't be estimated for any reason.
		 *
		 * If {@link is_size_known} is true, this estimate is an accurate size.
		 */
		public abstract int64 estimated_size { get; }
		/**
		 * Whether or not the accurate size of this spliterator is known.
		 *
		 * If this is true, {@link estimated_size} returns an accurate size.
		 *
		 * This value always could be changed false -> true when status changed,
		 * but not vice versa.
		 *
		 * Note. //is_size_known && estimated_size < 0// is possible. (e.g.
		 * an infinite spliterator)
		 */
		public abstract bool is_size_known { get; }
	}
	/**
	 * An object that supplies results.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public interface Supplier<G> : GLib.Object {
		/**
		 * Creates a new supplier from the given supply function.
		 * @param func a supply function
		 * @return a new supplier from the given supply function
		 */
		public static Gpseq.Supplier<G> from_func<G> (owned Gpseq.SupplyFunc<G> func);
		/**
		 * Supplies a result.
		 * @return a result
		 */
		public abstract G supply ();
	}
	/**
	 * A task that will be executed by a {@link Executor}.
	 *
	 * Note. Tasks are not reusable.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public interface Task<G> : GLib.Object {
		/**
		 * Computes the task and sets a value or an error to the
		 * {@link Task.future}.
		 */
		public abstract void compute ();
		/**
		 * Immediately performs the task computation.
		 *
		 * @throws Error an error occurred in the {@link future}
		 */
		public void invoke () throws GLib.Error;
		/**
		 * The future result of this task.
		 */
		public abstract Gpseq.Future<G> future { get; }
	}
	/**
	 * An object that creates new worker threads.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public interface ThreadFactory : GLib.Object {
		/**
		 * @param pool a worker thread pool
		 * @return a new thread that has not yet started
		 */
		public abstract Gpseq.WorkerThread create_thread (Gpseq.WorkerPool pool);
	}
	[CCode (cheader_filename = "gpseq.h", cname = "GpseqCacheLinePad", has_type_id = false)]
	[Version (since = "0.3.0-alpha")]
	public struct CacheLinePad {
	}
	/**
	 * Hints that can be used to optimize collect operations.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Flags]
	public enum CollectorFeatures {
		/**
		 * Indicates that the accumulator returned by create_accumulator() can
		 * be accumulated concurrently from multiple threads.
		 */
		CONCURRENT,
		/**
		 * Indicates that the collector doesn't commit to preserving the
		 * encounter order of input elements. e.g. Set
		 */
		UNORDERED
	}
	[CCode (cheader_filename = "gpseq.h")]
	public errordomain ChannelError {
		CLOSED,
		TIMEOUT,
		TRY_FAILED
	}
	[CCode (cheader_filename = "gpseq.h")]
	public errordomain MapError {
		DUPLICATE_KEY
	}
	[CCode (cheader_filename = "gpseq.h")]
	public errordomain OptionalError {
		NOT_PRESENT
	}
	/**
	 * Combines two values and returns the result.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public delegate G CombineFunc<G> (owned G a, owned G b) throws GLib.Error;
	[CCode (cheader_filename = "gpseq.h")]
	public delegate bool EachChunkFunc<G> (G[] chunk) throws GLib.Error;
	[CCode (cheader_filename = "gpseq.h")]
	public delegate Gee.Iterator<A> FlatMapFunc<A,G> (owned G g) throws GLib.Error;
	[CCode (cheader_filename = "gpseq.h")]
	public delegate A FoldFunc<A,G> (owned G g, owned A a) throws GLib.Error;
	[CCode (cheader_filename = "gpseq.h")]
	public delegate void Func<G> (G g) throws GLib.Error;
	[CCode (cheader_filename = "gpseq.h")]
	public delegate A MapFunc<A,G> (owned G g) throws GLib.Error;
	[CCode (cheader_filename = "gpseq.h")]
	public delegate bool Predicate<G> (G g) throws GLib.Error;
	/**
	 * A delegate that supplies results.
	 * @return a result
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public delegate G SupplyFunc<G> ();
	[CCode (cheader_filename = "gpseq.h")]
	public delegate G TaskFunc<G> () throws GLib.Error;
	/**
	 * Merges the given results and returns the final result.
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public delegate A TeeMergeFunc<A> (GLib.Object[] results) throws GLib.Error;
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.2.0-alpha")]
	public delegate void VoidFunc ();
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.2.0-alpha")]
	public delegate void VoidTaskFunc () throws GLib.Error;
	/**
	 * Atomically adds //val// to the value of //atomic//.
	 *
	 * Think of this operation as an atomic version of:
	 *
	 * {{{
	 *   { tmp = *atomic; *atomic += val; return tmp; }
	 * }}}
	 *
	 * This call acts as a full compiler and hardware memory barrier.
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @param val the value to add
	 * @return the value of //atomic// before the add, signed
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_add")]
	public static int64 atomic_int64_add ([CCode (type = "volatile gint64 *")] ref int64 atomic, int64 val);
	/**
	 * Performs an atomic bitwise 'and' of the value of //atomic// and //val//,
	 * storing the result back in //atomic//.
	 *
	 * This call acts as a full compiler and hardware memory barrier.
	 *
	 * Think of this operation as an atomic version of:
	 *
	 * {{{
	 *   { tmp = *atomic; *atomic &= val; return tmp; }
	 * }}}
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @param val the value to 'and'
	 * @return the value of //atomic// before the operation, unsigned
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_and")]
	public static uint64 atomic_int64_and ([CCode (type = "volatile guint64 *")] ref uint64 atomic, uint64 val);
	/**
	 * Compares //atomic// to //oldval// and, if equal, sets it to //newval//.
	 * If //atomic// was not equal to //oldval// then no change occurs.
	 *
	 * This compare and exchange is done atomically.
	 *
	 * Think of this operation as an atomic version of:
	 *
	 * {{{
	 *   { if (*atomic == oldval) { *atomic = newval; return TRUE; } else return FALSE; }
	 * }}}
	 *
	 * This call acts as a full compiler and hardware memory barrier.
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @param oldval the value to compare with
	 * @param newval the value to conditionally replace with
	 * @return %TRUE if the exchange took place
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_compare_and_exchange")]
	public static bool atomic_int64_compare_and_exchange ([CCode (type = "volatile gint64 *")] ref int64 atomic, int64 oldval, int64 newval);
	/**
	 * Decrements the value of //atomic// by 1.
	 *
	 * Think of this operation as an atomic version of:
	 *
	 * {{{
	 *   { *atomic -= 1; return (*atomic == 0); }
	 * }}}
	 *
	 * This call acts as a full compiler and hardware memory barrier.
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @return %TRUE if the resultant value is zero
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_dec_and_test")]
	public static bool atomic_int64_dec_and_test ([CCode (type = "volatile gint64 *")] ref int64 atomic);
	/**
	 * Gets the current value of //atomic//.
	 *
	 * This call acts as a full compiler and hardware
	 * memory barrier (before the get).
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @return the value of the integer
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_get")]
	public static int64 atomic_int64_get ([CCode (type = "volatile gint64 *")] ref int64 atomic);
	/**
	 * Increments the value of //atomic// by 1.
	 *
	 * Think of this operation as an atomic version of:
	 *
	 * {{{
	 *   { *atomic += 1; }
	 * }}}
	 *
	 * This call acts as a full compiler and hardware memory barrier.
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_inc")]
	public static void atomic_int64_inc ([CCode (type = "volatile gint64 *")] ref int64 atomic);
	/**
	 * Performs an atomic bitwise 'or' of the value of //atomic// and //val//,
	 * storing the result back in //atomic//.
	 *
	 * Think of this operation as an atomic version of:
	 *
	 * {{{
	 *   { tmp = *atomic; *atomic |= val; return tmp; }
	 * }}}
	 *
	 * This call acts as a full compiler and hardware memory barrier.
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @param val the value to 'or'
	 * @return the value of //atomic// before the operation, unsigned
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_or")]
	public static uint64 atomic_int64_or ([CCode (type = "volatile guint64 *")] ref uint64 atomic, uint64 val);
	/**
	 * Sets the value of //atomic// to //newval//.
	 *
	 * This call acts as a full compiler and hardware
	 * memory barrier (after the set).
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @param newval a new value to store
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_set")]
	public static void atomic_int64_set ([CCode (type = "volatile gint64 *")] ref int64 atomic, int64 newval);
	/**
	 * Performs an atomic bitwise 'xor' of the value of //atomic// and //val//,
	 * storing the result back in //atomic//.
	 *
	 * Think of this operation as an atomic version of:
	 *
	 * {{{
	 *   { tmp = *atomic; *atomic ^= val; return tmp; }
	 * }}}
	 *
	 * This call acts as a full compiler and hardware memory barrier.
	 *
	 * @param atomic a pointer to a {@link int64} or {@link uint64}
	 * @param val the value to 'xor'
	 * @return the value of //atomic// before the operation, unsigned
	 **/
	[CCode (cheader_filename = "gpseq.h", cname = "gpseq_atomic_int64_xor")]
	public static uint64 atomic_int64_xor ([CCode (type = "volatile guint64 *")] ref uint64 atomic, uint64 val);
	/**
	 * Runs the given blocking task.
	 *
	 * If the current thread is not a {@link WorkerThread}, this method just
	 * runs the task without any further work. Otherwise, this method tries to
	 * create a new thread.
	 *
	 * -> If succeed, the new thread takes the context of this thread and
	 * runs the remaining tasks in the context. This thread runs the
	 * blocking task and is marked as //blocked// until the task ends.
	 * After it ends, this thread is unblocked and takes the context back,
	 * and the new thread is terminated.
	 *
	 * -> If failed, e.g. the maximum number of threads exceeded, this
	 * method just runs the function without any further work.
	 *
	 * @param func a task function
	 *
	 * @throws Error the error thrown by the function
	 *
	 * @see Gpseq.blocking_get
	 * @see WorkerThread.blocking
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.2.0-alpha")]
	public static void blocking (Gpseq.VoidTaskFunc func) throws GLib.Error;
	/**
	 * Runs the given blocking task and returns the result.
	 *
	 * If the current thread is not a {@link WorkerThread}, this method just
	 * runs the task without any further work. Otherwise, this method tries to
	 * create a new thread.
	 *
	 * -> If succeed, the new thread takes the context of this thread and
	 * runs the remaining tasks in the context. This thread runs the
	 * blocking task and is marked as //blocked// until the task ends.
	 * After it ends, this thread is unblocked and takes the context back,
	 * and the new thread is terminated.
	 *
	 * -> If failed, e.g. the maximum number of threads exceeded, this
	 * method just runs the function without any further work.
	 *
	 * @param func a task function
	 * @return the result produced by the function
	 *
	 * @throws Error the error thrown by the function
	 *
	 * @see Gpseq.blocking
	 * @see WorkerThread.blocking
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.2.0-alpha")]
	public static G blocking_get<G> (Gpseq.TaskFunc<G> func) throws GLib.Error;
	/**
	 * Runs the subtasks and returns the results.
	 *
	 * Submits the left task to the executor first, runs the right task in
	 * the current thread, and waits for them to complete.
	 *
	 * This method uses the executor of the common task env.
	 *
	 * {{{
	 * int fibonacci (int n) {
	 *     if (n <= 1) {
	 *         return n;
	 *     } else {
	 *         // Note. Not 'int' but 'int?' (boxed value type)
	 *         var (left, right) = join<int?>( () => fibonacci(n-1),
	 *                                         () => fibonacci(n-2) );
	 *         return left + right;
	 *     }
	 * }
	 * }}}
	 *
	 * @param left the left task
	 * @param right the right task
	 * @return (left-result, right-result) An array containing the two results.
	 *
	 * @throws Error the error thrown by the subtasks
	 *
	 * @see ForkJoinTask
	 * @see SpliteratorTask
	 * @see TaskEnv.get_common_task_env
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.3.0-alpha")]
	public static G[] join<G> (owned Gpseq.TaskFunc<G> left, owned Gpseq.TaskFunc<G> right) throws GLib.Error;
	/**
	 * Sorts the given array by comparing with the specified compare function,
	 * in parallel. The sort is stable.
	 *
	 * Note. With nullable primitive types, this method produces an undesirable
	 * result if the compare function is not specified. you should provide
	 * specified compare function to get a proper result.
	 *
	 * {{{
	 * int?[] array = {5, 4, 3, 2, 1};
	 * parallel_sort<int?>(array).wait();
	 * // => the result is undesirable, such as 5, 2, 1, 3, 4
	 *
	 * int?[] array2 = {5, 4, 3, 2, 1};
	 * parallel_sort<int?>(array2, (a, b) => {
	 *     if (a == null) return -1;
	 *     else if (b == null) return 1;
	 *     else return a < b ? -1 : (a == b ? 0 : 1);
	 * }).wait();
	 * // => the result is 1, 2, 3, 4, 5
	 * }}}
	 *
	 * @param array a gpointer array to be sorted
	 * @param compare compare function to compare elements. if it is not
	 * specified, the result of {@link Gee.Functions.get_compare_func_for} is
	 * used
	 * @return a future which will be completed with a null value if the sort
	 * succeeds, or with an exception if the sort fails because an error is
	 * thrown from the compare function
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public static Gpseq.Future<void*> parallel_sort<G> (G[] array, owned GLib.CompareDataFunc<G>? compare = null);
	/**
	 * Schedules the given function to execute asynchronously.
	 *
	 * The {@link Executor} of {@link TaskEnv.get_common_task_env} will execute
	 * the function. By default, it is a {@link WorkerPool} which uses
	 * work-stealing algorithm.
	 *
	 * This method is the same as {@link task} but this accepts a
	 * {@link VoidTaskFunc} which has void return type.
	 *
	 * @param func a task function to execute
	 * @return a future of the execution
	 *
	 * @see WorkerPool
	 * @see FuncTask
	 */
	[CCode (cheader_filename = "gpseq.h")]
	[Version (since = "0.3.0-beta")]
	public static Gpseq.Future<void*> run (owned Gpseq.VoidTaskFunc func);
	/**
	 * Schedules the given function to execute asynchronously.
	 *
	 * The {@link Executor} of {@link TaskEnv.get_common_task_env} will execute
	 * the function. By default, it is a {@link WorkerPool} which uses
	 * work-stealing algorithm.
	 *
	 * @param func a task function to execute
	 * @return a future of the execution
	 *
	 * @see WorkerPool
	 * @see FuncTask
	 */
	[CCode (cheader_filename = "gpseq.h")]
	public static Gpseq.Future<G> task<G> (owned Gpseq.TaskFunc<G> func);
}
