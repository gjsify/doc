/* gxml-0.10.vapi generated by valac 0.28.1, do not modify. */

/**
 * The XML Document Object Model.
 *
 * GXml provides a DOM Level 1 Core API in a GObject framework.
 */
[CCode (gir_namespace = "GXml", gir_version = "0.10")]
namespace GXml {
	/**
	 * An abstract class used as base class for {@link GXml.NamedAttrMap} class.
	 * 
	 * This is just an auxiliary class to implement {@link Gee.Traversable}
	 * {@link Gee.Iterable} interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class AbstractNamedAttrMap : GLib.Object, Gee.Traversable<GXml.AbstractNamedAttrMap.Entry<string,GXml.Attribute>>, Gee.Iterable<GXml.AbstractNamedAttrMap.Entry<string,GXml.Attribute>> {
		public class Entry : Gee.Map.Entry<string,GXml.Attribute> {
			public Entry (string k, GXml.Attribute v);
			public override string key { get; }
			public override bool read_only { get; }
			public override GXml.Attribute value { get; set; }
		}
		protected class Iterator : GLib.Object, Gee.Traversable<GXml.AbstractNamedAttrMap.Entry>, Gee.Iterator<GXml.AbstractNamedAttrMap.Entry> {
			protected Xml.Attr* cur;
			protected GXml.AbstractNamedAttrMap nm;
			public Iterator (GXml.AbstractNamedAttrMap nm);
		}
		protected GXml.xElement elem;
	}
	/**
	 * An internal class for nodes whose content is stored in a
	 * corresponding Xml.Node.
	 * 
	 * This would normally be hidden, but Vala wants base classes
	 * to be at least as public as subclasses.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class BackedNode : GXml.xNode {
		/**
		 * {@inheritDoc}
		 */
		public override GXml.NamespaceAttr? add_namespace_attr (string uri, string? namespace_prefix);
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? append_child (GXml.xNode new_child);
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? clone_node (bool deep);
		/**
		 * {@inheritDoc}
		 */
		public override bool has_child_nodes ();
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? insert_before (GXml.xNode new_child, GXml.xNode? ref_child);
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? remove_child (GXml.xNode old_child);
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? replace_child (GXml.xNode new_child, GXml.xNode old_child);
		/**
		 * {@inheritDoc}
		 */
		public override bool set_namespace (string uri, string? namespace_prefix);
		public override string stringify (bool format = true, int level = 0);
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNodeList? child_nodes { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNode? first_child { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNode? last_child { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? local_name { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override Gee.List<GXml.Namespace>? namespace_definitions { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? namespace_prefix { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? namespace_uri { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNode? next_sibling { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string node_name { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override GXml.NodeType node_type { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? node_value { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNode? parent_node { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNode? previous_sibling { get; internal set; }
	}
	/**
	 * An partial portion of a {@link GXml.xDocument}, not necessarily valid XML.
	 *
	 * To create one, use {@link GXml.xDocument.create_document_fragment}.
	 *
	 * This does not need to have a root document element,
	 * or being completely valid. It can have multiple children,
	 * which, if the DocumentFragment is inserted as a child to
	 * another node, become that nodes' children, without the
	 * DocumentFragment itself existing as a child.
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-B63ED1A3]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DocumentFragment : GXml.BackedNode {
	}
	/**
	 * Convenient class for a list of {@link GXml.Element} objects based on
	 * {@link Gee.ListArray}, with good support for bindings.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class ElementList : Gee.ArrayList<GXml.Element> {
		public ElementList ();
		public new GXml.Element @get (int index);
		public new GXml.Element[] to_array ();
	}
	/**
	 * The content referenced by an {@link GXml.EntityReference}, and defined
	 * in a {@link GXml.DocumentType}.
	 *
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-527DCFF2]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Entity : GXml.xNode {
		public override unowned GXml.xNode? append_child (GXml.xNode new_child);
		public override unowned GXml.xNode? clone_node (bool deep);
		public override bool has_child_nodes ();
		public override unowned GXml.xNode? insert_before (GXml.xNode new_child, GXml.xNode? ref_child);
		public override unowned GXml.xNode? remove_child (GXml.xNode old_child);
		public override unowned GXml.xNode? replace_child (GXml.xNode new_child, GXml.xNode old_child);
		public override GXml.xNodeList? child_nodes { get; internal set; }
		public override string node_name { get; internal set; }
		/**
		 * The notation name for this entity if it is
		 * unparsed. This is %NULL if the entity is parsed.
		 */
		public string notation_name { get; private set; }
		public override GXml.xNode? parent_node { get; internal set; }
		/**
		 * A public identifier for the entity. %NULL when unspecified.
		 */
		public string public_id { get; private set; }
		/**
		 * A system identifier for the entity. %NULL when unspecified.
		 */
		public string system_id { get; private set; }
	}
	/**
	 * A reference to an unparsed {@link GXml.Entity}, like "&apos;" for an apostrophe.
	 * 
	 * To create one, use {@link GXml.xDocument.create_entity_reference}.
	 * 
	 * The entity name, e.g. "apos", is stored as the EntityReference's `node_name`.
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-11C98490]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class EntityReference : GXml.xNode {
		/**
		 * Stores the reference entity's name ("apos" for &apos;).
		 */
		public override string node_name { get; private set; }
	}
	/**
	 * Convenient static methods for enumeration serialization to string.
	 * 
	 * Enumerations have a set of utility methods to better represent on
	 * serialisation/deserialization.
	 * 
	 * Enumerations could be converted to string using its definition on {@link GLib.EnumClass},
	 * by taking its nick name directly or converting to its camel case representation.
	 * 
	 * Any enumeration value type in a <code>GLib.Object</code>'s property could be
	 * deserialized from its definition given on {@link GLib.EnumClass} (name and
	 * nick) or from its camel case representation.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Enumeration {
		public Enumeration ();
		/**
		 * Introspect an enumeration to get value's nick name.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @enumeration.
		 */
		public static string get_nick (GLib.Type enumeration, int val) throws GLib.Error;
		/**
		 * Introspect an enumeration to get value's nick name and transform
		 * to camel case representation.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @param enumeration.
		 */
		public static string get_nick_camelcase (GLib.Type enumeration, int val) throws GLib.Error;
		/**
		 * Transform enumeration's value to its string representation.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @enumeration.
		 * @param use_nick makes to returns value's nick name in {@link GLib.EnumClass}
		 * @param camelcase makes to returns value's nick name in {@link GLib.EnumClass}
		 * as camel case representation. If @use_nick is set this take no effect.
		 */
		public static string get_string (GLib.Type enumeration, int val, bool use_nick = false, bool camelcase = false) throws GLib.Error;
		/**
		 * Parse @val to an enumeration's value.
		 * 
		 * Returns: an {@link GLib.EnumValue} representing an enumeration's value.
		 * 
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val a string to parse an enum value of type @param enumeration.
		 * as camel case representation. If @use_nick is set this take no effect.
		 */
		public static GLib.EnumValue? parse (GLib.Type enumeration, string val) throws GLib.Error;
		/**
		 * From a integer valuer calculates a valid {@link GLib.EnumValue} for a
		 * {@link GLib.Type}. 
		 *
		 * Returns: a {@link GLib.EnumValue} or null if fails.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer in a valid range in the enumeration.
		 */
		public static GLib.EnumValue? parse_integer (GLib.Type enumeration, int val);
		/**
		 * Transform an enumeration in an array of {@link GLib.EnumValue}.
		 * 
		 * Returns: an array of {@link GLib.EnumValue} representing an enumeration.
		 * 
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 */
		public static unowned GLib.EnumValue[] to_array (GLib.Type enumeration);
		/**
		 * Transform an enumeration in an array of strings representing enumeration values.
		 *
		 * Returns: an array of strings representing an enumeration.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 */
		public static string[] to_string_array (GLib.Type enumeration) throws GLib.Error;
	}
	/**
	 * Class implemeting {@link GXml.Attribute} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GAttribute : GXml.GNode, GXml.Attribute {
		public GAttribute (GXml.GDocument doc, Xml.Attr* node);
		public override string name { owned get; }
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
		public override GXml.Node parent { owned get; }
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.CDATA} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GCDATA : GXml.GNode, GXml.CDATA {
		public GCDATA (GXml.GDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.Comment} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GComment : GXml.GNode, GXml.Comment {
		public GComment (GXml.GDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.Document} interface, not tied to libxml-2.0 library.
	 *
	 * This class use {@link Xml.TextWriter} to write down XML documents using
	 * its contained {@link GXml.Node} childs or other XML structures.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GDocument : GXml.GNode, GXml.Document {
		protected Xml.Buffer _buffer;
		protected Xml.Doc* doc;
		public GDocument ();
		public GDocument.from_doc (Xml.Doc doc);
		public GDocument.from_file (GLib.File file, int options = 0, GLib.Cancellable? cancel = null) throws GLib.Error;
		public GDocument.from_path (string path, int options = 0) throws GLib.Error;
		public GDocument.from_stream (GLib.InputStream istream) throws GLib.Error;
		public GDocument.from_string (string str, int options = 0) throws GLib.Error;
		public GDocument.from_uri (string uri, int options = 0) throws GLib.Error;
		/**
		 * Uses libxml2 internal dump to memory function over owned 
		 */
		public string libxml_to_string ();
		public virtual bool save (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual bool save_as (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override bool set_namespace (string uri, string? prefix);
		public override string to_string ();
		public override Gee.Map<string,GXml.Node> attrs { owned get; }
		public override Gee.BidirList<GXml.Node> children { owned get; }
		public override GXml.Document document { get; }
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.Element} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GElement : GXml.GNode, GXml.Element {
		public GElement (GXml.GDocument doc, Xml.Node* node);
		public override string to_string ();
		public override string value { owned get; set; }
	}
	/**
	 * Implementation of {@link Gee.AbstractMap} to handle {@link Xml.Node} attributes
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GHashMapAttr : Gee.AbstractMap<string,GXml.Node> {
		public class Entry : Gee.Map.Entry<string,GXml.Node> {
			public Entry (GXml.GDocument doc, Xml.Attr* attr);
			public override string key { get; }
			public override bool read_only { get; }
			public override GXml.Node value { get; set; }
		}
		public class Iterator : GLib.Object, Gee.MapIterator<string,GXml.Node> {
			public Iterator (GXml.GDocument doc, Xml.Node* node);
		}
		public GHashMapAttr (GXml.GDocument doc, Xml.Node* node);
		public override void clear ();
		public override GXml.Node @get (string key);
		public override bool has (string key, GXml.Node value);
		public override bool has_key (string key);
		public override Gee.MapIterator<string,GXml.Node> map_iterator ();
		public override void @set (string key, GXml.Node value);
		public override bool unset (string key, out GXml.Node value = null);
		public override Gee.Set<Gee.Map.Entry<string,GXml.Node>> entries { owned get; }
		public override Gee.Set<string> keys { owned get; }
		public override bool read_only { get; }
		public override int size { get; }
		public override Gee.Collection<GXml.Node> values { owned get; }
	}
	/**
	 * A {@link Gee.AbstractBidirList} implementation to access {@link Xml.Node} collection
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GListChildren : Gee.AbstractBidirList<GXml.Node> {
		public class Iterator : GLib.Object, Gee.Traversable<GXml.Node>, Gee.Iterator<GXml.Node>, Gee.BidirIterator<GXml.Node>, Gee.ListIterator<GXml.Node>, Gee.BidirListIterator<GXml.Node> {
			public Iterator (GXml.GDocument doc, Xml.Node* node);
		}
		public GListChildren (GXml.GDocument doc, Xml.Node* node);
		public override bool add (GXml.Node item);
		public override new Gee.BidirListIterator<GXml.Node> bidir_list_iterator ();
		public override void clear ();
		public override bool contains (GXml.Node item);
		public override GXml.Node @get (int index);
		public override int index_of (GXml.Node item);
		/**
		 * This method is ignored by default.
		 */
		public override void insert (int index, GXml.Node item);
		public override Gee.Iterator<GXml.Node> iterator ();
		public override Gee.ListIterator<GXml.Node> list_iterator ();
		public override bool remove (GXml.Node item);
		/**
		 * This method is ignored by default.
		 */
		public override GXml.Node remove_at (int index);
		/**
		 * This method is ignored by default.
		 */
		public override void @set (int index, GXml.Node item);
		public override Gee.List<GXml.Node>? slice (int start, int stop);
		public override bool read_only { get; }
		public override int size { get; }
	}
	/**
	 * A {@link Gee.AbstractList} implementation to access {@link Xml.Ns} namespaces collection
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GListNamespaces : Gee.AbstractList<GXml.Node> {
		public class Iterator : GLib.Object, Gee.Traversable<GXml.Node>, Gee.Iterator<GXml.Node>, Gee.ListIterator<GXml.Node> {
			public Iterator (Xml.Node* node);
		}
		public GListNamespaces (GXml.GDocument doc, Xml.Node* node);
		public override bool add (GXml.Node item);
		public override void clear ();
		public override bool contains (GXml.Node item);
		public override new GXml.Node @get (int index);
		public override int index_of (GXml.Node item);
		public override void insert (int index, GXml.Node item);
		public override Gee.Iterator<GXml.Node> iterator ();
		public override Gee.ListIterator<GXml.Node> list_iterator ();
		public override bool remove (GXml.Node item);
		public override GXml.Node remove_at (int index);
		public override new void @set (int index, GXml.Node item);
		public override Gee.List<GXml.Node>? slice (int start, int stop);
		public override bool read_only { get; }
		public override int size { get; }
	}
	/**
	 * Class implemeting {@link GXml.Namespace}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GNamespace : GXml.GNode, GXml.Namespace {
		public GNamespace (Xml.Ns* ns);
		public Xml.Ns* get_internal_ns ();
	}
	/**
	 * Base interface providing basic functionalities to all GXml interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class GNode : GLib.Object, GXml.Node {
		protected GXml.GDocument _doc;
		protected Xml.Node* _node;
		public GNode ();
		public Xml.Node* get_internal_node ();
		public virtual bool set_namespace (string uri, string? prefix);
		public static GXml.Node to_gnode (GXml.GDocument doc, Xml.Node* node);
		public virtual string to_string ();
		public virtual Gee.Map<string,GXml.Node> attrs { owned get; }
		public virtual Gee.BidirList<GXml.Node> children { owned get; }
		public virtual GXml.Document document { get; }
		public virtual string name { owned get; }
		public virtual Gee.List<GXml.Namespace> namespaces { owned get; }
		public virtual GXml.Node parent { owned get; }
		public virtual GXml.NodeType type_node { get; }
		public virtual string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.ProcessingInstruction} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GProcessingInstruction : GXml.GNode, GXml.ProcessingInstruction {
		public GProcessingInstruction (GXml.GDocument doc, Xml.Node* node);
	}
	/**
	 * Class implemeting {@link GXml.Text} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class GText : GXml.GNode, GXml.Text {
		public GText (GXml.GDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	/**
	 * HML parsing suport. Document handling
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HtmlDocument : GXml.xDocument {
		public HtmlDocument ();
		public HtmlDocument.from_file (GLib.File file, int options = 0, GLib.Cancellable? cancel = null) throws GLib.Error;
		public HtmlDocument.from_path (string path, int options = 0) throws GLib.Error;
		public HtmlDocument.from_string (string html, int options = 0);
		public HtmlDocument.from_uri (string uri, int options = 0) throws GLib.Error;
		/**
		 * Get first node where 'id' attribute has given value.
		 */
		public GXml.Element? get_element_by_id (string id);
		/**
		 * Search all {@link GXml.Element} with a property called "class" and with a
		 * value as a class apply to a node.
		 */
		public GXml.ElementList get_elements_by_class_name (string klass);
		public static int default_options { get; }
	}
	/**
	 * Describes the features available in this
	 * implementation of the DOM.
	 *
	 * This can be accessed from a {@link GXml.xDocument}
	 * object. Provided a possible feature and the feature's
	 * version, it can tell the client whether it is here
	 * implemented.
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Implementation : GLib.Object {
		/**
		 * Creates a xDocument according to this {@link GXml.Implementation}.
		 *
		 * Version: DOM Level 3 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument]]
		 
		 * @param namespace_uri URI for the namespace in which this xDocument belongs, or %NULL
		 * @param qualified_name A qualified name for the xDocument, or %NULL
		 * @param doctype The type of the document, or %NULL
		 *
		 * @return The new document
		 */
		public GXml.xDocument create_document (string? namespace_uri, string? qualified_name, GXml.xDocumentType? doctype);
		/**
		 * Reports whether we support a feature at a given version level.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-hasFeature]]
		 *
		 * TODO: implement more of this, using libxml2's parser.h's xmlGetFeature, xmlHasFeature, etc.
		 *
		 * @param feature A feature we might support, usually something like 'xml' or 'html'
		 * @param version A possible version of the feature, or %NULL if any version will do
		 *
		 * @return true if we support the specified feature, false otherwise
		 */
		public bool has_feature (string feature, string? version = null);
	}
	/**
	 * A class implementing {@link GXml.NamedNodeMap} interface for {@link GXml.xAttr} objects.
	 * 
	 * A collection of {@link GXml.NamedNodeMap} of type {@link GXml.xAttr} objects in a {@link GXml.xElement}.
	 *
	 * This class implements {@link Gee.Map}, but requires parent {@link GXml.AbstractNamedAttrMap} class
	 * in order to implement it.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NamedAttrMap : GXml.AbstractNamedAttrMap, Gee.Map<string,GXml.Attribute>, GXml.NamedNodeMap<GXml.xAttr?> {
		public bool contains (string key);
		public bool contains_all (Gee.Map<string,GXml.Attribute> map);
		public bool remove (string key, out GXml.Attribute val = null);
		public bool remove_all (Gee.Map<string,GXml.Attribute> map);
	}
	/**
	 * Represents an XML Namespace for a {@link GXml.Node} node.
	 *
	 * These represent
	 * prefix=uri pairs that define namespaces for XML {@link GXml.xElement}
	 * and {@link GXml.xAttr}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NamespaceAttr : GXml.xNode, GXml.Namespace {
		/**
		 * The namespace uri that this xmlns attribute defines. So,
		 * if the element was like {{{&lt;Fish xmlns:foods="http://fishies.org/foods" />}}}, the
		 * defined namespace uri would be [[http://fishies.org/foods/]].
		 */
		public string defined_namespace_uri { get; internal set; }
		/**
		 * The prefix that this xmlns attribute defines. So,
		 * if the element was like {{{xmlns:foods="http://fishies.org/foods"}}}, the
		 * defined prefix would be foods.
		 */
		public string defined_prefix { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? local_name { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? namespace_prefix { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? namespace_uri { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string node_name { get; internal set; }
		/**
		 * {@inheritDoc}
		 */
		public override string? node_value { get; internal set; }
	}
	/**
	 * Convenient class for a list of {@link GXml.Node} objects based on
	 * {@link Gee.ListArray}, with good support for bindings.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NodeList : Gee.ArrayList<GXml.Node> {
		public NodeList ();
		public new GXml.Node @get (int index);
		public new GXml.Node[] to_array ();
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on {@link Gee.ArrayList}.
	 * 
	 * It is derived  It implements {@link Serializable} and {@link SerializableCollection}
	 * interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableArrayList<G> : Gee.ArrayList<G>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		public SerializableArrayList ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Represent any boolean property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableBool : GLib.Object, GXml.SerializableProperty {
		public SerializableBool ();
		/**
		 * Parse the stored value, from the XML property, to a {@link int}. This parsing
		 * may is different from the actual stored string. If can't be parsed to a valid
		 * boolean, this method will always return false.
		 */
		public bool get_value ();
		/**
		 * Given boolean value is parsed to string and then stored.
		 */
		public void set_value (bool val);
		/**
		 * Parse actual stored string to a boolean and returns the result. See {@link get_value}
		 */
		public string to_string ();
	}
	/**
	 * Any {@link GXml.Serializable} class having a collection managed list of
	 * {@link GXml.Node} must implement this abstract class.
	 * 
	 * Gee Serializable clases requires to be initialized with required typed objects to contain 
	 * its collections and Serializable interface don't know required type. Then you must use this
	 * function to initialize any Serializable collection objects in order to serialize/deserialize
	 * all {@link GXml.Node} to given clases.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class SerializableContainer : GXml.SerializableObjectModel {
		public SerializableContainer ();
		/**
		 * Implementors must implement this function and initialize any Serializable container.
		 */
		public abstract void init_containers ();
	}
	/**
	 * Represent any double presition float property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 * This object can be used when the property could be removed from serialization, specially if missing
	 * on XML have some missing and avoidable.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableDouble : GLib.Object, GXml.SerializableProperty {
		protected int _fraction;
		protected string _val;
		public SerializableDouble ();
		public string format (string f);
		public int get_fraction ();
		public double get_value ();
		public void set_fraction (int fraction);
		public void set_value (double val);
		public string to_string ();
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on Gee interfaces with dual key.
	 * 
	 * It implements {@link Serializable} and {@link SerializableCollection} interfaces, it is iterable as
	 * other Gee collections.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableDualKeyMap<P,S,V> : GLib.Object, Gee.Traversable<V>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		protected Gee.HashMultiMap<P,Gee.HashMap<S,V>> storage;
		public SerializableDualKeyMap ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public new V @get (P primary_key, S secondary_key);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public Gee.Collection<S> secondary_keys (P key);
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public new void @set (P primary_key, S secundary_key, V val);
		public virtual bool set_default_namespace (GXml.Node node);
		public Gee.Collection<V> values ();
		public Gee.Collection<V> values_for_key (P primary_key);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		public GLib.Type primary_key_type { get; }
		public Gee.Collection<P> primary_keys { owned get; }
		protected GLib.ParamSpec[] properties { get; set; }
		public GLib.Type secondary_key_type { get; }
		public int size { get; }
		public GLib.Type value_type { get; }
	}
	/**
	 * Represent any value as string but a list of enum values by default to select from.
	 * property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}.
	 *
	 * This class makes easy to create enumerations with its representation to string,
	 * but limited to the actual values of the enumeration, making it flexible for
	 * values not supported now but possible because some extensions. Can be added
	 * an extension element in the enumeration and return it when the supported values
	 * are not met with the string representation in the property.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableEnum : GLib.Object, GXml.SerializableProperty {
		protected GLib.Type _enumtype;
		protected string _val;
		public SerializableEnum ();
		public GLib.Type get_enum_type ();
		public void parse (string str) throws GLib.Error;
		public void parse_integer (int v) throws GLib.Error;
		public void set_enum_type (GLib.Type type);
		public int to_integer () throws GLib.Error;
		public string to_string ();
		public SerializableEnum.with_enum (GLib.Type type);
	}
	/**
	 * Represent any float property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 * This object can be used when the property could be removed from serialization, specially if missing
	 * on XML have some missing and avoidable.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableFloat : GXml.SerializableDouble {
		public SerializableFloat ();
		/**
		 * Parse the stored value, from the XML property, to a {@link int}. This parsing
		 * may is different from the actual stored string.
		 *
		 * The stored value, is parsed using to double value and then
		 * casted to an float before return, this make flexible on stored values
		 * in XML and parsed without errors, but they could defere from the value
		 * returned by this method.
		 */
		public new float get_value ();
		/**
		 * Given float number is parsed to string and then stored.
		 */
		public new void set_value (float val);
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on {@link Gee.HashMap}.
	 * 
	 * It uses a key and value store implementing {@link Gee.HashMap} interface.
	 * It implements {@link Serializable} and {@link SerializableCollection} interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableHashMap<K,V> : Gee.HashMap<K,V>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		public SerializableHashMap ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Represent any boolean property to be added as a {@link GXml.Attribute} to a {@link GXml.Element} 
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableInt : GXml.SerializableDouble {
		public SerializableInt ();
		/**
		 * Parse the stored value, from the XML property, to a {@link int}. This parsing
		 * may is different from the actual stored string.
		 *
		 * The stored value, is parsed as double value and then
		 * casted to an integer before return, this make flexible on stored values
		 * in XML and parsed without errors, but they could defere from the value
		 * returned by this method.
		 */
		public new int get_value ();
		/**
		 * Given integer is parsed to string and then stored.
		 */
		public new void set_value (int val);
	}
	/**
	 * Object Model is an {@link Serializable} implementation using {@link Element}
	 * to represent {@link GLib.Object} class objects.
	 * 
	 * This implementation consider each object as a XML node, represented in GXml 
	 * as a {@link GXml.Element} and its properties is represented by {@link GXml.Attribute}.
	 * Each property, if it is a {@link Serializable} object, is represented as child
	 * {@link Element}.
	 * 
	 * If a object's value property must be represented as a XML node content, 
	 * then it requires to override {@link Serializable.serialize_use_xml_node_value}
	 * and set value at {@link Serializable.serialized_xml_node_value}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class SerializableObjectModel : GLib.Object, GXml.Serializable {
		protected GXml.Node _node;
		public SerializableObjectModel ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public string default_node_name ();
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Element element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual bool get_enable_unknown_serializable_property ();
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public abstract string to_string ();
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Serializable Framework. A {@link Serializable} objects container based on {@link Gee.TreeMap}.
	 * 
	 * It uses a key and value store implementing {@link Gee.TreeMap} interface.
	 * It implements {@link Serializable} and {@link SerializableCollection} interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableTreeMap<K,V> : Gee.TreeMap<K,V>, GXml.Serializable, GXml.SerializableCollection {
		protected bool _deserialized;
		protected GXml.Node _node;
		public SerializableTreeMap ();
		public bool default_deserialize (GXml.Node node) throws GLib.Error;
		public bool default_deserialize_property (GXml.Node property_node) throws GLib.Error;
		public GXml.Node? default_serialize (GXml.Node node) throws GLib.Error;
		public GXml.Node? default_serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool deserialize (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_children () throws GLib.Error;
		public virtual bool deserialize_node (GXml.Node node) throws GLib.Error;
		public virtual bool deserialize_proceed ();
		public virtual bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		public virtual bool deserialized ();
		public virtual GLib.ParamSpec? find_property_spec (string property_name);
		public virtual GLib.ParamSpec[] list_serializable_properties ();
		public virtual string node_name ();
		public virtual bool property_use_nick ();
		public virtual GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		public virtual GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		public virtual bool serialize_use_xml_node_value ();
		public virtual bool set_default_namespace (GXml.Node node);
		public GLib.HashTable<string,GLib.ParamSpec> ignored_serializable_properties { get; protected set; }
		protected GLib.ParamSpec[] properties { get; set; }
	}
	/**
	 * Represent any value as string but a list of options by default to select from.
	 * property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}.
	 *
	 * All values are stored in an array to get access to it by its position using
	 * {@link SerializableValueList.get_value_at}.
	 *
	 * Is recommended to initilize your list from a fixed array to avoid to have a list
	 * for each object in memory, do it by initialize the internal variable
	 * {@link GXml.SerializableValueList._vals}, at construct {} clause to point a fixed
	 * array of strings.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SerializableValueList : GLib.Object, GXml.SerializableProperty {
		protected string[] _vals;
		protected Gee.ArrayList<string> extra;
		public SerializableValueList ();
		/**
		 * Add a list of string values to select from.
		 * 
		 * This values are added to the ones already defined at construct time.s
		 */
		public virtual void add_values (string[] vals);
		/**
		 * Get the string value at a given index. This operation does not change
		 * the actual value.
		 */
		public virtual string? get_value_at (int index);
		/**
		 * Return a {@link Gee.List} with all possible selection strings.
		 *
		 * If no values where defined at construction time and no values
		 * have been added, then this will return an empty list.
		 */
		public virtual Gee.List<string> get_values ();
		/**
		 * Get an array of string values in list.
		 *
		 * If no values were defined at construction time and
		 * no values were added this return null
		 */
		public virtual string[] get_values_array ();
		/**
		 * Checks if the actual value is in the values list.
		 */
		public virtual bool is_value ();
		/**
		 * Sets actual value to the one at a given position.
		 */
		public virtual void select_value_at (int index);
		public string to_string ();
	}
	/**
	 * Class implemeting {@link GXml.Attribute} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TAttribute : GXml.TNode, GXml.Attribute {
		protected Gee.ArrayList<GXml.Node> _namespaces;
		public TAttribute (GXml.Document d, string name, string value);
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.CDATA} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TCDATA : GXml.TNode, GXml.CDATA {
		public TCDATA (GXml.Document d, string text);
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Comment} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TComment : GXml.TNode, GXml.Comment {
		public TComment (GXml.Document doc, string text);
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Document} interface, not tied to libxml-2.0 library.
	 *
	 * This class use {@link Xml.TextWriter} to write down XML documents using
	 * its contained {@link GXml.Node} childs or other XML structures.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TDocument : GXml.TNode, GXml.Document {
		/**
		 * Enum for {@link Xml.TextReader} flag on parsing.
		 */
		public enum ReadType {
			NEXT,
			CONTINUE,
			STOP
		}
		/**
		 * Delegate function to control parsing of XML documents. Return {@link ReadType.NEXT}
		 * to skip all children nodes of current {@link GXml.Node}; {@link ReadType.CONTINUE}
		 * continue parsing nodes or {@link ReadType.STOP} to stop reading.
		 *
		 * While you get the current {@link Xml.TextReader} used in parsing, you can control
		 * next action to take depending on current node.
		 */
		public delegate GXml.TDocument.ReadType ReadTypeFunc (GXml.Node node, Xml.TextReader tr);
		protected Gee.ArrayList<GXml.Node> _children;
		protected Gee.ArrayList<GXml.Node> _namespaces;
		public TDocument ();
		public TDocument.from_file (GLib.File file);
		public TDocument.from_file_with_readtype_func (GLib.File file, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_path (string path);
		public TDocument.from_path_with_readtype_func (string path, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_stream (GLib.InputStream stream);
		public TDocument.from_stream_with_readtype_func (GLib.InputStream stream, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_string (string str);
		public TDocument.from_string_with_readtype_func (string str, GXml.TDocument.ReadTypeFunc func);
		public TDocument.from_uri (string uri);
		public TDocument.from_uri_with_readtype_func (string uri, GXml.TDocument.ReadTypeFunc func);
		/**
		 * Read a {@link GXml.Document} from a {@link GLib.File}, parsing is controller
		 * using {@link ReadTypeFunc}, if null it parse all nodes.
		 */
		public static void read_doc (GXml.Document doc, GLib.File file, GXml.TDocument.ReadTypeFunc? rtfunc = null) throws GLib.Error;
		/**
		 * Reads document from {@link GLib.InputStream} objects.
		 */
		public static void read_doc_stream (GXml.Document doc, GLib.InputStream istream, GXml.TDocument.ReadTypeFunc? rtfunc = null);
		/**
		 * Parse current node in {@link Xml.TextReader}.
		 *
		 * Returns: a {@link GXml.Node} respresenting current parsed one.
		 */
		public static GXml.TDocument.ReadType read_node (GXml.Node node, Xml.TextReader tr, GXml.TDocument.ReadTypeFunc? rntfunc = null) throws GLib.Error;
		[Deprecated (replacement = "save_as", since = "0.8.1")]
		public bool save_to (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * {@inheritDoc}
		 *
		 * All namespaces are stored at {@link GXml.Node.namespaces} owned by
		 * this {@link GXml.TDocument}.
		 *
		 * First namespace at list, is considered default one for the document. If
		 * you haven't declared a namespace for this document or for its root element,
		 * and you define one for a child node, this one is added for the first time
		 * to document's namespaces, then this becomes the default namespace. To avoid
		 * this, you should set a namespace for documento or its root, then childs.
		 *
		 * Default {@link GXml.Namespace} for a document is the first
		 */
		public override bool set_namespace (string uri, string? prefix);
		public static void start_node (GXml.Document doc, Xml.TextWriter tw, GXml.Node node, bool root, ref Gee.ArrayList<string> declared_ns) throws GLib.Error;
		public override string to_string ();
		public static bool tw_save_as (GXml.Document doc, GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public static void write_document (GXml.Document doc, Xml.TextWriter tw) throws GLib.Error;
		public override Gee.BidirList<GXml.Node> children { owned get; }
		public override GXml.Document document { get; }
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
	}
	/**
	 * Class implemeting {@link GXml.Element} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TElement : GXml.TNode, GXml.Element {
		protected Gee.HashMap<string,GXml.Node> _attrs;
		protected GXml.TNode.TChildrenList _children;
		protected Gee.ArrayList<GXml.Node> _namespaces;
		public TElement (GXml.Document d, string name);
		public override Gee.Map<string,GXml.Node> attrs { owned get; }
		public override Gee.BidirList<GXml.Node> children { owned get; }
		public override Gee.List<GXml.Namespace> namespaces { owned get; }
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Namespace}, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TNamespace : GXml.TNode, GXml.Namespace {
		public TNamespace (GXml.Document d, string uri, string? prefix);
	}
	/**
	 * Base node abstract class implemeting {@link GXml.Node} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class TNode : GLib.Object, GXml.Node {
		protected class TChildrenList : Gee.AbstractBidirList<GXml.Node> {
			protected TChildrenList (GXml.Node e);
			public override bool add (GXml.Node item);
			public override Gee.BidirListIterator<GXml.Node> bidir_list_iterator ();
			public override void clear ();
			public override bool contains (GXml.Node item);
			public override new GXml.Node @get (int index);
			public override int index_of (GXml.Node item);
			public override void insert (int index, GXml.Node item);
			public override Gee.Iterator<GXml.Node> iterator ();
			public override Gee.ListIterator<GXml.Node> list_iterator ();
			public override bool remove (GXml.Node item);
			public override GXml.Node remove_at (int index);
			public override new void @set (int index, GXml.Node item);
			public override Gee.List<GXml.Node>? slice (int start, int stop);
			public override bool read_only { get; }
			public override int size { get; }
		}
		protected GXml.Document _doc;
		protected string _name;
		protected GXml.Node _parent;
		protected string _value;
		public TNode ();
		public virtual bool set_namespace (string uri, string? prefix);
		public virtual void set_parent (GXml.Node node);
		public virtual string to_string ();
		public virtual Gee.Map<string,GXml.Node> attrs { owned get; }
		public virtual Gee.BidirList<GXml.Node> children { owned get; }
		public virtual GXml.Document document { get; }
		public virtual string name { owned get; }
		public virtual Gee.List<GXml.Namespace> namespaces { owned get; }
		public virtual GXml.Node parent { owned get; }
		public virtual GXml.NodeType type_node { get; }
		public virtual string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.ProcessingInstruction} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TProcessingInstruction : GXml.TNode, GXml.ProcessingInstruction {
		public TProcessingInstruction (GXml.Document doc, string target, string data);
		public override string value { owned get; set; }
	}
	/**
	 * Class implemeting {@link GXml.Text} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TText : GXml.TNode, GXml.Text {
		public TText (GXml.Document d, string text);
		public override string value { owned get; set; }
	}
	/**
	 * An XML Attr node, which represents a name="value" pair.
	 *
	 * These represent name="value" attributes associated with XML Elements
	 * (see {@link GXml.Element}). Values are often represented as strings but can
	 * also be more complex subtrees for some nodes.
	 *
	 * To create one, use {@link GXml.xDocument.create_attribute}.
	 *
	 * XML Example: Here, we have an Attr with the name 'flavour'
	 * and the value 'pumpkin'. {{{<pie flavour="pumpkin" />}}}
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 *
	 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-637646024]]
	 *
	 * @see GXml.Node
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xAttr : GXml.BackedNode, GXml.Attribute {
		/**
		 * {@inheritDoc}
		 */
		public override string stringify (bool format = false, int level = 0);
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNodeList? child_nodes { get; internal set; }
		/**
		 * The name of the attribute's name=value pair.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1112119403]]
		 */
		public override string name { owned get; }
		/**
		 * {@inheritDoc}
		 *
		 * Note: In libxml2, xmlAttrs have siblings, which are other Attrs contained
		 * by the same Element.  In the W3C DOM, they specifically don't.
		 *
		 * URL: [[http://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/Attr.html]]
		 */
		public override GXml.xNode? next_sibling { get; internal set; }
		/**
		 * The node_value for an attribute is a string
		 * representing the contents of the Attr's tree of
		 * children.
		 */
		public override string? node_value { get; internal set; }
		/**
		 * {@inheritDoc}
		 *
		 * Note: In libxml2, xmlAttrs have parent nodes, which are the Elements that
		 * contain them.  In the W3C DOM, they specifically don't.
		 *
		 * URL: [[http://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/Attr.html]]
		 */
		public override GXml.xNode? parent_node { get; internal set; }
		/**
		 * {@inheritDoc}
		 *
		 * Note: In libxml2, xmlAttrs have siblings, which are other Attrs contained
		 * by the same Element.  In the W3C DOM, they specifically don't.
		 *
		 * URL: [[http://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/Attr.html]]
		 */
		public override GXml.xNode? previous_sibling { get; internal set; }
		/**
		 * Whether an Attr was explicitly set in the
		 * underlying document. If the attribute is changed,
		 * it is set to false.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-862529273]]
		 */
		public bool specified { get; private set; }
		/**
		 * Value of the Attr. This is the same as node_value.
		 * It is a stringified version of the value, which can
		 * also be accessed as a tree node structure of
		 * child_nodes.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-221662474]]
		 */
		public override string value { owned get; set; }
	}
	/**
	 * An XML CDATA section, which contains non-XML data that is
	 * stored in an XML document.
	 *
	 * To create one, use {@link GXml.xDocument.create_cdata_section}.
	 *
	 * An XML example would be like:
	 * {{{ <![CDATA[Here contains non-XML data, like code, or something that requires a lot of special XML entities.]]>.}}}
	 * It is a type of Text node. For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-667469212]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xCDATASection : GXml.xText, GXml.CDATA {
		/**
		 * {@inheritDoc}
		 */
		public override string node_name { get; private set; }
	}
	/**
	 * CharacterData defines an interface for manipulating XML character data.
	 *
	 * It is used by the {@link GXml.xCDATASection},
	 * {@link GXml.Text}, and {@link GXml.Comment} node types.
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-FF21A306]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xCharacterData : GXml.BackedNode {
		/**
		 * Appends `new_segment` to the end of the character data.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-32791A2F]]
		 *
		 * @param new_segment The new data that will be appended at the end
		 */
		public void append_data (string new_segment);
		/**
		 * Deletes a range of characters, `count`-characters long, starting from `offset`.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-7C603781]]
		 *
		 * @param offset The index of the first character in the range to be deleted
		 * @param count The length in characters of the range to be deleted
		 */
		public void delete_data (ulong offset, ulong count);
		/**
		 * Inserts `new_segment` into the character data at `offset`.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-3EDB695F]]
		 *
		 * @param offset The index where the new data will be inserted
		 * @param new_segment The new data to be inserted
		 */
		public void insert_data (ulong offset, string new_segment);
		/**
		 * Replaces a range of characters, `count`-characters
		 * long, starting at `offset`, with `new_segment`.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-E5CBA7FB]]
		 *
		 * @param offset The index of the first character in the range that will be replaced
		 * @param count The length in characters of the range that will be replaced
		 * @param new_segment The text that will be added
		 */
		public void replace_data (ulong offset, ulong count, string new_segment);
		/**
		 * Retrieves a substring of the character data
		 * count-characters long, starting from the character
		 * at offset.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-6531BCCF]]
		 */
		public string substring_data (ulong offset, ulong count);
		/**
		 * The character data in string form for the node.
		 * Generally equivalent to node_value.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-72AB8359]]
		 */
		public string data { get; set; }
		/**
		 * The number of characters.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-7D61178C]]
		 */
		public ulong length { get; private set; }
	}
	/**
	 * An XML comment.
	 *
	 * To create one, use {@link GXml.xDocument.create_comment}.
	 *
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-1728279322]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xComment : GXml.xCharacterData, GXml.Comment {
		public override string node_name { get; private set; }
	}
	/**
	 * Represents an XML xDocument as a tree of {@link GXml.xNode}s.
	 *
	 * The xDocument has a root document element {@link GXml.xElement}.
	 * A xDocument's schema can be defined through its
	 * {@link GXml.xDocumentType}.
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#i-xDocument]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xDocument : GXml.xNode, GXml.Document {
		/**
		 * Creates an empty document.
		 *
		 * @return A new, empty {@link GXml.xDocument}; this must be freed with {@link GLib.Object.unref}
		 */
		public xDocument ();
		/**
		 * Appends new_child to this document, appearing at
		 * the end of its list of children.  A document can
		 * only have one {@link GXml.xElement} child, the root
		 * element, and one {@link GXml.xDocumentType}.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-appendChild]]
		 *
		 * @param new_child The child we're appending
		 *
		 * @return The newly added child; this should not be freed
		 */
		public override unowned GXml.xNode? append_child (GXml.xNode new_child);
		public unowned GXml.xNode copy_node (GXml.xNode foreign_node, bool deep = true);
		/**
		 * Creates an {@link GXml.Attribute} attribute with `name`, usually to be associated with an xElement.
		 *
		 * XML example: {{{<element attributename="attributevalue">content</element>}}}
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-createAttribute]]
		 *
		 * @param name The `name` of the attribute
		 *
		 * @return A new {@link GXml.Attribute} with the given `name`; this should not be freed
		 */
		public GXml.xAttr create_attribute (string name);
		/**
		 * Creates a CDATA section containing data.
		 *
		 * These do not apply to HTML doctype documents.  Its
		 * memory is freed when its owner document is freed.
		 *
		 * XML example:
		 * {{{ <![CDATA[Here contains non-XML data, like code, or something that requires a lot of special XML entities.]]>. }}}
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-createCDATASection]]
		 *
		 * @param cdata_data The content for the CDATA section
		 *
		 * @return A new {@link GXml.xCDATASection} with the
		 * supplied data; this should not be freed
		 */
		public unowned GXml.xCDATASection create_cdata_section (string cdata_data);
		/**
		 * Creates a {@link GXml.DocumentFragment}.
		 *
		 * xDocument fragments do not can contain a subset of a
		 * document, without being a complete tree.  Its
		 * memory is freed when its owner document is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-createDocumentFragment]]
		 *
		 * @return A {@link GXml.DocumentFragment}; this should not be freed
		 */
		public unowned GXml.DocumentFragment create_document_fragment ();
		/**
		 * Creates an entity reference.
		 *
		 * XML example: {{{&name;}}}, for example an apostrophe has the name 'apos', so in XML it appears as {{{&apos;}}}
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-createEntityReference]]
		 *
		 * @param name The 'name' of the entity reference
		 *
		 * @return An {@link GXml.EntityReference} for `name`; this should not be freed
		 */
		public GXml.EntityReference create_entity_reference (string name);
		/**
		 * Creates an XML comment with data.  Its memory is
		 * freed when its owner document is freed.
		 *
		 * XML example:
		 *
		 * {{{
		 *  <!-- data -->
		 * }}}
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-createComment]]
		 *
		 * @param comment_data The content of the comment
		 *
		 * @return A new {@link GXml.Comment} containing the
		 * supplied data; this should not be freed
		 */
		public unowned GXml.xComment create_managed_comment (string comment_data);
		/**
		 * Creates a new {@link GXml.ProcessingInstruction}.
		 *
		 * Its memory is freed when its owner document is
		 * freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-createProcessingInstruction]]
		 *
		 * @param target The target of the instruction
		 * @param data The content of the instruction
		 *
		 * @return A new {@link GXml.ProcessingInstruction}
		 * for the given target; this should not be freed
		 */
		public GXml.xProcessingInstruction create_processing_instruction (string target, string data);
		/**
		 * Creates a {@link GXml.Text} node containing the text in data.
		 * Its memory is freed when its owner document is freed.
		 *
		 * XML example:
		 * {{{<someElement>Text is contained here.</someElement>}}}
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-createTextNode]]
		 *
		 * @param text_data The textual data for the {@link GXml.Text} node
		 *
		 * @return A new {@link GXml.Text} node containing
		 * the supplied data; this should not be freed
		 */
		public unowned GXml.xText create_text_node (string text_data);
		/**
		 * Creates a xDocument for the {@link GLib.File} `fin`.
		 *
		 * @param fin The {@link GLib.File} containing the document
		 * @param can A {@link GLib.Cancellable} to let you cancel opening the file, or %NULL
		 *
		 * @return A new {@link GXml.xDocument} for `fin`; this must be freed with {@link GLib.Object.unref}
		 *
		 * @throws GLib.Error A {@link GLib.Error} if an error cocurs while reading the {@link GLib.File}
		 * @throws GXml.Error A {@link GXml.Error} if an error occurs while reading the file as a stream
		 */
		public xDocument.from_gfile (GLib.File fin, GLib.Cancellable? can = null) throws GXml.Error, GLib.Error;
		/**
		 * Creates a xDocument based on a libxml2 Xml.Doc* object.
		 *
		 * @param doc A {@link Xml.Doc} from libxml2
		 * @param require_root A flag to indicate whether we should require a root node, which the DOM normally expects
		 *
		 * @return A new {@link GXml.xDocument} wrapping the provided {@link Xml.Doc}; this must be freed with {@link GLib.Object.unref}
		 */
		public xDocument.from_libxml2 (Xml.Doc* doc, bool require_root = true);
		/**
		 * Creates a xDocument from the file at file_path.
		 *
		 * @param file_path A path to an XML document
		 *
		 * @return A {@link GXml.xDocument} for the given `file_path`; this must be freed with {@link GLib.Object.unref}
		 *
		 * @throws GXml.Error A {@link GXml.Error} if an error occurs while loading
		 */
		public xDocument.from_path (string file_path) throws GXml.Error;
		/**
		 * Creates a {@link GXml.xDocument} from data provided
		 * through a {@link GLib.InputStream}.
		 *
		 * @param instream A {@link GLib.InputStream} providing our document
		 * @param can      A {@link GLib.Cancellable} object allowing the caller
		 *                 to interrupt and cancel this operation, or %NULL
		 *
		 * @return A new {@link GXml.xDocument} built from the contents of instream;
		 *         this must be freed with {@link GLib.Object.unref}
		 *
		 * @throws GXml.Error A {@link GXml.Error} if an error occurs while reading the stream
		 */
		public xDocument.from_stream (GLib.InputStream instream, GLib.Cancellable? can = null) throws GLib.Error;
		/**
		 * Creates a xDocument from data found in memory.
		 *
		 * @param xml A string representing an XML document
		 *
		 * @return A new {@link GXml.xDocument} from `memory`; this must be freed with {@link GLib.Object.unref}
		 */
		public xDocument.from_string (string xml);
		/**
		 * Creates a xDocument from data found in memory using options.
		 *
		 * @param xml A string representing an XML document
		 * @param url the base URL to use for the document
		 * @param encoding the document encoding
		 * @param options a combination of {@link Xml.ParserOption}
		 *
		 * @return A new {@link GXml.xDocument} from `memory`; this must be freed with {@link GLib.Object.unref}
		 */
		public xDocument.from_string_with_options (string xml, string? url = null, string? encoding = null, int options = 0) throws GLib.Error;
		/**
		 * Obtains a list of {@link GXml.xElement}s, each with
		 * the given tag name `tag_name`, contained within
		 * this document.
		 *
		 * Note that the list is live, updated as new elements
		 * are added to the document.
		 *
		 * Unlike a {@link GXml.xNode} and its subclasses,
		 * {@link GXml.NodeList} are not part of the document
		 * tree, and thus their memory is not managed for the
		 * user, so the user must explicitly free them.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-getElementsByTagName]]
		 *
		 * @param tag_name The {@link GXml.xElement} tag name we matching for
		 *
		 * @return A {@link GXml.NodeList} of
		 * {@link GXml.xElement}s; this must be freed with
		 * {@link GLib.Object.unref}.
		 */
		public GXml.xNodeList get_elements_by_tag_name (string tag_name);
		/**
		 * {@inheritDoc}
		 */
		public override bool has_child_nodes ();
		/**
		 * Inserts `new_child` into this document before
		 * `ref_child`, an existing child of this
		 * {@link GXml.xDocument}. A document can only have one
		 * {@link GXml.xElement} child (the root element) and
		 * one {@link GXml.xDocumentType}.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-952280727]]
		 *
		 * @param new_child The new node to insert into the document
		 * @param ref_child The existing child of the document that new_child will precede, or %NULL
		 *
		 * @return The newly inserted child; this should not be freed
		 */
		public override unowned GXml.xNode? insert_before (GXml.xNode new_child, GXml.xNode? ref_child);
		/**
		 * Removes `old_child` from this document's list of
		 * children.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-removeChild]]
		 *
		 * @param old_child The child we wish to remove
		 *
		 * @return The removed node `old_child`; this should not be freed
		 */
		public override unowned GXml.xNode? remove_child (GXml.xNode old_child);
		/**
		 * Replaces `old_child` with `new_child` in this node's list of children.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-replaceChild]]
		 *
		 * @param new_child The child we will replace `old_child` with
		 * @param old_child The child being replaced
		 *
		 * @return The removed node `old_child`; this should not be freed
		 */
		public override unowned GXml.xNode? replace_child (GXml.xNode new_child, GXml.xNode old_child);
		/**
		 * Saves a xDocument to the file at path file_path
		 *
		 * @param file_path A path on the local system to save the document to
		 *
		 * @throws GXml.Error A {@link GXml.Error} if an error occurs while writing
		 */
		public void save_to_path (string file_path) throws GXml.Error;
		/**
		 * Saves a xDocument to the OutputStream outstream.
		 *
		 * @param outstream A destination {@link GLib.OutputStream} to save the XML file to
		 * @param can A {@link GLib.Cancellable} to cancel saving with, or %NULL
		 *
		 * @throws GXml.Error A {@link GXml.Error} is thrown if saving encounters an error
		 */
		public void save_to_stream (GLib.OutputStream outstream, GLib.Cancellable? can = null) throws GLib.Error;
		/**
		 * {@inheritDoc}
		 */
		public override string stringify (bool format = true, int level = 0);
		/**
		 * {@inheritDoc}
		 */
		public override GXml.xNodeList? child_nodes { get; internal set; }
		/**
		 * The xDocument Type Definition (DTD) defining this document. This may be %NULL.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#attribute-doctype]]
		 */
		public GXml.xDocumentType? doctype { get; private set; }
		/**
		 * The root node of the document's node tree.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#attribute-documentElement]]
		 */
		public GXml.xElement document_element { get; private set; }
		/**
		 * Describes the features of the DOM implementation behind this document.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#attribute-implementation]]
		 */
		public GXml.Implementation implementation { get; private set; }
		/**
		 * Provides the name for this node. For documents, it is always "#document".
		 */
		public override string node_name { get; private set; }
		public virtual GXml.Node root { owned get; }
	}
	/**
	 * Defines a xDocument, such as the entities that it can use.
	 * 
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-412266927]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xDocumentType : GXml.xNode, GXml.DocumentType {
		/**
		 * A HashTable of entities defined for this DocumentType.
		 */
		public Gee.Map<string,GXml.Entity>? entities { get; private set; }
		/**
		 * That which follows DOCTYPE in the XML doctype
		 * declaration, like 'xml' or 'html'. For example, the
		 * document type name is 'html' for a document with
		 * the XML doctype declaration of
		 * {{{ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> }}}
		 */
		public override string name { owned get; }
		/**
		 * A HashTable of notations defined for this DocumentType.
		 */
		public Gee.Map<string,GXml.xNotation>? notations { get; private set; }
	}
	/**
	 * Represent an XML xElement node, which have attributes and children.
	 *
	 * To create one, use {@link GXml.xDocument.create_element}.
	 *
	 * These can have child nodes
	 * of various types including other Elements. Elements can
	 * have Attr attributes associated with them. Elements have
	 * tag names. In addition to methods inherited from Node,
	 * Elements have additional methods for manipulating
	 * attributes, as an alternative to manipulating the
	 * attributes HashMap directly.
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-745549614]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xElement : GXml.BackedNode, GXml.Element {
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? append_child (GXml.xNode new_child);
		/**
		 * Retrieve the attribute value, as a string, for an
		 * attribute associated with this element with the
		 * name name.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-666EE0F9]]
		 *
		 * @param name The name of the attribute whose value to retrieve
		 *
		 * @return The value of the named attribute, or "" if
		 * no such attribute is set.
		 */
		public string get_attribute (string name);
		/**
		 * Get the Attr node representing this element's attribute named name.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-217A91B8]]
		 *
		 * @param name The name of the Attr node to retrieve
		 *
		 * @return The Attr node named by name for this element, or %NULL if none is set
		 */
		public GXml.xAttr? get_attribute_node (string name);
		/**
		 * Obtains a NodeList of Elements with the given
		 * tag_name that are descendants of this xElement.
		 * This will include the current element if it
		 * matches. The returned list is updated as necessary
		 * as the tree changes.
		 * 
		 * Visual explanation of get_elements_by_tag_name tree traversal.
		 * {{{
		 * a
		 *  b    c
		 * d e  f g
		 *
		 * we want: a b d e c f g
		 *
		 * start:
		 * add a
		 *
		 * pop top of stack (a)
		 * a: check for match: yes? add to return list
		 * a: add children from last to first (c,b) to top of stack (so head=b, then c)
		 *
		 * a
		 * a< [bc]
		 * b< [de]c
		 * d< ec
		 * e< c
		 * c< [fg]
		 * f< g
		 * g<
		 *
		 * see a, add a, visit a
		 * }}}
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1938918D]]
		 *
		 * @param tag_name The tag name to match for
		 *
		 * @return A NodeList containing the matching descendants
		 * 
		 */
		public GXml.xNodeList get_elements_by_tag_name (string tag_name);
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? insert_before (GXml.xNode new_child, GXml.xNode? ref_child);
		/**
		 * Remove the attribute named name from this element.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-6D6AC0F9]]
		 *
		 * @param name The name of the attribute to unset
		 */
		public void remove_attribute (string name);
		/**
		 * Remove Attr old_attr from this element, if it was
		 * set.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-D589198]]
		 *
		 * @param old_attr The Attr we are removing
		 *
		 * @return The old_attr we wanted to remove, even if
		 * it wasn't found.
		 */
		public GXml.xAttr remove_attribute_node (GXml.xAttr old_attr);
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? remove_child (GXml.xNode old_child);
		/**
		 * {@inheritDoc}
		 */
		public override unowned GXml.xNode? replace_child (GXml.xNode new_child, GXml.xNode old_child);
		/**
		 * Set the value of this element's attribute named
		 * name to the string value.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-F68F082]]
		 *
		 * @param name Name of the attribute whose value to set
		 * @param value The value to set
		 */
		public void set_attribute (string name, string value);
		/**
		 * Set the attribute in Attr for this element.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-887236154]]
		 *
		 * @param new_attr The attribute to set
		 *
		 * @return If an Attr with the same name exists, it
		 * is replaced and the old Attr is returned.
		 * Elsewise, %NULL is returned.
		 */
		public GXml.xAttr set_attribute_node (GXml.xAttr new_attr);
		/**
		 * {@inheritDoc}
		 */
		public override string stringify (bool format = false, int level = 0);
		/**
		 * Contains a {@link GXml.NamedAttrMap} of
		 * {@link GXml.Attribute} attributes associated with this
		 * {@link GXml.xElement}.
		 *
		 * Attributes in the NamedNodeMap are updated live, so
		 * changes in the element's attributes through its
		 * other methods are reflected in the attributes
		 *
		 * Do not free this or its contents.  It's memory will
		 * be released when the owning {@link GXml.xDocument}
		 * is freed.
		 */
		public override GXml.NamedAttrMap? attributes { get; internal set; }
		/**
		 * Elements do not have a node_value. Instead, their
		 * contents are stored in Attr attributes and in
		 * child_nodes.
		 */
		public override string? node_value { get; private set; }
	}
	/**
	 * Represents an XML xNode, the base class for most XML structures in
	 * the {@link GXml.xDocument}'s tree.
	 * 
	 * {@link GXml.xDocument}s are {@link GXml.xNode}s, and are
	 * composed of a tree of {@link GXml.xNode}s.
	 * 
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-1950641247]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class xNode : GLib.Object, GXml.Node {
		protected GXml.NamedAttrMap _attributes;
		protected GXml.xNodeList _child_nodes;
		/**
		 * Add a new namespace to this {@link GXml.xNode}
		 */
		public virtual GXml.NamespaceAttr? add_namespace_attr (string uri, string? namespace_prefix);
		/**
		 * Appends {@link new_child} to the end of this node's list of children,
		 * {@link GXml.xNode.child_nodes}.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 *
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-appendChild]]
		 *
		 * @param new_child A new {@link GXml.xNode} that will
		 * become the last child of this current node
		 *
		 * @return The newly added child, {@link new_child}.  Do not free it, its memory will be
		 * released when the owning {@link GXml.xDocument} is
		 * freed.
		 */
		public virtual unowned GXml.xNode? append_child (GXml.xNode new_child);
		/**
		 * Creates a parentless copy of this node.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 *
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-cloneNode]]
		 *
		 * @param deep If true, descendants are cloned as well. If false, they are not
		 *
		 * @return A parentless clone of this node.  Do not
		 * free it, its memory will be released when the owning
		 * {@link GXml.xDocument} is freed.
		 */
		public virtual unowned GXml.xNode? clone_node (bool deep);
		/**
		 * Indicates whether this node has children.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 *
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-hasChildNodes]]
		 *
		 * @return true if this node has children, false if not
		 */
		public virtual bool has_child_nodes ();
		/**
		 * Insert {@link new_child} as a child to this node, and place
		 * it in the list before {@link ref_child}.
		 *
		 * If {@link ref_child} is %NULL, {@link new_child} is appended to the
		 * list of children instead.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-insertBefore]]
		 *
		 * @param new_child A new {@link GXml.xNode} that will become a child of the current one
		 * @param ref_child The child that {@link new_child} will be placed ahead of
		 *
		 * @return {@link new_child}, the node that has been
		 * inserted.  Do not free it, its memory will be
		 * released when the owning {@link GXml.xDocument} is
		 * freed.
		 */
		public virtual unowned GXml.xNode? insert_before (GXml.xNode new_child, GXml.xNode? ref_child);
		/**
		 * Removes {@link old_child} from this node's list of children,
		 * {@link GXml.xNode.child_nodes}.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-removeChild]]
		 *
		 * @param old_child The {@link GXml.xNode} child to remove from the current one
		 *
		 * @return The removed node {@link old_child}.  Do not free it, its memory will be
		 * released when the owning {@link GXml.xDocument} is
		 * freed
		 */
		public virtual unowned GXml.xNode? remove_child (GXml.xNode old_child);
		/**
		 * Replaces {@link old_child} with {@link new_child} in this node's list of children.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-replaceChild]]
		 *
		 * @param new_child A new {@link GXml.xNode} that will become a child of the current one
		 * @param old_child A {@link GXml.xNode} that will be removed and replaced by {@link new_child}
		 *
		 * @return The removed node {@link old_child}.  Do not free it, its memory will be
		 * released when the owning {@link GXml.xDocument} is
		 * freed.
		 */
		public virtual unowned GXml.xNode? replace_child (GXml.xNode new_child, GXml.xNode old_child);
		/**
		 * Set namespace to this {@link GXml.xNode}
		 *
		 * Returns: true if namespace exists.
		 */
		public virtual bool set_namespace (string uri, string? namespace_prefix);
		/**
		 * Provides a string representation of this node.
		 *
		 * Note that if the DOM tree contains a Text node, a
		 * CDATA section, or an EntityRef, it will not be
		 * formatted, since the current implementation with
		 * libxml2 will not handle that case.  (See libxml2's
		 * xmlNodeDumpOutput internals to understand more.)
		 *
		 * @param format %FALSE: no formatting, true: formatted, with indentation
		 * @param level Indentation level
		 *
		 * @return XML string for node, which must be free
		 * this.
		 */
		public virtual string stringify (bool format = false, int level = 0);
		public virtual string to_string ();
		/**
		 * A {@link GXml.NamedNodeMap} containing the {@link GXml.Attribute}
		 * attributes for this node. `attributes`
		 * actually only apply to {@link GXml.Element}
		 * nodes. For all other {@link GXml.xNode} subclasses,
		 * `attributes` is %NULL.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-84CF09]]
		 */
		public virtual GXml.NamedAttrMap? attributes { get; internal set; }
		public virtual Gee.Map<string,GXml.Node> attrs { owned get; }
		/**
		 * List of child nodes to this node. These sometimes
		 * represent the value of a node as a tree of
		 * {@link GXml.xNode}, whereas node_value represents
		 * it as a string. This can be %NULL for node types
		 * that have no children.
		 *
		 * The {@link GXml.NodeList} is live, in that changes to this
		 * node's children will be reflected in an
		 * already-active {@link GXml.NodeList}.
		 *
		 * The caller must call {@link GLib.Object.unref} on
		 * the list when it is done with it.  The lists are
		 * constructed dynamically.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1451460987]]
		 */
		public virtual GXml.xNodeList? child_nodes { get; internal set; }
		public virtual Gee.BidirList<GXml.Node> children { owned get; }
		/**
		 * Links to the first child. If there are no
		 * children, it returns %NULL.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-169727388]]
		 */
		public virtual GXml.xNode? first_child { get; internal set; }
		/**
		 * Links to the last child. If there are no
		 * children, it returns %NULL.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-61AD09FB]]
		 */
		public virtual GXml.xNode? last_child { get; internal set; }
		/**
		 * Stores the local name within the namespace. This
		 * only applies to Elements and Attrs from DOM Level 2
		 * Core that were created with namespace support.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 2 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-NodeNSLocalN]]
		 */
		public virtual string? local_name { get; internal set; }
		public virtual string name { owned get; }
		/**
		 * The list of attributes that store namespace definitions.  This is not part of a DOM spec.
		 *
		 * The caller must free this using {@link GLib.Object.unref}.
		 */
		public virtual Gee.List<GXml.Namespace>? namespace_definitions { get; internal set; }
		/**
		 * Stores the namespace prefix for the node. This
		 * only applies to Elements and Attrs from DOM Level 2
		 * Core that were created with namespace support.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 2 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-NodeNSPrefix]]
		 */
		public virtual string? namespace_prefix { get; internal set; }
		/**
		 * Stores the URI describing the node's namespace.
		 * This only applies to Elements and Attrs from DOM
		 * Level 2 Core that were created with namespace
		 * support.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 2 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-NodeNSname]]
		 */
		public virtual string? namespace_uri { get; internal set; }
		public virtual Gee.List<GXml.Namespace> namespaces { owned get; }
		/**
		 * Links to this node's next sibling. If there is no
		 * next sibling, it returns %NULL. Note that the
		 * children of a node are ordered.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-6AC54C2F]]
		 */
		public virtual GXml.xNode? next_sibling { get; internal set; }
		/**
		 * Stores the name of the node. Sometimes this is
		 * similar to the node type, but sometimes, it is
		 * arbitrary data, like for {@link GXml.Attribute} where
		 * the node_name is the name of the Attr's name=value
		 * pair.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-F68D095]]
		 */
		public virtual string node_name { get; internal set; }
		/**
		 * Stores the type of node. Most XML structures are
		 * nodes of different types, like {@link GXml.xDocument}
		 * as a {@link GXml.NodeType.DOCUMENT}, {@link GXml.Attribute}
		 * as a {@link GXml.NodeType.ATTRIBUTE}, Element as a
		 * {@link GXml.NodeType.ELEMENT}, etc.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-111237558]]
		 */
		public virtual GXml.NodeType node_type { get; internal set; }
		/**
		 * Stores the value of the xNode. The nature of
		 * node_value varies based on the type of node. This
		 * can be %NULL.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-F68D080]]
		 */
		public virtual string? node_value { get; internal set; }
		/**
		 * A link to the {@link GXml.xDocument} to which this node belongs.
		 *
		 * Do not free this unless you intend to free all
		 * memory owned by the {@link GXml.xDocument}, including this
		 * {@link GXml.xNode}.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#node-ownerDoc]]
		 */
		public GXml.xDocument owner_document { get; internal set; }
		public virtual GXml.Node parent { owned get; }
		/**
		 * A link to the parent_node of this node. For example,
		 * with elements, the immediate, outer element is the parent.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1060184317]]
		 */
		public virtual GXml.xNode? parent_node { get; internal set; }
		/**
		 * Links to this node's preceding sibling. If there
		 * are no previous siblings, it returns %NULL. Note
		 * that the children of a node are ordered.
		 *
		 * Do not free this.  It's memory will be released
		 * when the owning {@link GXml.xDocument} is freed.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-640FB3C8]]
		 */
		public virtual GXml.xNode? previous_sibling { get; internal set; }
		public virtual string value { owned get; set; }
	}
	/**
	 * Used in defining {@link GXml.DocumentType}s to declare the format of {@link GXml.Entity} and {@link GXml.ProcessingInstruction}s.
	 *
	 * Used collectively in defining DocumentTypes. A Notation can
	 * declare the format of unparsed entities or
	 * ProcessingInstruction targets.
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-5431D1B9]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xNotation : GXml.xNode, GXml.Notation {
		/**
		 * The declared name for the notation.
		 */
		public override string node_name { get; private set; }
	}
	/**
	 * Stores processor-specific information with the document in
	 * a textual format.
	 *
	 * To create one, use {@link GXml.xDocument.create_processing_instruction}.
	 *
	 * For an example of a ProcessingInstruction, this one specifies a stylesheet:
	 * {{{stylesheet href="style.xsl" type="text/xml"}}}
	 *
	 * The general form is
	 * {{{pi_target processing instruction data}}}
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-1004215813]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xProcessingInstruction : GXml.xNode, GXml.ProcessingInstruction {
		/**
		 * The target name.
		 */
		public override string node_name { get; private set; }
		/**
		 * The target's data.
		 */
		public override string? node_value { get; private set; }
	}
	/**
	 * Text children of an element, not the tags or attributes.
	 *
	 * To create one, use {@link GXml.xDocument.create_text_node}.
	 *
	 * Describes the text found as children of elements throughout
	 * an XML document, like "He who must not be named" betwean two tags
	 * With libxml2 as a backend, it should be noted that two
	 * adjacent text nodes are always merged into one Text node,
	 * so some functionality for Text, like split_text, will not
	 * work completely as expected.
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-1312295772]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class xText : GXml.xCharacterData, GXml.Text {
		/**
		 * Normally, this would split the text into two
		 * adjacent sibling Text nodes. Currently, with
		 * libxml2, adjacent Text nodes are actually
		 * automatically remerged, so for now, we split the
		 * text and return the second part as a node outside
		 * of the document tree.
		 *
		 * WARNING: behaviour of this function will likely
		 * change in the future to comply with the DOM Level 1
		 * Core spec.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-38853C1D]]
		 *
		 * @param offset The point at which to split the Text,
		 * in number of characters.
		 *
		 * @return The second half of the split Text node. For
		 * now, it is not attached to the tree as a sibling to
		 * the first part, as the spec wants.
		 */
		public GXml.xText split_text (ulong offset);
		/**
		 * The name of this node type, "#text"
		 */
		public override string node_name { get; private set; }
	}
	/**
	 * Interface to handle XML tags properties.
	 *
	 * Its features relays on {@link GXml.Node} interface inplementation to access
	 * {@link GXml.Element} properties.
	 *
	 * Attribute's name could be get from {@link GXml.Node.name} property. Its value
	 * should be get from {@link GXml.Node.value} property.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Attribute : GLib.Object, GXml.Node {
		public abstract GXml.Namespace @namespace { owned get; set; }
		public abstract string prefix { owned get; }
	}
	/**
	 * CDATA sections in XML documents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface CDATA : GLib.Object, GXml.Node {
		/**
		 * This should be implemented by returning {@link GXml.Node.value}
		 */
		public abstract string str { owned get; }
	}
	/**
	 * Representation of comments nodes in any {@link GXml.Node}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Comment : GLib.Object, GXml.Node {
		/**
		 * This should be implemented by returning {@link GXml.Node.value}
		 */
		public abstract string str { owned get; }
	}
	/**
	 * Interface to handle XML documents.
	 *
	 * Provides basic interfaces to read and create XML documents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Document : GLib.Object, GXml.Node {
		/**
		 * Creates a new {@link GXml.CDATA}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_cdata (string text);
		/**
		 * Creates a new {@link GXml.Comment}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_comment (string text);
		/**
		 * This method should create a new {@link GXml.Element}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}.
		 */
		public abstract GXml.Node create_element (string name) throws GLib.Error;
		/**
		 * Creates a new {@link GXml.ProcessingInstruction}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_pi (string target, string data);
		/**
		 * Creates a new {@link GXml.Text}.
		 *
		 * Is a matter of you to add as a child to any other
		 * {@link GXml.Node}, like a {@link GXml.Element} node.
		 */
		public abstract GXml.Node create_text (string text);
		/**
		 * Creates a new {@link GXml.Document} using default implementation class.
		 *
		 * As an interface you can create your own implementation of it, but if 
		 * default one is required use this.
		 */
		public static GXml.Document new_default ();
		/**
		 * Creates a new {@link GXml.Document} from a {@link GLib.File} using default implementation class.
		 *
		 * As an interface you can create your own implementation of it, but if 
		 * default one is required use this.
		 */
		public static GXml.Document new_default_for_file (GLib.File f) throws GLib.Error;
		/**
		 * Creates a new {@link GXml.Document} from a file path using default implementation class.
		 *
		 * As an interface you can create your own implementation of it, but if 
		 * default one is required use this.
		 */
		public static GXml.Document new_default_for_path (string path) throws GLib.Error;
		/**
		 * Save this {@link GXml.Document} to {@link GXml.Document.file}
		 *
		 * If {@link GXml.Document.file} doesn't exists, it creates a new file to save to.
		 */
		public abstract bool save (GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Save this {@link GXml.Document} to given {@link GLib.File}
		 */
		public abstract bool save_as (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Controls if writting to a {@link GLib.File} creates a backup, by default
		 * is true;
		 */
		public abstract bool backup { get; set; }
		/**
		 * Stores a {@link GLib.File} to save/read XML documents to/from.
		 */
		public abstract GLib.File file { get; set; }
		/**
		 * Controls if writting this documents should use indent.
		 */
		public abstract bool indent { get; set; }
		/**
		 * Controls if writting this documentsshould use namespaces
		 * declaration at root {@link GXml.Element}.
		 *
		 * This removes full declaration at childs nodes, because they
		 * are just prefixed if a prefix was defined for namespace apply.
		 */
		public abstract bool ns_top { get; set; }
		/**
		 * Controls if writting this document should use default namespace's prefix
		 * to prefix root's childs {@link GXml.Element}.
		 *
		 * This removes prefix on childs using default namespace. Default namespace
		 * is the first one found in {@link GXml.Node.namespaces} for this document.
		 */
		public abstract bool prefix_default_ns { get; set; }
		/**
		 * XML document root node as a {@link GXml.Element}.
		 */
		public abstract GXml.Node root { owned get; }
	}
	/**
	 * Interface to represent Document type definitions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DocumentType : GLib.Object, GXml.Node {
	}
	/**
	 * Interface to access XML document's tags, properties and content.
	 *
	 * Provides methods to create new XML tags properties and its values, and 
	 * access to tag's contents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Element : GLib.Object, GXml.Node {
		/**
		 * Search for a {@link GXml.Attribute} with given name.
		 *
		 * All attributes could be get using {@link GXml.Node.attrs} property.
		 */
		public abstract GXml.Node get_attr (string name);
		/**
		 * Search for a {@link GXml.Attribute} with a given name and namespace uri.
		 *
		 * To get a attibute from {@link GXml.Node.attrs} with a given namespace
		 * prefix, use "prefix:name".
		 */
		public abstract GXml.Node get_ns_attr (string name, string uri);
		/**
		 * This merges all adjacent {@link GXml.Text} nodes that are
		 * descendants of this {@link GXml.Element}.
		 */
		public abstract void normalize ();
		/**
		 * Search for a {@link GXml.Attribute} with given name and removes it.
		 */
		public abstract void remove_attr (string name);
		/**
		 * Add a new {@link GXml.Attribute} to this {@link GXml.Element}.
		 *
		 * You should provide a name and a value.
		 */
		public abstract void set_attr (string name, string value);
		/**
		 * Set an {@link GXml.Attribute} with a given name, value and namespace.
		 */
		public abstract void set_ns_attr (GXml.Namespace ns, string name, string value);
		/**
		 * This should be just a different name for {@link GXml.Node.value}.
		 */
		public abstract string content { owned get; set; }
		/**
		 * This should be just a different name for {@link GXml.Node.name}.
		 */
		public abstract string tag_name { owned get; }
	}
	/**
	 * DOM API. A collection of elements with a named objects.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface NamedNodeMap<T> : GLib.Object {
		public abstract T get_named_item (string name);
		public abstract T item (ulong index);
		public abstract T remove_named_item (string name);
		public abstract T set_named_item (T item);
		public abstract ulong length { get; }
	}
	/**
	 * Interface to handle XML Namespaces.
	 *
	 * Basic information for a XML document's namespaces and applied to a given
	 * {@link GXml.Node}.
	 *
	 * Namespace management is a matter of this or other libraries, implementing
	 * this interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Namespace : GLib.Object {
		/**
		 * Read-only property to get namespace's prefix.
		 *
		 * Prefix should be added to {@link GXml.Element} or {@link GXml.Attribute}
		 * name in order to apply a given namespace, unless it is the default.
		 */
		public abstract string prefix { owned get; }
		/**
		 * Read-only property to get namespace's URI.
		 */
		public abstract string uri { owned get; }
	}
	/**
	 * Base interface providing basic functionalities to all GXml interfaces.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Node : GLib.Object {
		/**
		 * Copy a {@link GXml.Node} relaing on {@link GXml.Document} to other {@link GXml.Node}.
		 *
		 * node could belongs from different {@link GXml.Document}, while source is a node
		 * belonging to given document.
		 *
		 * Just {@link GXml.Element} objects are supported. For attributes, use
		 * {@link GXml.Element.set_attr} method, passing source's name and value as arguments.
		 *
		 * @param doc a {@link GXml.Document} owning destiny node
		 * @param node a {@link GXml.Element} to copy nodes to
		 * @param source a {@link GXml.Element} to copy nodes from, it could be holded by different {@link GXml.Document}
		 */
		public static bool copy (GXml.Document doc, GXml.Node node, GXml.Node source, bool deep);
		/**
		 * Get first child with given name, or null. 
		 */
		public virtual new GXml.Node? @get (string key);
		/**
		 * Search all child {@link GXml.Element} with a given property's name and with
		 * value contained in text.
		 */
		public virtual GXml.ElementList get_elements_by_property_value (string property, string value);
		/**
		 * Node's defaults namespace's prefix.
		 *
		 * This allways returns first {@link GXml.Namespace}'s prefix in {@link GXml.Node}'s
		 * namespaces collection.
		 */
		public virtual string ns_prefix ();
		/**
		 * Node's defaults namespace's URI.
		 *
		 * This allways returns first {@link GXml.Namespace}'s URI in {@link GXml.Node}'s
		 * namespaces collection.
		 */
		public virtual string ns_uri ();
		/**
		 * Set a namespace to this node.
		 *
		 * Search for existing document's namespaces and applies it if found or creates
		 * a new one, appending to document's namespaces collection.
		 */
		public abstract bool set_namespace (string uri, string? prefix);
		/**
		 * Node's string representation.
		 */
		public abstract string to_string ();
		/**
		 * Attributes in this {@link GXml.Node}.
		 */
		public abstract Gee.Map<string,GXml.Node> attrs { owned get; }
		/**
		 * Collection of {@link GXml.Node} as childs.
		 *
		 * Depend on {@link GXml.Node} type, this childs could of different, like,
		 * elements, element's contents or properties.
		 */
		public abstract Gee.BidirList<GXml.Node> children { owned get; }
		/**
		 * Collection of {@link GXml.Node} as childs.
		 *
		 * Depend on {@link GXml.Node} type, this childs could of different, like,
		 * elements, element's contents or properties.
		 */
		[Deprecated (replace = "children", since = "0.10.0")]
		public virtual Gee.BidirList<GXml.Node> childs { owned get; }
		/**
		 * Node's XML document holding this node.
		 */
		public abstract GXml.Document document { get; }
		/**
		 * Node's name. The meaning differs, depending on node's type.
		 */
		public abstract string name { owned get; }
		/**
		 * Collection of Namespaces applied to this {@link GXml.Node}.
		 */
		public abstract Gee.List<GXml.Namespace> namespaces { owned get; }
		/**
		 * Node's XML document holding this node.
		 */
		public abstract GXml.Node parent { owned get; }
		/**
		 * Node's type as a enumeration.
		 */
		public abstract GXml.NodeType type_node { get; }
		/**
		 * Node's value. The meaning differs, depending on node's type.
		 */
		public abstract string value { owned get; set; }
	}
	/**
	 * Interface to handle notation elements
	 *
	 * Used in defining {@link GXml.DocumentType}s to declare the format of
	 * {@link GXml.Entity} and {@link GXml.ProcessingInstruction}s.
	 *
	 * Used collectively in defining DocumentTypes. A Notation can
	 * declare the format of unparsed entities or
	 * ProcessingInstruction targets.
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-5431D1B9]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Notation : GLib.Object, GXml.Node {
		public abstract string? external_id { get; }
		public abstract string? public_id { get; }
	}
	/**
	 * Interface for XML Processing Instruction sections.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface ProcessingInstruction : GLib.Object, GXml.Node {
		/**
		 * The data used by the target, like {{{href="style.xsl" type="text/xml"}}}
		 */
		public abstract string data { owned get; }
		/**
		 * The target for the processing instruction, like "xml-stylesheet".
		 */
		public abstract string target { owned get; }
	}
	/**
	 * Serialization framework. Base interface.
	 *
	 * Implementors of this interface, could define or override the way you want to 
	 * represent your class in a XML file.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Serializable : GLib.Object {
		/**
		 * Default implementation for {@link Serializable.find_property_spec}
		 *
		 */
		public virtual GLib.ParamSpec? default_find_property_spec (string property_name);
		/**
		 * Default implementation for {@link Serializable.list_serializable_properties}
		 *
		 */
		public virtual GLib.ParamSpec[] default_list_serializable_properties ();
		/**
		 * Deserialize this object.
		 *
		 * @param node {@link GXml.Node} used to deserialize from.
		 */
		public abstract bool deserialize (GXml.Node node) throws GLib.Error;
		/**
		 * Handles deserializing individual properties.
		 *
		 * Interface method to handle deserialization of an
		 * individual property.  The implementing class
		 * receives a description of the property and the
		 * {@link GXml.Node} that contains the content.  The
		 * implementing {@link GXml.Serializable} object can extract
		 * the data from the {@link GXml.Node} and store it in its
		 * property itself. Note that the {@link GXml.Node} may be
		 * as simple as a {@link GXml.Text} that stores the data as a
		 * string.
		 *
		 * Implementors:
		 * Use Serializable.get_property_value in order to allow derived classes to
		 * override the properties to serialize.
		 *
		 * @param property_node the {@link GXml.Node} encapsulating data to deserialize
		 * @return `true` if the property was handled, `false` if {@link GXml.Serialization} should handle it.
		 */
		public abstract bool deserialize_property (GXml.Node property_node) throws GLib.Error;
		/**
		 * Handles finding the {@link GLib.ParamSpec} for a given property.
		 *
		 * {@link GXml.Serialization} uses {@link GLib.ObjectClass.find_property}
		 * (as well as {@link GLib.ObjectClass.list_properties},
		 * {@link GLib.Object.get_property}, and
		 * {@link GLib.Object.set_property}) to manage serialization
		 * of properties.  {@link GXml.Serializable} gives the
		 * implementing class an opportunity to override
		 * {@link GLib.ObjectClass.find_property} to control
		 * what properties exist for {@link GXml.Serialization}'s
		 * purposes.
		 *
		 * For instance, if an object has private data fields
		 * that are not installed public properties, but that
		 * should be serialized, {@link GLib.ObjectClass.find_property} can be defined
		 * to return a {@link GLib.ParamSpec} for non-installed
		 * properties.  Other {@link GXml.Serializable} functions
		 * should be consistent with it.
		 *
		 * An implementing class might wish to maintain such
		 * {@link GLib.ParamSpec} s separately, rather than creating new
		 * ones for each call.
		 *
		 * @param property_name the name of a property to obtain a {@link GLib.ParamSpec} for
		 * @return a {@link GLib.ParamSpec} describing the named property
		 */
		public abstract GLib.ParamSpec? find_property_spec (string property_name);
		/**
		 * Return false if you want to ignore unknown properties and {@link GXml.Node}'s
		 * not in your class definition.
		 *
		 * Take care, disabling this feature you can lost data on serialization, because any unknown
		 * property or element will be discarted.
		 */
		public abstract bool get_enable_unknown_serializable_property ();
		/**
		 * Transforms a {@link GLib.Value} to its string representation.
		 *
		 * By default use {@link GLib.Value} standard transformations.
		 *
		 */
		public static string gvalue_to_string (GLib.Value val) throws GXml.SerializableError;
		/**
		 * List the known properties for an object's class
		 *
		 * Class {@link GXml.Serialization} uses
		 * {@link GLib.ObjectClass.list_properties} (as well as
		 * {@link GLib.ObjectClass.find_property},
		 * {@link GLib.Object.get_property}, and {@link GLib.Object.set_property})
		 * to manage serialization of an object's properties.
		 * {@link GXml.Serializable} gives an implementing class an
		 * opportunity to override
		 * {@link GLib.ObjectClass.list_properties} to control which
		 * properties exist for {@link GXml.Serialization}'s purposes.
		 *
		 * For instance, if an object has private data fields
		 * that are not installed public properties, but that
		 * should be serialized, list_properties can be
		 * defined to return a list of {@link GLib.ParamSpec} s covering
		 * all the "properties" to serialize.  Other
		 * {@link GXml.Serializable} functions should be consistent
		 * with it.
		 *
		 * An implementing class might wish to maintain such
		 * {@link GLib.ParamSpec} s separately, rather than creating new
		 * ones for each call.
		 *
		 * @return an array of {@link GLib.ParamSpec} of "properties" for the object.
		 */
		public abstract GLib.ParamSpec[] list_serializable_properties ();
		/**
		 * Defines the way to set Node name.
		 */
		public abstract string node_name ();
		/**
		 * Defines the way to set Node's property name, by using
		 * it's nick instead of default name.
		 *
		 * When serialize a class property, by default it uses its name given  on class
		 * declaration, but is less common to see XML node properties with names like
		 * "your_property", but more common is to use "YourProperty". In order
		 * to use this kind of names, your implementation should use properties' nick
		 * name and override {@link property_use_nick} method to return true. This should
		 * instruct your code to use this method to use property's nick name. This is
		 * the default in GXml default implementations.
		 */
		public abstract bool property_use_nick ();
		/**
		 * Serialize this object.
		 *
		 * This method must call serialize_property() recursivally on all properties
		 * to serialize.
		 *
		 * @param node an {@link GXml.Node} object to serialize to.
		 */
		public abstract GXml.Node? serialize (GXml.Node node) throws GLib.Error;
		/**
		 * Serialize a property @prop on a {@link GXml.Element}.
		 *
		 * This method is called recursivally by {@link serialize} method over all properties
		 * to be serialized.
		 */
		public abstract GXml.Node? serialize_property (GXml.Node element, GLib.ParamSpec prop) throws GLib.Error;
		/**
		 * Used to check {@link GXml.Element}'s contents must be deseralized.
		 *
		 * By default GXml's implementations doesn't deseriaze/serialize XML node contents.
		 * In order to enable it, you must override {@link serialize_use_xml_node_value}
		 * method to return true and store XML node's content to {@link serialized_xml_node_value}
		 * property.
		 *
		 * Implementors could set up methods to provide a clean easy to use API to set
		 * nodes contents. In most cases, users would like to set a value through a getter
		 * or setter or through a property in the class. If you use a property, you should
		 * add it to {@link ignored_serializable_properties} in order to see its value
		 * in a XML node property.
		 *
		 */
		public abstract bool serialize_use_xml_node_value ();
		/**
		 * Used to set specific namespace for an {@link GXml.Element}.
		 *
		 * By default no namspace prefix is added to {@link GXml.Element} on serialized. Implementors
		 * must consider override this methodk if this node should have a namespace.
		 */
		public abstract bool set_default_namespace (GXml.Node node);
		/**
		 * Transforms a string into another type hosted by {@link GLib.Value}.
		 *
		 * A utility function that handles converting a string
		 * representation of a value into the type specified by the
		 * supplied #GValue dest.  A #GXmlSerializableError will be
		 * set if the string cannot be parsed into the desired type.
		 * 
		 * {@link Serializable} interface support a number of data types to convert
		 * from its string representation. These are supported types:
		 * 
		 * a. integers: int8, int64, uint, long, ulong, char, uchar
		 * a. boolean
		 * a. floats: float, double
		 * a. enumerations
		 *
		 * @param str the string to transform into the given #GValue object
		 * @param dest the #GValue out parameter that will contain the parsed value from the string
		 * @return `true` if parsing succeeded, otherwise `false`
		 */
		public static bool string_to_gvalue (string str, ref GLib.Value dest) throws GXml.SerializableError;
		/**
		 * Used to add content in an {@link GXml.Element}.
		 *
		 * By default no contents is serialized/deseralized. Implementors must implement
		 * {@link Serializable.serialize_use_xml_node_value} function returning
		 * true in order to use this property.
		 *
		 * This property is ignored by default. Implementors must implement
		 * {@link serialize_use_xml_node_value} to return true and add a
		 * set and get function to get/set this value, in order to use your own API.
		 *
		 * This property is ignored on serialisation.
		 */
		public abstract string? serialized_xml_node_value { owned get; protected set; }
		/**
		 * On deserialization stores any {@link GXml.Node} not used on this
		 * object, but exists in current XML file.
		 *
		 * XML allows great flexibility, providing different ways to represent the same
		 * information. This is a problem when you try to deserialize them.
		 *
		 * In order to deserialize correctly, you must create your XML, both by
		 * serializing a {@link Serializable} object or by hand writing. By using the
		 * former, you can add extra information, like nodes or contents in known nodes,
		 * but most of them could be ignored or lost on deserialization/serialization process.
		 * To avoid data lost, you can override {@link get_enable_unknown_serializable_property}
		 * method in order to return true, your implementation or the ones in GXml, will
		 * store all unknown properties and nodes on deserialization and must serialize
		 * again back to the XML file. Even you are allowed to get this unknown objects
		 * by iterating on {@link Serializable.unknown_serializable_nodes} hash table.
		 *
		 * This property is ignored on serialisation.
		 */
		public abstract Gee.Collection<GXml.Node> unknown_serializable_nodes { owned get; }
		/**
		 * On deserialization stores any {@link GXml.Attribute} not used on this
		 * object, but exists in current XML file.
		 *
		 * Node's name is used as key to find stored {@link GXml.Attribute}, key is
		 * case sensitive.
		 *
		 * XML allows great flexibility, providing different ways to represent the same
		 * information. This is a problem when you try to deserialize them.
		 *
		 * In order to deserialize correctly, you must create your XML, both by
		 * serializing a {@link Serializable} object or by hand writing. By using the
		 * former, you can add extra information, like attributes, but most of
		 * them could be ignored or lost on deserialization/serialization process. To
		 * avoid data lost, you can override {@link get_enable_unknown_serializable_property}
		 * method in order to return true, your implementation or the ones in GXml, will
		 * store all unknown attributes on deserialization and must serialize
		 * again back to the XML file. Even you are allowed to get this unknown objects
		 * by iterating on {@link unknown_serializable_properties} collection, if you know
		 * attribute's name, use it to retrieve it.
		 *
		 * This property is ignored on serialisation.
		 */
		public abstract Gee.Map<string,GXml.Attribute> unknown_serializable_properties { owned get; }
		/**
		 * Signal to deserialize unknown properties.
		 *
		 * @param node a {@link GXml.Node} to get attribute from
		 * @param prop a {@link GLib.ParamSpec} describing attribute to deserialize
		 */
		public signal void deserialize_unknown_property (GXml.Node node, GLib.ParamSpec prop);
		/**
		 * Signal to deserialize unknown properties' type.
		 *
		 * @param node a {@link GXml.Node} to get attribute from
		 * @param prop a {@link GLib.ParamSpec} describing attribute to deserialize
		 */
		public signal void deserialize_unknown_property_type (GXml.Node node, GLib.ParamSpec prop);
		/**
		 * Signal to serialize unknown properties. Any new node must be added to
		 * @param element before return the new @param node added.
		 *
		 * @param element a {@link GXml.Node} to add attribute or child nodes to
		 * @param prop a {@link GLib.ParamSpec} describing attribute to serialize
		 * @param node set to the {@link GXml.Node} representing this attribute
		 */
		public signal void serialize_unknown_property (GXml.Node element, GLib.ParamSpec prop, out GXml.Node node);
		/**
		 * Signal to serialize unknown properties. Any new node must be added to
		 * @param element before return the new @node added.
		 * 
		 * @param element a {@link GXml.Node} to add attribute or child nodes to
		 * @param prop a {@link GLib.ParamSpec} describing attribute to serialize
		 * @param node set to the {@link GXml.Node} representing this attribute
		 */
		public signal void serialize_unknown_property_type (GXml.Node element, GLib.ParamSpec prop, out GXml.Node node);
	}
	/**
	 * Serializable Framework. interface to be implemented by any collection of {@link Serializable} objects.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableCollection : GLib.Object, Gee.Traversable<GXml.Serializable>, GXml.Serializable {
		/**
		 * Executes a deserialization from all children nodes in a {@link GXml.Node}. After this operation
		 * {@link GXml.SerializableCollection.deserialized} should return true. This
		 * operation should not be executed if {@link GXml.SerializableCollection.is_prepared}
		 * return false;
		 *
		 * This could override existing objects in collection.
		 */
		public abstract bool deserialize_children () throws GLib.Error;
		/**
		 * Executes a deserialization from a {@link GXml.Node}. After this operation
		 * {@link GXml.SerializableCollection.deserialized} should return true. This
		 * operation should not be executed if {@link GXml.SerializableCollection.is_prepared}
		 * return false;
		 *
		 * This could override existing objects in collection.
		 */
		public abstract bool deserialize_node (GXml.Node node) throws GLib.Error;
		/**
		 * Returns true if the collection should be deserialized from a {@link GXml.Node}'s children
		 * when {@link GXml.Serializable.deserialize} is called. For large collection of nodes
		 * this could impact in performance; return false and use {@link GXml.SerializableCollection.deserialize_children}
		 * when you need to deserialize all nodes to access them.
		 */
		public abstract bool deserialize_proceed ();
		/**
		 * Returns true if the collection was deserialized from a {@link GXml.Node}'s children.
		 */
		public abstract bool deserialized ();
		/**
		 * Convenient function to detect Serializable Collections.
		 */
		public virtual bool is_collection ();
	}
	/**
	 * Serializable Framework. Interface to get two keys to be used to store {@link Serializable} objects.
	 * 
	 * This interface must be implemented by classes derived from {@link GXml.SerializableDualKeyMap}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableMapDualKey<P,S> : GLib.Object {
		/**
		 * Implement this function to return the value to be used as primary key on
		 * {@link SerializableDualKeyMap} containers.
		 */
		public abstract P get_map_primary_key ();
		/**
		 * Implement this function to return the value to be used as secondary key on
		 * {@link SerializableDualKeyMap} containers.
		 */
		public abstract S get_map_secondary_key ();
	}
	/**
	 * Serializable Framework. Interface to get one key to be used to store {@link Serializable} objects.
	 * 
	 * This interface must be implemented by classes derived from {@link SerializableTreeMap}
	 * and {@link SerializableHashMap}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableMapKey<K> : GLib.Object {
		/**
		 * Implement this function to return the value to be used as key on {@link SerializableTreeMap}
		 * and {@link SerializableHashMap} containers.
		 */
		public abstract K get_map_key ();
	}
	/**
	 * Represent any property to be added as a {@link GXml.Attribute} to a {@link GXml.Element}
	 *
	 * The actual value stored and returned by {@link GXml.SerializableProperty.get_serializable_property_value}
	 * is the actual string in the XML property, this means may the value could differ from the spected value
	 * on some implementations like {@link GXml.SerializableInt}. Take a look in each implementations about
	 * retured values.
	 *
	 * Implementations of {@link GXml.SerializableProperty}, could be used to provide more flexibility
	 * when parsing {@link GXml.Attribute} properties values and to exclude to be serialized if they have not
	 * been created in the holding objects.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface SerializableProperty : GLib.Object {
		/**
		 * Tryies to deserialize from a {@link GXml.Node} searching a {@link GXml.Attribute}
		 * with the name in @param prop or from its nick if @nick is true.
		 */
		public bool default_serializable_property_deserialize_property (GXml.Node property_node, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Default serialization method to add a {@link GXml.Attribute} to a {@link GXml.Element}
		 *
		 * If {@link GXml.SerializableProperty.get_serializable_property_value} returns null
		 * given {@link GXml.Node} is not modified.
		 */
		public GXml.Node? default_serializable_property_serialize_property (GXml.Node element, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Tryies to deserialize from a {@link GXml.Node} searching a {@link GXml.Attribute}
		 * with the name provided in @param prop or its nick if @nick is true,
		 * if not set, then {@link GLib.ParamSpec} name should used. If @param nick is set to true,
		 * then {@link GLib.ParamSpec} nick is used as name.
		 */
		public virtual bool deserialize_property (GXml.Node property_node, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Value to be set to a {@link GXml.Attribute}, to be added to a {@link GXml.Element}
		 */
		public abstract string get_serializable_property_value ();
		/**
		 * Serialization method to add a {@link GXml.Attribute} to a {@link GXml.Element}, using {@link GLib.ParamSpec}
		 * name or nick, if @param nick is set to true, as the attribute's name.
		 *
		 * If {@link GXml.SerializableProperty.get_serializable_property_value} returns null
		 * given {@link GXml.Node} should not be modified.
		 */
		public virtual GXml.Node? serialize_property (GXml.Node property_node, GLib.ParamSpec prop, bool nick) throws GLib.Error;
		/**
		 * Set value to be set to a {@link GXml.Attribute}, to be added to a {@link GXml.Element}
		 *
		 * If value is set to @null then the property will be ignored by default and no
		 * property will be set to given {@link GXml.Element}.
		 *
		 * Some implementations stores the value without any convertion at all; then if the value,
		 * from XML property, makes no sense for the property type, you should take care
		 * to use the provided API from them to convert it.
		 */
		public abstract void set_serializable_property_value (string? val);
	}
	/**
	 * Representation of text nodes in any {@link GXml.Node}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Text : GLib.Object, GXml.Node {
		/**
		 * This should be implemented by returning {@link GXml.Node.value}
		 */
		public abstract string str { owned get; }
	}
	/**
	 * DOM API. Interface to access a list of nodes.
	 *
	 * A live list used to store {@link GXml.xNode}s.
	 *
	 * Usually contains the children of a {@link GXml.xNode}, or
	 * the results of {@link GXml.xElement.get_elements_by_tag_name}.
	 * {@link GXml.NodeList} implements both the DOM Level 1 Core API for
	 * a NodeList, as well as the {@link GLib.List} API, to make
	 * it more accessible and familiar to GLib programmers.
	 * Implementing classes also implement {@link Gee.Iterable}, to make
	 * iteration in supporting languages (like Vala) nice and
	 * easy.
	 *
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-536297177]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface xNodeList : GLib.Object, Gee.Iterable<GXml.xNode>, Gee.Collection<GXml.xNode> {
		public abstract unowned GXml.xNode? append_child (GXml.xNode new_child);
		/**
		 * Retrieve the first node in the list.  Like {@link GLib.List.first}.
		 */
		public abstract GXml.xNode first ();
		/**
		 * Obtain the n'th item in the list. Like {@link GLib.List.nth}.
		 *
		 * @param n The index of the item to access
		 */
		public abstract new GXml.xNode @get (int n);
		public abstract unowned GXml.xNode? insert_before (GXml.xNode new_child, GXml.xNode? ref_child);
		/**
		 * Access the idx'th item in the list.
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#method-item]]
		 */
		public abstract GXml.xNode item (ulong idx);
		/**
		 * Retrieve the last node in the list.  Like {@link GLib.List.last}.
		 */
		public abstract GXml.xNode last ();
		public abstract unowned GXml.xNode? remove_child (GXml.xNode old_child);
		public abstract unowned GXml.xNode? replace_child (GXml.xNode new_child, GXml.xNode old_child);
		/**
		 * Creates an XML string representation of the nodes in the list.
		 *
		 * #todo: write a test
		 *
		 * @param in_line Whether to parse and expand entities or not
		 *
		 * @return The list as an XML string
		 */
		public abstract string to_string (bool in_line);
		/**
		 * The number of nodes contained within this list
		 *
		 * Version: DOM Level 1 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#attribute-length]]
		 */
		public abstract ulong length { get; protected set; }
	}
	/**
	 * Describes various error states. For more, see
	 * 
	 * Version: DOM Level 1 Core<<BR>>
	 * URL: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-BBACDC08]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum DomException {
		/**
		 * Indicates that there has not been a recent error
		 */
		NONE,
		/**
		 * An index or size is out of range, like less than 0 or exceeding some upper bound.
		 */
		INDEX_SIZE,
		/**
		 * Text exceeds the maximum size supported in our string implementation.
		 */
		DOMSTRING_SIZE,
		/**
		 * A node asked to be inserted into an invalid location.
		 */
		HIERARCHY_REQUEST,
		/**
		 * A node created for one document wanted to be used in another.
		 */
		WRONG_DOCUMENT,
		/**
		 * An invalid character was found in a name.
		 */
		INVALID_CHARACTER,
		/**
		 * Tried to specify data for a node that did not support it.
		 */
		NO_DATA_ALLOWED,
		/**
		 * Attempted to modify a read-only node.
		 */
		NO_MODIFICATION_ALLOWED,
		/**
		 * A reference to a non-existent node was made.
		 */
		NOT_FOUND,
		/**
		 * A request was made for something that this implementation does not support.
		 */
		NOT_SUPPORTED,
		/**
		 * An element tried to make use of an attribute already attached to another element.
		 */
		INUSE_ATTRIBUTE,
		/**
		 * Generic error in creating the DOM.
		 */
		DOM,
		/**
		 * A document could not be parsed due to invalid XML.
		 */
		INVALID_DOC,
		/**
		 * A document lacked a root element.
		 */
		INVALID_ROOT,
		/**
		 * There was an issue with the namespace.  A qualified name's prefix may have disagreed with the corresponding namespace or vice versa.
		 *
		 * Version: DOM Level 3 Core<<BR>>
		 * URL: [[http://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMException-NAMESPACE_ERR]]
		 */
		NAMESPACE,
		/**
		 * Non-DOM error
		 */
		X_OTHER
	}
	/**
	 * Enumerates possible NodeTypes.
	 *
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-1950641247]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum NodeType {
		X_UNKNOWN,
		ELEMENT,
		ATTRIBUTE,
		TEXT,
		CDATA_SECTION,
		ENTITY_REFERENCE,
		ENTITY,
		PROCESSING_INSTRUCTION,
		COMMENT,
		DOCUMENT,
		DOCUMENT_TYPE,
		DOCUMENT_FRAGMENT,
		NOTATION
	}
	/**
	 * Errors for documents handling reading/writing
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain DocumentError {
		INVALID_DOCUMENT_ERROR,
		INVALID_FILE
	}
	/**
	 * Errors when de/serializing enumerations.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain EnumerationError {
		/**
		 * Given value is invalid in enumeration, when transform to string.
		 */
		INVALID_VALUE,
		/**
		 * Given text to transform to an enumeration's value.
		 */
		INVALID_TEXT
	}
	/**
	 * libmxl2 bindings for Errors on parse and write.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain Error {
		NOT_SUPPORTED,
		PARSER,
		WRITER
	}
	/**
	 * Errors when de/serializing enumerations as a set of string when using {@link GXml.SerializableEnum}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain SerializableEnumError {
		INVALID_VALUE_ERROR,
		PARSE_ERROR
	}
	/**
	 * Errors from {@link Serializable}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain SerializableError {
		/**
		 * An object with a known {@link GLib.Type} that we do not support was encountered.
		 */
		UNSUPPORTED_TYPE_ERROR,
		STR_TO_VALUE_ERROR
	}
	/**
	 * Last error exception for DOM.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public static GXml.DomException last_error;
	/**
	 * Log DOM exception warnings.
	 * 
	 * @param exception rised
	 * @param message message to log
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public static void exception (GXml.DomException ex, string message);
	/**
	 * Log DOM exception warnings.
	 * 
	 * @param exception rised
	 * @param message message to log
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	[Deprecated (replacement = "exeption", since = "0.8.1")]
	public static void warning (GXml.DomException ex, string message);
}
